# Chain adventure game design
_Exported on 12/26/2025 at 11:12:49 MST from Cursor (2.3.0-pre.21.patch.0)_

---

**User**

We are creating a game called chain. It is an adventure side-scroller, with a top-view world map that allows you to traverse between adventures.

The main character is Chain. Chain is in search of the lost princess, who has been kidnapped by the archenemy Cannon.

There should be two kinds of points, health and magic. health is depleted when Chain is hit by an enemy; magic is depleted when Chain uses a spell. Spells include both buffs (to reduce damage or increase jumping and running abilities) as well as offensive spells to damage enemies. Some challenges should require the use of spells.

Magic and health points should start with a max of 4 units, but finding special hearts and magic bottles should increase Chain's capacity for these points.

Enemies should be various, and have different levels of difficulty to defeat them.

Chain should be able to find magic vials and food to restore magic and health points, respectively.

Let's use pygame. Let's do it in 16-bit style.

---

**Cursor**

I'll create a comprehensive pygame side-scroller game with all the features you've described. This is a substantial project, so let me organize it well.

```pip-requirements
pygame==2.5.2

```

```markdown
# Chain - A 16-bit Adventure Side-Scroller

## Story
Chain is on a quest to rescue the lost princess, kidnapped by the archenemy **Cannon**. 
Navigate through dangerous lands, defeat enemies, and master magical spells to save her!

## Gameplay

### Controls
- **Arrow Keys / WASD**: Move Chain
- **Space**: Jump (in side-scroller mode)
- **Z**: Attack
- **X**: Cast selected spell
- **1-4**: Select spell slot
- **Enter**: Interact / Confirm
- **ESC**: Pause / Back

### Points System
- **Health (❤️)**: Starts at 4 max. Depleted when hit by enemies.
- **Magic (✨)**: Starts at 4 max. Depleted when casting spells.

### Collectibles
- **Food**: Restores health points
- **Magic Vials**: Restores magic points
- **Heart Containers**: Permanently increases max health
- **Magic Bottles**: Permanently increases max magic

### Spells
1. **Shield**: Reduces incoming damage (buff)
2. **Swift**: Increases movement and jump speed (buff)
3. **Fireball**: Ranged offensive spell
4. **Thunder**: Area-of-effect damage spell

### Enemies
Various enemies with different behaviors and difficulty levels:
- **Slimes**: Easy, slow-moving
- **Bats**: Medium, flying erratic patterns
- **Knights**: Hard, shielded and aggressive
- **Cannon** (Boss): The archenemy!

## Installation

```bash
pip install -r requirements.txt
python main.py
```

## Project Structure
```
chain/
├── main.py           # Game entry point
├── settings.py       # Game constants and configuration
├── game.py           # Main game class and loop
├── player.py         # Chain player class
├── enemies.py        # Enemy classes
├── items.py          # Collectible items
├── spells.py         # Spell system
├── world_map.py      # Top-view world map
├── level.py          # Side-scroller level
├── sprites.py        # Sprite rendering utilities
├── ui.py             # User interface elements
└── assets/           # Game assets (generated procedurally)
```

## 16-bit Aesthetic
The game features procedurally generated pixel art in a classic 16-bit style,
with vibrant colors and chunky sprites reminiscent of SNES/Genesis era games.

```

```python
"""
Game settings and constants for Chain
"""

# Display settings
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60
TILE_SIZE = 32
PIXEL_SCALE = 2  # For that chunky 16-bit look

# Game title
TITLE = "Chain - Quest for the Lost Princess"

# Colors - 16-bit palette inspired
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
DARK_BLUE = (24, 20, 37)
NAVY = (38, 43, 68)
PURPLE = (58, 68, 102)
SLATE = (90, 105, 136)
LIGHT_SLATE = (139, 155, 180)
SKY_BLUE = (87, 114, 119)
TEAL = (62, 137, 137)
CYAN = (116, 196, 182)
MINT = (177, 220, 176)

RED = (172, 50, 50)
DARK_RED = (102, 46, 46)
ORANGE = (223, 113, 38)
YELLOW = (251, 191, 69)
CREAM = (247, 228, 182)

GREEN = (75, 105, 47)
DARK_GREEN = (55, 75, 37)
LIME = (106, 190, 48)

PINK = (215, 123, 186)
MAGENTA = (143, 77, 137)

BROWN = (102, 57, 49)
DARK_BROWN = (63, 40, 50)
TAN = (143, 86, 59)
BEIGE = (217, 160, 102)

GRAY = (89, 86, 82)
LIGHT_GRAY = (155, 156, 130)

# Player settings
PLAYER_SPEED = 4
PLAYER_JUMP_SPEED = -12
PLAYER_GRAVITY = 0.5
PLAYER_MAX_HEALTH = 4
PLAYER_MAX_MAGIC = 4
PLAYER_ATTACK_COOLDOWN = 30  # frames
PLAYER_INVINCIBILITY_FRAMES = 60

# Spell costs
SPELL_COSTS = {
    'shield': 1,
    'swift': 1,
    'fireball': 2,
    'thunder': 3
}

# Spell durations (in frames, for buffs)
SPELL_DURATIONS = {
    'shield': 300,  # 5 seconds
    'swift': 240,   # 4 seconds
}

# Buff effects
SHIELD_DAMAGE_REDUCTION = 0.5
SWIFT_SPEED_MULTIPLIER = 1.5
SWIFT_JUMP_MULTIPLIER = 1.3

# Projectile settings
FIREBALL_SPEED = 8
FIREBALL_DAMAGE = 2
THUNDER_RADIUS = 80
THUNDER_DAMAGE = 3

# Enemy settings
ENEMY_TYPES = {
    'slime': {
        'health': 2,
        'damage': 1,
        'speed': 1,
        'score': 10,
        'color': LIME
    },
    'bat': {
        'health': 1,
        'damage': 1,
        'speed': 2.5,
        'score': 20,
        'color': PURPLE
    },
    'knight': {
        'health': 4,
        'damage': 2,
        'speed': 1.5,
        'score': 50,
        'color': SLATE
    },
    'cannon': {
        'health': 20,
        'damage': 3,
        'speed': 2,
        'score': 500,
        'color': DARK_RED
    }
}

# Item settings
ITEM_TYPES = {
    'food': {
        'heal': 1,
        'color': ORANGE
    },
    'feast': {
        'heal': 2,
        'color': YELLOW
    },
    'magic_vial': {
        'restore': 1,
        'color': CYAN
    },
    'magic_potion': {
        'restore': 2,
        'color': TEAL
    },
    'heart_container': {
        'max_health_increase': 1,
        'color': RED
    },
    'magic_bottle': {
        'max_magic_increase': 1,
        'color': MAGENTA
    }
}

# World map settings
WORLD_MAP_WIDTH = 25
WORLD_MAP_HEIGHT = 19
WORLD_PLAYER_SPEED = 3

# Level types
LEVEL_FOREST = 'forest'
LEVEL_CAVE = 'cave'
LEVEL_CASTLE = 'castle'
LEVEL_BOSS = 'boss'

# Game states
STATE_MENU = 'menu'
STATE_WORLD_MAP = 'world_map'
STATE_LEVEL = 'level'
STATE_PAUSE = 'pause'
STATE_GAME_OVER = 'game_over'
STATE_VICTORY = 'victory'

```

```python
"""
Sprite rendering utilities for 16-bit pixel art style
"""

import pygame
from settings import *


def create_pixel_surface(width, height, scale=PIXEL_SCALE):
    """Create a surface for pixel art that will be scaled up"""
    return pygame.Surface((width, height), pygame.SRCALPHA)


def scale_surface(surface, scale=PIXEL_SCALE):
    """Scale a surface up for that chunky 16-bit look"""
    w, h = surface.get_size()
    return pygame.transform.scale(surface, (w * scale, h * scale))


def draw_pixel_rect(surface, color, rect, scale=1):
    """Draw a rectangle with pixel-perfect edges"""
    pygame.draw.rect(surface, color, rect)


def create_chain_sprite(facing_right=True, frame=0):
    """Create Chain's sprite - the hero"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    # Body (tunic)
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (4, 6, 8, 7))
    
    # Head
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (5, 2, 6, 5))
    
    # Hair (blue-ish)
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (5, 1, 6, 2))
    pygame.draw.rect(surface, hair_color, (4, 2, 1, 2))
    if facing_right:
        pygame.draw.rect(surface, hair_color, (11, 2, 1, 3))
    else:
        pygame.draw.rect(surface, hair_color, (4, 2, 1, 3))
    
    # Eyes
    eye_color = DARK_BLUE
    if facing_right:
        pygame.draw.rect(surface, eye_color, (9, 4, 1, 1))
    else:
        pygame.draw.rect(surface, eye_color, (6, 4, 1, 1))
    
    # Legs (animated)
    leg_color = BROWN
    if frame % 2 == 0:
        pygame.draw.rect(surface, leg_color, (5, 13, 2, 3))
        pygame.draw.rect(surface, leg_color, (9, 13, 2, 3))
    else:
        pygame.draw.rect(surface, leg_color, (4, 13, 2, 3))
        pygame.draw.rect(surface, leg_color, (10, 13, 2, 3))
    
    # Boots
    boot_color = DARK_BROWN
    if frame % 2 == 0:
        pygame.draw.rect(surface, boot_color, (5, 15, 2, 1))
        pygame.draw.rect(surface, boot_color, (9, 15, 2, 1))
    else:
        pygame.draw.rect(surface, boot_color, (4, 15, 2, 1))
        pygame.draw.rect(surface, boot_color, (10, 15, 2, 1))
    
    # Belt
    belt_color = BROWN
    pygame.draw.rect(surface, belt_color, (4, 10, 8, 1))
    
    # Belt buckle (chain link symbol)
    pygame.draw.rect(surface, YELLOW, (7, 10, 2, 1))
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_chain_attack_sprite(facing_right=True):
    """Create Chain's attack sprite with sword"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    # Base character (offset to make room for sword)
    offset_x = 4 if facing_right else 4
    
    # Body
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (offset_x + 4, 6, 8, 7))
    
    # Head
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (offset_x + 5, 2, 6, 5))
    
    # Hair
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (offset_x + 5, 1, 6, 2))
    
    # Eyes
    eye_color = DARK_BLUE
    if facing_right:
        pygame.draw.rect(surface, eye_color, (offset_x + 9, 4, 1, 1))
    else:
        pygame.draw.rect(surface, eye_color, (offset_x + 6, 4, 1, 1))
    
    # Legs
    leg_color = BROWN
    pygame.draw.rect(surface, leg_color, (offset_x + 5, 13, 2, 3))
    pygame.draw.rect(surface, leg_color, (offset_x + 9, 13, 2, 3))
    
    # Sword
    sword_color = LIGHT_SLATE
    sword_handle = BROWN
    if facing_right:
        pygame.draw.rect(surface, sword_handle, (offset_x + 12, 6, 2, 3))
        pygame.draw.rect(surface, sword_color, (offset_x + 14, 4, 6, 2))
        pygame.draw.rect(surface, YELLOW, (offset_x + 12, 5, 3, 1))  # Guard
    else:
        pygame.draw.rect(surface, sword_handle, (offset_x - 2, 6, 2, 3))
        pygame.draw.rect(surface, sword_color, (offset_x - 8, 4, 6, 2))
        pygame.draw.rect(surface, YELLOW, (offset_x - 3, 5, 3, 1))  # Guard
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_slime_sprite(frame=0):
    """Create slime enemy sprite"""
    size = 12
    surface = create_pixel_surface(size, size)
    
    color = LIME
    dark = DARK_GREEN
    
    # Body (bouncy animation)
    if frame % 20 < 10:
        pygame.draw.rect(surface, dark, (1, 6, 10, 6))
        pygame.draw.rect(surface, color, (2, 4, 8, 6))
        pygame.draw.rect(surface, color, (3, 3, 6, 2))
    else:
        pygame.draw.rect(surface, dark, (0, 8, 12, 4))
        pygame.draw.rect(surface, color, (1, 6, 10, 4))
        pygame.draw.rect(surface, color, (2, 5, 8, 2))
    
    # Eyes
    pygame.draw.rect(surface, WHITE, (3, 5, 2, 2))
    pygame.draw.rect(surface, WHITE, (7, 5, 2, 2))
    pygame.draw.rect(surface, BLACK, (4, 6, 1, 1))
    pygame.draw.rect(surface, BLACK, (8, 6, 1, 1))
    
    return scale_surface(surface)


def create_bat_sprite(frame=0):
    """Create bat enemy sprite"""
    size = 14
    surface = create_pixel_surface(size, size)
    
    color = PURPLE
    dark = DARK_BLUE
    
    # Body
    pygame.draw.rect(surface, color, (5, 5, 4, 5))
    pygame.draw.rect(surface, dark, (6, 4, 2, 2))
    
    # Wings (animated)
    if frame % 10 < 5:
        # Wings up
        pygame.draw.rect(surface, color, (0, 3, 5, 3))
        pygame.draw.rect(surface, color, (9, 3, 5, 3))
        pygame.draw.rect(surface, color, (1, 2, 3, 2))
        pygame.draw.rect(surface, color, (10, 2, 3, 2))
    else:
        # Wings down
        pygame.draw.rect(surface, color, (0, 6, 5, 3))
        pygame.draw.rect(surface, color, (9, 6, 5, 3))
        pygame.draw.rect(surface, color, (1, 8, 3, 2))
        pygame.draw.rect(surface, color, (10, 8, 3, 2))
    
    # Eyes (red, menacing)
    pygame.draw.rect(surface, RED, (5, 5, 1, 1))
    pygame.draw.rect(surface, RED, (8, 5, 1, 1))
    
    # Ears
    pygame.draw.rect(surface, color, (5, 3, 1, 2))
    pygame.draw.rect(surface, color, (8, 3, 1, 2))
    
    return scale_surface(surface)


def create_knight_sprite(facing_right=True, frame=0):
    """Create knight enemy sprite - armored and tough"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    armor_color = SLATE
    armor_dark = GRAY
    visor_color = DARK_BLUE
    
    # Body (armor)
    pygame.draw.rect(surface, armor_dark, (4, 6, 8, 7))
    pygame.draw.rect(surface, armor_color, (5, 5, 6, 6))
    
    # Helmet
    pygame.draw.rect(surface, armor_dark, (4, 1, 8, 5))
    pygame.draw.rect(surface, armor_color, (5, 2, 6, 3))
    
    # Visor
    pygame.draw.rect(surface, visor_color, (6, 3, 4, 2))
    pygame.draw.rect(surface, RED, (7, 3, 1, 1))  # Glowing eye
    pygame.draw.rect(surface, RED, (9, 3, 1, 1))  # Glowing eye
    
    # Shield
    if facing_right:
        pygame.draw.rect(surface, armor_dark, (2, 6, 3, 5))
        pygame.draw.rect(surface, armor_color, (2, 7, 2, 3))
    else:
        pygame.draw.rect(surface, armor_dark, (11, 6, 3, 5))
        pygame.draw.rect(surface, armor_color, (12, 7, 2, 3))
    
    # Sword
    sword_color = LIGHT_SLATE
    if facing_right:
        pygame.draw.rect(surface, sword_color, (12, 4, 2, 6))
        pygame.draw.rect(surface, sword_color, (13, 2, 1, 3))
    else:
        pygame.draw.rect(surface, sword_color, (2, 4, 2, 6))
        pygame.draw.rect(surface, sword_color, (2, 2, 1, 3))
    
    # Legs (armored)
    if frame % 2 == 0:
        pygame.draw.rect(surface, armor_dark, (5, 13, 2, 3))
        pygame.draw.rect(surface, armor_dark, (9, 13, 2, 3))
    else:
        pygame.draw.rect(surface, armor_dark, (4, 13, 2, 3))
        pygame.draw.rect(surface, armor_dark, (10, 13, 2, 3))
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_cannon_sprite(frame=0):
    """Create Cannon (boss) sprite - the archenemy"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    # Cape
    cape_color = DARK_RED
    pygame.draw.rect(surface, cape_color, (2, 6, 20, 14))
    pygame.draw.rect(surface, RED, (4, 8, 16, 10))
    
    # Body (dark armor)
    armor_color = DARK_BLUE
    armor_accent = NAVY
    pygame.draw.rect(surface, armor_color, (7, 6, 10, 10))
    pygame.draw.rect(surface, armor_accent, (8, 7, 8, 8))
    
    # Head (helmet with crown)
    pygame.draw.rect(surface, armor_color, (8, 1, 8, 6))
    pygame.draw.rect(surface, DARK_RED, (9, 3, 6, 3))  # Visor
    
    # Crown spikes
    pygame.draw.rect(surface, YELLOW, (8, 0, 2, 2))
    pygame.draw.rect(surface, YELLOW, (11, 0, 2, 1))
    pygame.draw.rect(surface, YELLOW, (14, 0, 2, 2))
    
    # Evil eyes
    pygame.draw.rect(surface, YELLOW, (10, 3, 1, 1))
    pygame.draw.rect(surface, YELLOW, (13, 3, 1, 1))
    
    # Cannon arm (signature weapon)
    cannon_color = GRAY
    if frame % 30 < 15:
        pygame.draw.rect(surface, cannon_color, (17, 8, 6, 4))
        pygame.draw.rect(surface, DARK_BROWN, (16, 9, 2, 2))
        pygame.draw.rect(surface, ORANGE, (22, 9, 2, 2))  # Charging
    else:
        pygame.draw.rect(surface, cannon_color, (17, 8, 6, 4))
        pygame.draw.rect(surface, DARK_BROWN, (16, 9, 2, 2))
    
    # Legs
    pygame.draw.rect(surface, armor_color, (8, 16, 3, 6))
    pygame.draw.rect(surface, armor_color, (13, 16, 3, 6))
    pygame.draw.rect(surface, DARK_BROWN, (8, 21, 3, 2))
    pygame.draw.rect(surface, DARK_BROWN, (13, 21, 3, 2))
    
    return scale_surface(surface)


def create_heart_sprite(full=True, is_container=False):
    """Create heart sprite for health display"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if is_container:
        color = YELLOW
        outline = ORANGE
    elif full:
        color = RED
        outline = DARK_RED
    else:
        color = GRAY
        outline = DARK_BROWN
    
    # Heart shape
    pygame.draw.rect(surface, outline, (1, 2, 3, 3))
    pygame.draw.rect(surface, outline, (6, 2, 3, 3))
    pygame.draw.rect(surface, outline, (0, 3, 2, 3))
    pygame.draw.rect(surface, outline, (8, 3, 2, 3))
    pygame.draw.rect(surface, outline, (2, 5, 6, 3))
    pygame.draw.rect(surface, outline, (3, 8, 4, 1))
    pygame.draw.rect(surface, outline, (4, 9, 2, 1))
    
    # Fill
    pygame.draw.rect(surface, color, (2, 3, 2, 2))
    pygame.draw.rect(surface, color, (6, 3, 2, 2))
    pygame.draw.rect(surface, color, (1, 4, 2, 2))
    pygame.draw.rect(surface, color, (7, 4, 2, 2))
    pygame.draw.rect(surface, color, (3, 5, 4, 2))
    pygame.draw.rect(surface, color, (4, 7, 2, 1))
    
    # Highlight
    if full or is_container:
        pygame.draw.rect(surface, WHITE, (2, 3, 1, 1))
    
    return scale_surface(surface)


def create_magic_sprite(full=True, is_bottle=False):
    """Create magic point sprite (star/crystal)"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if is_bottle:
        color = MAGENTA
        outline = PURPLE
    elif full:
        color = CYAN
        outline = TEAL
    else:
        color = GRAY
        outline = DARK_BROWN
    
    # Crystal/star shape
    pygame.draw.rect(surface, outline, (4, 0, 2, 2))
    pygame.draw.rect(surface, outline, (3, 2, 4, 2))
    pygame.draw.rect(surface, outline, (0, 3, 10, 2))
    pygame.draw.rect(surface, outline, (2, 5, 6, 2))
    pygame.draw.rect(surface, outline, (3, 7, 4, 2))
    pygame.draw.rect(surface, outline, (4, 9, 2, 1))
    
    # Fill
    pygame.draw.rect(surface, color, (4, 1, 2, 1))
    pygame.draw.rect(surface, color, (3, 3, 4, 1))
    pygame.draw.rect(surface, color, (1, 4, 8, 1))
    pygame.draw.rect(surface, color, (3, 5, 4, 1))
    pygame.draw.rect(surface, color, (4, 6, 2, 2))
    
    # Highlight
    if full or is_bottle:
        pygame.draw.rect(surface, WHITE, (4, 3, 1, 1))
    
    return scale_surface(surface)


def create_food_sprite(food_type='food'):
    """Create food item sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if food_type == 'feast':
        # Roasted chicken leg
        pygame.draw.rect(surface, TAN, (2, 2, 6, 5))
        pygame.draw.rect(surface, BEIGE, (3, 3, 4, 3))
        pygame.draw.rect(surface, BROWN, (1, 6, 2, 3))  # Bone
        pygame.draw.rect(surface, CREAM, (1, 8, 2, 1))
    else:
        # Apple
        pygame.draw.rect(surface, RED, (2, 3, 6, 5))
        pygame.draw.rect(surface, RED, (3, 2, 4, 1))
        pygame.draw.rect(surface, DARK_RED, (2, 6, 6, 2))
        pygame.draw.rect(surface, BROWN, (4, 0, 2, 3))  # Stem
        pygame.draw.rect(surface, GREEN, (5, 1, 2, 2))  # Leaf
        pygame.draw.rect(surface, WHITE, (3, 3, 1, 1))  # Highlight
    
    return scale_surface(surface)


def create_magic_vial_sprite(vial_type='magic_vial'):
    """Create magic vial sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if vial_type == 'magic_potion':
        color = TEAL
        liquid = CYAN
    else:
        color = PURPLE
        liquid = MAGENTA
    
    # Bottle
    pygame.draw.rect(surface, LIGHT_GRAY, (3, 0, 4, 2))  # Cork
    pygame.draw.rect(surface, LIGHT_SLATE, (2, 2, 6, 2))  # Neck
    pygame.draw.rect(surface, LIGHT_SLATE, (1, 4, 8, 5))  # Body outline
    
    # Liquid
    pygame.draw.rect(surface, color, (2, 5, 6, 3))
    pygame.draw.rect(surface, liquid, (3, 6, 4, 2))
    
    # Highlight
    pygame.draw.rect(surface, WHITE, (2, 4, 1, 2))
    
    # Sparkle
    pygame.draw.rect(surface, WHITE, (5, 5, 1, 1))
    
    return scale_surface(surface)


def create_fireball_sprite(frame=0):
    """Create fireball projectile sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    # Core
    pygame.draw.rect(surface, YELLOW, (3, 3, 4, 4))
    pygame.draw.rect(surface, WHITE, (4, 4, 2, 2))
    
    # Flames (animated)
    if frame % 4 < 2:
        pygame.draw.rect(surface, ORANGE, (2, 2, 2, 2))
        pygame.draw.rect(surface, ORANGE, (6, 2, 2, 2))
        pygame.draw.rect(surface, ORANGE, (2, 6, 2, 2))
        pygame.draw.rect(surface, ORANGE, (6, 6, 2, 2))
        pygame.draw.rect(surface, RED, (1, 4, 2, 2))
    else:
        pygame.draw.rect(surface, ORANGE, (1, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (7, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (1, 5, 2, 2))
        pygame.draw.rect(surface, ORANGE, (7, 5, 2, 2))
        pygame.draw.rect(surface, RED, (0, 4, 2, 2))
    
    return scale_surface(surface)


def create_thunder_sprite(frame=0):
    """Create thunder effect sprite"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    # Lightning bolt shape
    color = YELLOW if frame % 4 < 2 else WHITE
    
    pygame.draw.rect(surface, color, (8, 0, 3, 4))
    pygame.draw.rect(surface, color, (6, 3, 4, 3))
    pygame.draw.rect(surface, color, (4, 5, 6, 3))
    pygame.draw.rect(surface, color, (6, 7, 4, 3))
    pygame.draw.rect(surface, color, (8, 9, 3, 4))
    pygame.draw.rect(surface, color, (10, 12, 2, 4))
    
    return scale_surface(surface)


def create_shield_effect_sprite(frame=0):
    """Create shield buff visual effect"""
    size = 20
    surface = create_pixel_surface(size, size)
    
    # Shimmering shield
    alpha = 128 + int(64 * ((frame % 30) / 30))
    color = (*CYAN[:3], alpha)
    
    # Circular shield
    for i in range(8):
        angle_offset = (frame * 3 + i * 45) % 360
        x = int(10 + 7 * (1 if i % 2 == 0 else -1) * ((frame + i * 5) % 10) / 10)
        y = int(10 + 7 * (1 if i < 4 else -1) * ((frame + i * 5) % 10) / 10)
        pygame.draw.rect(surface, CYAN, (x, y, 2, 2))
    
    # Border
    pygame.draw.rect(surface, TEAL, (0, 8, 2, 4))
    pygame.draw.rect(surface, TEAL, (18, 8, 2, 4))
    pygame.draw.rect(surface, TEAL, (8, 0, 4, 2))
    pygame.draw.rect(surface, TEAL, (8, 18, 4, 2))
    
    return scale_surface(surface)


def create_tile_sprite(tile_type, variant=0):
    """Create tile sprites for levels"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    if tile_type == 'grass':
        pygame.draw.rect(surface, GREEN, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIME, (0, 0, 16, 4))
        # Grass detail
        for i in range(4):
            x = (i * 4 + variant) % 16
            pygame.draw.rect(surface, DARK_GREEN, (x, 4, 1, 2))
    
    elif tile_type == 'dirt':
        pygame.draw.rect(surface, BROWN, (0, 0, 16, 16))
        pygame.draw.rect(surface, TAN, (2, 2, 3, 2))
        pygame.draw.rect(surface, TAN, (10, 8, 4, 3))
        pygame.draw.rect(surface, DARK_BROWN, (6, 12, 2, 2))
    
    elif tile_type == 'stone':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIGHT_GRAY, (1, 1, 6, 5))
        pygame.draw.rect(surface, LIGHT_GRAY, (9, 8, 5, 6))
        pygame.draw.rect(surface, DARK_BROWN, (0, 7, 16, 1))
        pygame.draw.rect(surface, DARK_BROWN, (7, 0, 1, 16))
    
    elif tile_type == 'brick':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        # Brick pattern
        pygame.draw.rect(surface, RED, (1, 1, 6, 6))
        pygame.draw.rect(surface, RED, (9, 1, 6, 6))
        pygame.draw.rect(surface, RED, (1, 9, 14, 6))
        pygame.draw.rect(surface, BROWN, (0, 7, 16, 2))
        pygame.draw.rect(surface, BROWN, (7, 0, 2, 8))
    
    elif tile_type == 'wood':
        pygame.draw.rect(surface, BROWN, (0, 0, 16, 16))
        # Wood grain
        for i in range(4):
            y = i * 4 + 1
            pygame.draw.rect(surface, TAN, (0, y, 16, 2))
        pygame.draw.rect(surface, DARK_BROWN, (4, 0, 1, 16))
        pygame.draw.rect(surface, DARK_BROWN, (11, 0, 1, 16))
    
    elif tile_type == 'water':
        base = TEAL if variant % 2 == 0 else SKY_BLUE
        pygame.draw.rect(surface, base, (0, 0, 16, 16))
        # Waves
        wave_color = CYAN
        for i in range(3):
            x = (i * 6 + variant * 2) % 16
            pygame.draw.rect(surface, wave_color, (x, 4, 4, 1))
            pygame.draw.rect(surface, wave_color, ((x + 3) % 16, 10, 4, 1))
    
    elif tile_type == 'lava':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        pygame.draw.rect(surface, RED, (2, 2, 5, 4))
        pygame.draw.rect(surface, RED, (9, 7, 5, 5))
        pygame.draw.rect(surface, ORANGE, (3, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (10, 9, 3, 2))
        pygame.draw.rect(surface, YELLOW, (4, 3, 1, 1))
    
    elif tile_type == 'sky':
        pygame.draw.rect(surface, SKY_BLUE, (0, 0, 16, 16))
        if variant % 3 == 0:
            # Cloud
            pygame.draw.rect(surface, WHITE, (2, 4, 8, 4))
            pygame.draw.rect(surface, WHITE, (4, 2, 4, 2))
    
    return scale_surface(surface)


def create_world_map_tile(tile_type):
    """Create tiles for the world map"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    if tile_type == 'grass':
        pygame.draw.rect(surface, GREEN, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIME, (3, 3, 2, 2))
        pygame.draw.rect(surface, LIME, (10, 8, 2, 2))
        pygame.draw.rect(surface, DARK_GREEN, (7, 12, 2, 2))
    
    elif tile_type == 'forest':
        pygame.draw.rect(surface, DARK_GREEN, (0, 0, 16, 16))
        # Trees
        pygame.draw.rect(surface, GREEN, (2, 4, 4, 6))
        pygame.draw.rect(surface, GREEN, (10, 2, 4, 8))
        pygame.draw.rect(surface, BROWN, (3, 10, 2, 4))
        pygame.draw.rect(surface, BROWN, (11, 10, 2, 4))
    
    elif tile_type == 'mountain':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        # Mountain peak
        pygame.draw.rect(surface, SLATE, (6, 0, 4, 6))
        pygame.draw.rect(surface, SLATE, (4, 6, 8, 4))
        pygame.draw.rect(surface, SLATE, (2, 10, 12, 6))
        pygame.draw.rect(surface, WHITE, (7, 1, 2, 3))  # Snow cap
    
    elif tile_type == 'water':
        pygame.draw.rect(surface, NAVY, (0, 0, 16, 16))
        pygame.draw.rect(surface, TEAL, (2, 4, 6, 2))
        pygame.draw.rect(surface, TEAL, (8, 10, 6, 2))
    
    elif tile_type == 'path':
        pygame.draw.rect(surface, GREEN, (0, 0, 16, 16))
        pygame.draw.rect(surface, TAN, (4, 0, 8, 16))
        pygame.draw.rect(surface, BEIGE, (6, 2, 4, 4))
        pygame.draw.rect(surface, BEIGE, (6, 10, 4, 4))
    
    elif tile_type == 'castle':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        # Castle structure
        pygame.draw.rect(surface, SLATE, (2, 4, 12, 12))
        pygame.draw.rect(surface, SLATE, (0, 2, 4, 4))
        pygame.draw.rect(surface, SLATE, (12, 2, 4, 4))
        pygame.draw.rect(surface, DARK_BLUE, (6, 10, 4, 6))  # Door
        pygame.draw.rect(surface, RED, (2, 0, 2, 3))  # Flag
    
    elif tile_type == 'cave':
        pygame.draw.rect(surface, DARK_BROWN, (0, 0, 16, 16))
        pygame.draw.rect(surface, BLACK, (4, 6, 8, 10))
        pygame.draw.rect(surface, DARK_BROWN, (2, 4, 12, 4))
    
    elif tile_type == 'boss':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        # Evil castle
        pygame.draw.rect(surface, DARK_BLUE, (2, 4, 12, 12))
        pygame.draw.rect(surface, DARK_BLUE, (0, 2, 4, 4))
        pygame.draw.rect(surface, DARK_BLUE, (12, 2, 4, 4))
        pygame.draw.rect(surface, BLACK, (6, 10, 4, 6))
        pygame.draw.rect(surface, YELLOW, (4, 6, 2, 2))  # Evil eye
        pygame.draw.rect(surface, YELLOW, (10, 6, 2, 2))  # Evil eye
    
    elif tile_type == 'level_marker':
        pygame.draw.rect(surface, YELLOW, (4, 4, 8, 8))
        pygame.draw.rect(surface, ORANGE, (6, 6, 4, 4))
    
    return scale_surface(surface)


def create_chain_world_sprite(facing='down', frame=0):
    """Create Chain sprite for world map (top-down view)"""
    size = 12
    surface = create_pixel_surface(size, size)
    
    # Body
    pygame.draw.rect(surface, TEAL, (3, 3, 6, 6))
    
    # Head direction
    skin = BEIGE
    hair = NAVY
    
    if facing == 'down':
        pygame.draw.rect(surface, hair, (4, 2, 4, 2))
        pygame.draw.rect(surface, skin, (4, 4, 4, 3))
        pygame.draw.rect(surface, DARK_BLUE, (5, 5, 1, 1))
        pygame.draw.rect(surface, DARK_BLUE, (7, 5, 1, 1))
    elif facing == 'up':
        pygame.draw.rect(surface, hair, (4, 2, 4, 4))
        pygame.draw.rect(surface, skin, (5, 5, 2, 2))
    elif facing == 'left':
        pygame.draw.rect(surface, hair, (3, 2, 4, 3))
        pygame.draw.rect(surface, skin, (3, 4, 3, 3))
        pygame.draw.rect(surface, DARK_BLUE, (3, 5, 1, 1))
    elif facing == 'right':
        pygame.draw.rect(surface, hair, (5, 2, 4, 3))
        pygame.draw.rect(surface, skin, (6, 4, 3, 3))
        pygame.draw.rect(surface, DARK_BLUE, (8, 5, 1, 1))
    
    # Feet (animated)
    if frame % 20 < 10:
        pygame.draw.rect(surface, BROWN, (3, 9, 2, 2))
        pygame.draw.rect(surface, BROWN, (7, 9, 2, 2))
    else:
        pygame.draw.rect(surface, BROWN, (4, 9, 2, 2))
        pygame.draw.rect(surface, BROWN, (6, 9, 2, 2))
    
    return scale_surface(surface)

```

```python
"""
Spell system for Chain
"""

import pygame
import math
from settings import *
from sprites import create_fireball_sprite, create_thunder_sprite, create_shield_effect_sprite


class Spell:
    """Base spell class"""
    
    def __init__(self, name, cost, spell_type):
        self.name = name
        self.cost = cost
        self.spell_type = spell_type  # 'buff' or 'offensive'
        self.active = False
        self.duration = 0
        self.frame = 0
    
    def can_cast(self, magic_points):
        return magic_points >= self.cost
    
    def cast(self, caster, target_pos=None, facing_right=True):
        """Override in subclasses"""
        pass
    
    def update(self):
        self.frame += 1
    
    def draw(self, surface, pos):
        pass


class ShieldSpell(Spell):
    """Shield buff - reduces incoming damage"""
    
    def __init__(self):
        super().__init__('Shield', SPELL_COSTS['shield'], 'buff')
        self.duration = SPELL_DURATIONS['shield']
        self.remaining_duration = 0
    
    def cast(self, caster, target_pos=None, facing_right=True):
        self.active = True
        self.remaining_duration = self.duration
        return True
    
    def update(self):
        super().update()
        if self.active:
            self.remaining_duration -= 1
            if self.remaining_duration <= 0:
                self.active = False
    
    def get_damage_multiplier(self):
        if self.active:
            return SHIELD_DAMAGE_REDUCTION
        return 1.0
    
    def draw(self, surface, pos):
        if self.active:
            sprite = create_shield_effect_sprite(self.frame)
            # Center on player
            x = pos[0] - sprite.get_width() // 2
            y = pos[1] - sprite.get_height() // 2
            surface.blit(sprite, (x, y))


class SwiftSpell(Spell):
    """Swift buff - increases movement and jump speed"""
    
    def __init__(self):
        super().__init__('Swift', SPELL_COSTS['swift'], 'buff')
        self.duration = SPELL_DURATIONS['swift']
        self.remaining_duration = 0
    
    def cast(self, caster, target_pos=None, facing_right=True):
        self.active = True
        self.remaining_duration = self.duration
        return True
    
    def update(self):
        super().update()
        if self.active:
            self.remaining_duration -= 1
            if self.remaining_duration <= 0:
                self.active = False
    
    def get_speed_multiplier(self):
        if self.active:
            return SWIFT_SPEED_MULTIPLIER
        return 1.0
    
    def get_jump_multiplier(self):
        if self.active:
            return SWIFT_JUMP_MULTIPLIER
        return 1.0
    
    def draw(self, surface, pos):
        if self.active:
            # Draw speed lines
            for i in range(3):
                alpha = 150 - i * 40
                line_x = pos[0] - 20 - i * 10 - (self.frame % 10)
                line_y = pos[1] - 5 + i * 8
                pygame.draw.rect(surface, (*CYAN[:3],), (line_x, line_y, 15, 2))


class Fireball(pygame.sprite.Sprite):
    """Fireball projectile"""
    
    def __init__(self, x, y, facing_right):
        super().__init__()
        self.frame = 0
        self.image = create_fireball_sprite(self.frame)
        self.rect = self.image.get_rect(center=(x, y))
        self.direction = 1 if facing_right else -1
        self.speed = FIREBALL_SPEED
        self.damage = FIREBALL_DAMAGE
        self.lifetime = 120  # frames
    
    def update(self):
        self.frame += 1
        self.rect.x += self.speed * self.direction
        self.image = create_fireball_sprite(self.frame)
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()


class FireballSpell(Spell):
    """Fireball offensive spell"""
    
    def __init__(self):
        super().__init__('Fireball', SPELL_COSTS['fireball'], 'offensive')
        self.projectiles = pygame.sprite.Group()
    
    def cast(self, caster, target_pos=None, facing_right=True):
        # Create fireball projectile
        fireball = Fireball(caster.rect.centerx, caster.rect.centery, facing_right)
        self.projectiles.add(fireball)
        return fireball
    
    def update(self):
        super().update()
        self.projectiles.update()
    
    def draw(self, surface, pos):
        self.projectiles.draw(surface)
    
    def get_projectiles(self):
        return self.projectiles


class ThunderEffect(pygame.sprite.Sprite):
    """Thunder area effect"""
    
    def __init__(self, x, y):
        super().__init__()
        self.frame = 0
        self.image = create_thunder_sprite(self.frame)
        self.rect = self.image.get_rect(center=(x, y))
        self.damage = THUNDER_DAMAGE
        self.radius = THUNDER_RADIUS
        self.lifetime = 30  # frames
        self.hit_enemies = set()  # Track which enemies have been hit
    
    def update(self):
        self.frame += 1
        self.image = create_thunder_sprite(self.frame)
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def can_hit(self, enemy):
        """Check if enemy is in range and hasn't been hit yet"""
        if enemy in self.hit_enemies:
            return False
        
        # Calculate distance
        dx = enemy.rect.centerx - self.rect.centerx
        dy = enemy.rect.centery - self.rect.centery
        distance = math.sqrt(dx * dx + dy * dy)
        
        if distance <= self.radius:
            self.hit_enemies.add(enemy)
            return True
        return False


class ThunderSpell(Spell):
    """Thunder area-of-effect offensive spell"""
    
    def __init__(self):
        super().__init__('Thunder', SPELL_COSTS['thunder'], 'offensive')
        self.effects = pygame.sprite.Group()
    
    def cast(self, caster, target_pos=None, facing_right=True):
        # Create thunder effect at player position
        offset = 50 if facing_right else -50
        thunder = ThunderEffect(caster.rect.centerx + offset, caster.rect.centery)
        self.effects.add(thunder)
        return thunder
    
    def update(self):
        super().update()
        self.effects.update()
    
    def draw(self, surface, pos):
        self.effects.draw(surface)
    
    def get_effects(self):
        return self.effects


class SpellManager:
    """Manages all spells for the player"""
    
    def __init__(self):
        self.spells = {
            'shield': ShieldSpell(),
            'swift': SwiftSpell(),
            'fireball': FireballSpell(),
            'thunder': ThunderSpell()
        }
        self.spell_order = ['shield', 'swift', 'fireball', 'thunder']
        self.selected_spell = 0
    
    def get_current_spell(self):
        spell_name = self.spell_order[self.selected_spell]
        return self.spells[spell_name]
    
    def select_spell(self, index):
        if 0 <= index < len(self.spell_order):
            self.selected_spell = index
    
    def next_spell(self):
        self.selected_spell = (self.selected_spell + 1) % len(self.spell_order)
    
    def prev_spell(self):
        self.selected_spell = (self.selected_spell - 1) % len(self.spell_order)
    
    def cast_current_spell(self, caster, magic_points, facing_right=True):
        spell = self.get_current_spell()
        if spell.can_cast(magic_points):
            result = spell.cast(caster, facing_right=facing_right)
            if result:
                return spell.cost
        return 0
    
    def update(self):
        for spell in self.spells.values():
            spell.update()
    
    def draw(self, surface, player_pos):
        for spell in self.spells.values():
            spell.draw(surface, player_pos)
    
    def get_speed_multiplier(self):
        return self.spells['swift'].get_speed_multiplier()
    
    def get_jump_multiplier(self):
        return self.spells['swift'].get_jump_multiplier()
    
    def get_damage_multiplier(self):
        return self.spells['shield'].get_damage_multiplier()
    
    def get_active_buffs(self):
        """Return list of active buff names"""
        active = []
        if self.spells['shield'].active:
            active.append('shield')
        if self.spells['swift'].active:
            active.append('swift')
        return active
    
    def get_projectiles(self):
        """Return all active projectiles"""
        return self.spells['fireball'].get_projectiles()
    
    def get_effects(self):
        """Return all active effects (thunder)"""
        return self.spells['thunder'].get_effects()

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import create_chain_sprite, create_chain_attack_sprite, create_chain_world_sprite
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-4)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Enemy classes for Chain
"""

import pygame
import math
import random
from settings import *
from sprites import create_slime_sprite, create_bat_sprite, create_knight_sprite, create_cannon_sprite


class Enemy(pygame.sprite.Sprite):
    """Base enemy class"""
    
    def __init__(self, x, y, enemy_type):
        super().__init__()
        self.enemy_type = enemy_type
        self.stats = ENEMY_TYPES[enemy_type]
        
        self.max_health = self.stats['health']
        self.health = self.max_health
        self.damage = self.stats['damage']
        self.speed = self.stats['speed']
        self.score = self.stats['score']
        
        self.frame = 0
        self.facing_right = True
        
        # AI state
        self.state = 'patrol'
        self.patrol_distance = 100
        self.start_x = x
        self.direction = 1
        
        # Physics
        self.velocity_x = 0
        self.velocity_y = 0
        
        # Combat
        self.hurt_timer = 0
        self.attack_cooldown = 0
        
        # Create initial sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
    
    def update_sprite(self):
        """Override in subclasses"""
        pass
    
    def update(self, player=None, tiles=None):
        """Update enemy state"""
        self.frame += 1
        
        if self.hurt_timer > 0:
            self.hurt_timer -= 1
        
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        self.ai_update(player)
        self.physics_update(tiles)
        self.update_sprite()
    
    def ai_update(self, player):
        """AI behavior - override in subclasses"""
        pass
    
    def physics_update(self, tiles):
        """Apply physics"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:
            self.velocity_y = 15
        
        # Move
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def take_damage(self, amount):
        """Take damage"""
        self.health -= amount
        self.hurt_timer = 10
        
        if self.health <= 0:
            self.kill()
            return True  # Enemy died
        return False
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw enemy"""
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.hurt_timer > 0 and self.frame % 4 < 2:
            return
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw health bar for tough enemies
        if self.max_health > 2:
            self.draw_health_bar(surface, camera_offset)
    
    def draw_health_bar(self, surface, camera_offset):
        """Draw health bar above enemy"""
        bar_width = 30
        bar_height = 4
        
        x = self.rect.centerx - camera_offset[0] - bar_width // 2
        y = self.rect.top - camera_offset[1] - 8
        
        # Background
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health
        health_width = int(bar_width * (self.health / self.max_health))
        pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))


class Slime(Enemy):
    """Slime enemy - easy, hops around"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'slime')
        self.hop_timer = 0
    
    def update_sprite(self):
        self.image = create_slime_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Hop periodically
        self.hop_timer += 1
        if self.hop_timer >= 60:
            self.hop_timer = 0
            self.velocity_y = -6
            
            # Move toward player if nearby, otherwise patrol
            if player and abs(player.rect.centerx - self.rect.centerx) < 200:
                if player.rect.centerx < self.rect.centerx:
                    self.velocity_x = -self.speed * 2
                else:
                    self.velocity_x = self.speed * 2
            else:
                # Patrol
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                self.velocity_x = self.speed * self.direction


class Bat(Enemy):
    """Bat enemy - flying, erratic movement"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'bat')
        self.start_y = y
        self.angle = 0
        self.swoop_target = None
    
    def update_sprite(self):
        self.image = create_bat_sprite(self.frame)
    
    def ai_update(self, player):
        # Erratic flying pattern
        self.angle += 0.05
        
        if player and abs(player.rect.centerx - self.rect.centerx) < 150:
            # Swoop toward player
            dx = player.rect.centerx - self.rect.centerx
            dy = player.rect.centery - self.rect.centery
            dist = math.sqrt(dx * dx + dy * dy)
            
            if dist > 0:
                self.velocity_x = (dx / dist) * self.speed * 1.5
                self.velocity_y = (dy / dist) * self.speed * 1.5
        else:
            # Patrol pattern
            self.velocity_x = math.sin(self.angle) * self.speed
            self.velocity_y = math.cos(self.angle * 2) * self.speed * 0.5
        
        self.facing_right = self.velocity_x > 0
    
    def physics_update(self, tiles):
        # Bats don't use gravity
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Keep within bounds
        if self.rect.y < self.start_y - 100:
            self.rect.y = self.start_y - 100
        if self.rect.y > self.start_y + 100:
            self.rect.y = self.start_y + 100


class Knight(Enemy):
    """Knight enemy - tough, shielded, aggressive"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'knight')
        self.shield_active = True
        self.charge_timer = 0
        self.charging = False
    
    def update_sprite(self):
        self.image = create_knight_sprite(self.facing_right, self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        if player:
            dx = player.rect.centerx - self.rect.centerx
            
            # Face player
            self.facing_right = dx > 0
            
            if abs(dx) < 250:
                # Aggressive pursuit
                self.charge_timer += 1
                
                if self.charge_timer >= 90:
                    # Charge attack
                    self.charging = True
                    self.charge_timer = 0
                
                if self.charging:
                    self.velocity_x = self.speed * 3 * (1 if self.facing_right else -1)
                    if abs(dx) < 30 or abs(dx) > 200:
                        self.charging = False
                else:
                    # Walk toward player
                    if abs(dx) > 40:
                        self.velocity_x = self.speed * (1 if dx > 0 else -1)
            else:
                # Patrol
                self.charge_timer = 0
                self.charging = False
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                    self.facing_right = False
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                    self.facing_right = True
                self.velocity_x = self.speed * self.direction
    
    def take_damage(self, amount):
        """Knights take reduced damage from front when shield is up"""
        if self.shield_active:
            # Shield blocks some damage
            amount = max(1, amount - 1)
        return super().take_damage(amount)


class Cannon(Enemy):
    """Boss enemy - the archenemy"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'cannon')
        self.phase = 1
        self.attack_pattern = 0
        self.pattern_timer = 0
        self.projectiles = pygame.sprite.Group()
        self.arena_bounds = (x - 200, x + 200)
    
    def update_sprite(self):
        self.image = create_cannon_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        if not player:
            return
        
        # Update phase based on health
        if self.health <= self.max_health * 0.3:
            self.phase = 3
        elif self.health <= self.max_health * 0.6:
            self.phase = 2
        
        dx = player.rect.centerx - self.rect.centerx
        self.facing_right = dx > 0
        
        self.pattern_timer += 1
        
        if self.phase == 1:
            self.phase1_ai(player)
        elif self.phase == 2:
            self.phase2_ai(player)
        else:
            self.phase3_ai(player)
    
    def phase1_ai(self, player):
        """Phase 1: Patrol and shoot"""
        # Move back and forth
        if self.rect.x > self.arena_bounds[1]:
            self.direction = -1
        elif self.rect.x < self.arena_bounds[0]:
            self.direction = 1
        
        self.velocity_x = self.speed * self.direction
        
        # Shoot periodically
        if self.pattern_timer >= 90:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase2_ai(self, player):
        """Phase 2: Chase and rapid fire"""
        dx = player.rect.centerx - self.rect.centerx
        
        if abs(dx) > 100:
            self.velocity_x = self.speed * 1.5 * (1 if dx > 0 else -1)
        
        # Rapid fire
        if self.pattern_timer >= 45:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase3_ai(self, player):
        """Phase 3: Enraged - fast and aggressive"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive pursuit
        self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Very rapid fire
        if self.pattern_timer >= 30:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def shoot_cannon_ball(self, player):
        """Fire a cannon ball at the player"""
        ball = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery
        )
        self.projectiles.add(ball)
    
    def update(self, player=None, tiles=None):
        super().update(player, tiles)
        self.projectiles.update()
    
    def draw(self, surface, camera_offset=(0, 0)):
        super().draw(surface, camera_offset)
        
        # Draw projectiles
        for ball in self.projectiles:
            ball.draw(surface, camera_offset)
        
        # Draw boss health bar at top of screen
        self.draw_boss_health_bar(surface)
    
    def draw_boss_health_bar(self, surface):
        """Draw large boss health bar at top"""
        bar_width = 300
        bar_height = 20
        x = SCREEN_WIDTH // 2 - bar_width // 2
        y = 20
        
        # Background
        pygame.draw.rect(surface, DARK_BROWN, (x - 2, y - 2, bar_width + 4, bar_height + 4))
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health
        health_width = int(bar_width * (self.health / self.max_health))
        pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))
        
        # Border
        pygame.draw.rect(surface, YELLOW, (x - 2, y - 2, bar_width + 4, bar_height + 4), 2)


class CannonBall(pygame.sprite.Sprite):
    """Projectile fired by Cannon boss"""
    
    def __init__(self, x, y, target_x, target_y):
        super().__init__()
        
        # Calculate direction
        dx = target_x - x
        dy = target_y - y
        dist = math.sqrt(dx * dx + dy * dy)
        
        self.speed = 5
        if dist > 0:
            self.velocity_x = (dx / dist) * self.speed
            self.velocity_y = (dy / dist) * self.speed
        else:
            self.velocity_x = self.speed
            self.velocity_y = 0
        
        self.damage = 2
        self.lifetime = 180
        
        # Create sprite
        self.image = pygame.Surface((16, 16), pygame.SRCALPHA)
        pygame.draw.circle(self.image, GRAY, (8, 8), 7)
        pygame.draw.circle(self.image, DARK_BROWN, (8, 8), 5)
        pygame.draw.circle(self.image, ORANGE, (6, 6), 2)
        
        self.rect = self.image.get_rect(center=(x, y))
    
    def update(self):
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


def create_enemy(enemy_type, x, y):
    """Factory function to create enemies"""
    if enemy_type == 'slime':
        return Slime(x, y)
    elif enemy_type == 'bat':
        return Bat(x, y)
    elif enemy_type == 'knight':
        return Knight(x, y)
    elif enemy_type == 'cannon':
        return Cannon(x, y)
    else:
        return Slime(x, y)  # Default

```

```python
"""
Item system for Chain - pickups, power-ups, and collectibles
"""

import pygame
from settings import *
from sprites import (
    create_food_sprite, create_magic_vial_sprite,
    create_heart_sprite, create_magic_sprite
)


class Item(pygame.sprite.Sprite):
    """Base item class"""
    
    def __init__(self, x, y, item_type):
        super().__init__()
        self.item_type = item_type
        self.frame = 0
        
        # Bobbing animation
        self.base_y = y
        self.bob_offset = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
    
    def update_sprite(self):
        """Override in subclasses"""
        pass
    
    def update(self):
        """Update item animation"""
        self.frame += 1
        
        # Bobbing effect
        import math
        self.bob_offset = int(math.sin(self.frame * 0.1) * 3)
        self.rect.y = self.base_y + self.bob_offset
        
        self.update_sprite()
    
    def collect(self, player):
        """Called when player collects this item - override in subclasses"""
        self.kill()
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw item"""
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


class Food(Item):
    """Food item - restores health"""
    
    def __init__(self, x, y, food_type='food'):
        self.food_type = food_type
        super().__init__(x, y, food_type)
        
        if food_type == 'feast':
            self.heal_amount = ITEM_TYPES['feast']['heal']
        else:
            self.heal_amount = ITEM_TYPES['food']['heal']
    
    def update_sprite(self):
        self.image = create_food_sprite(self.food_type)
    
    def collect(self, player):
        player.heal(self.heal_amount)
        super().collect(player)


class MagicVial(Item):
    """Magic vial - restores magic points"""
    
    def __init__(self, x, y, vial_type='magic_vial'):
        self.vial_type = vial_type
        super().__init__(x, y, vial_type)
        
        if vial_type == 'magic_potion':
            self.restore_amount = ITEM_TYPES['magic_potion']['restore']
        else:
            self.restore_amount = ITEM_TYPES['magic_vial']['restore']
    
    def update_sprite(self):
        self.image = create_magic_vial_sprite(self.vial_type)
    
    def collect(self, player):
        player.restore_magic(self.restore_amount)
        super().collect(player)


class HeartContainer(Item):
    """Heart container - increases max health"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'heart_container')
        self.increase_amount = ITEM_TYPES['heart_container']['max_health_increase']
    
    def update_sprite(self):
        self.image = create_heart_sprite(is_container=True)
    
    def collect(self, player):
        player.increase_max_health(self.increase_amount)
        super().collect(player)


class MagicBottle(Item):
    """Magic bottle - increases max magic"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'magic_bottle')
        self.increase_amount = ITEM_TYPES['magic_bottle']['max_magic_increase']
    
    def update_sprite(self):
        self.image = create_magic_sprite(is_bottle=True)
    
    def collect(self, player):
        player.increase_max_magic(self.increase_amount)
        super().collect(player)


class Coin(Item):
    """Coin - adds to score"""
    
    def __init__(self, x, y, value=10):
        self.value = value
        super().__init__(x, y, 'coin')
    
    def update_sprite(self):
        # Create coin sprite
        size = 10
        surface = pygame.Surface((size * PIXEL_SCALE, size * PIXEL_SCALE), pygame.SRCALPHA)
        
        # Animated rotation effect
        frame_mod = self.frame % 20
        if frame_mod < 5:
            width = 8
        elif frame_mod < 10:
            width = 6
        elif frame_mod < 15:
            width = 4
        else:
            width = 6
        
        x_offset = (10 - width) // 2
        
        # Draw coin
        scaled_width = width * PIXEL_SCALE
        scaled_x = x_offset * PIXEL_SCALE
        
        pygame.draw.rect(surface, YELLOW, 
                        (scaled_x, 2 * PIXEL_SCALE, scaled_width, 6 * PIXEL_SCALE))
        pygame.draw.rect(surface, ORANGE, 
                        (scaled_x, 6 * PIXEL_SCALE, scaled_width, 2 * PIXEL_SCALE))
        
        self.image = surface
    
    def collect(self, player):
        player.add_score(self.value)
        super().collect(player)


class Key(Item):
    """Key - unlocks doors/chests"""
    
    def __init__(self, x, y, key_id='default'):
        self.key_id = key_id
        super().__init__(x, y, 'key')
    
    def update_sprite(self):
        # Create key sprite
        size = 12
        surface = pygame.Surface((size * PIXEL_SCALE, size * PIXEL_SCALE), pygame.SRCALPHA)
        
        # Key shape
        pygame.draw.rect(surface, YELLOW, 
                        (2 * PIXEL_SCALE, 2 * PIXEL_SCALE, 4 * PIXEL_SCALE, 4 * PIXEL_SCALE))
        pygame.draw.rect(surface, YELLOW, 
                        (4 * PIXEL_SCALE, 5 * PIXEL_SCALE, 2 * PIXEL_SCALE, 6 * PIXEL_SCALE))
        pygame.draw.rect(surface, YELLOW, 
                        (2 * PIXEL_SCALE, 8 * PIXEL_SCALE, 2 * PIXEL_SCALE, 2 * PIXEL_SCALE))
        pygame.draw.rect(surface, ORANGE, 
                        (3 * PIXEL_SCALE, 3 * PIXEL_SCALE, 2 * PIXEL_SCALE, 2 * PIXEL_SCALE))
        
        self.image = surface
    
    def collect(self, player):
        # Add key to player inventory (would need to implement inventory)
        player.add_score(100)  # For now, just add score
        super().collect(player)


class ItemManager:
    """Manages all items in a level"""
    
    def __init__(self):
        self.items = pygame.sprite.Group()
    
    def add_item(self, item):
        """Add an item to the manager"""
        self.items.add(item)
    
    def spawn_food(self, x, y, feast=False):
        """Spawn a food item"""
        food_type = 'feast' if feast else 'food'
        self.items.add(Food(x, y, food_type))
    
    def spawn_magic_vial(self, x, y, potion=False):
        """Spawn a magic vial"""
        vial_type = 'magic_potion' if potion else 'magic_vial'
        self.items.add(MagicVial(x, y, vial_type))
    
    def spawn_heart_container(self, x, y):
        """Spawn a heart container"""
        self.items.add(HeartContainer(x, y))
    
    def spawn_magic_bottle(self, x, y):
        """Spawn a magic bottle"""
        self.items.add(MagicBottle(x, y))
    
    def spawn_coin(self, x, y, value=10):
        """Spawn a coin"""
        self.items.add(Coin(x, y, value))
    
    def spawn_key(self, x, y, key_id='default'):
        """Spawn a key"""
        self.items.add(Key(x, y, key_id))
    
    def update(self):
        """Update all items"""
        self.items.update()
    
    def check_collection(self, player):
        """Check if player collected any items"""
        for item in self.items:
            if player.rect.colliderect(item.rect):
                item.collect(player)
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw all items"""
        for item in self.items:
            item.draw(surface, camera_offset)
    
    def clear(self):
        """Clear all items"""
        self.items.empty()


def create_item(item_type, x, y):
    """Factory function to create items"""
    if item_type == 'food':
        return Food(x, y, 'food')
    elif item_type == 'feast':
        return Food(x, y, 'feast')
    elif item_type == 'magic_vial':
        return MagicVial(x, y, 'magic_vial')
    elif item_type == 'magic_potion':
        return MagicVial(x, y, 'magic_potion')
    elif item_type == 'heart_container':
        return HeartContainer(x, y)
    elif item_type == 'magic_bottle':
        return MagicBottle(x, y)
    elif item_type == 'coin':
        return Coin(x, y)
    elif item_type == 'key':
        return Key(x, y)
    else:
        return Coin(x, y)  # Default

```

```python
"""
User Interface elements for Chain
"""

import pygame
from settings import *
from sprites import create_heart_sprite, create_magic_sprite


class UI:
    """Handles all UI rendering"""
    
    def __init__(self):
        # Initialize font
        pygame.font.init()
        self.font_large = pygame.font.Font(None, 48)
        self.font_medium = pygame.font.Font(None, 32)
        self.font_small = pygame.font.Font(None, 24)
        
        # Cache sprites
        self.heart_full = create_heart_sprite(full=True)
        self.heart_empty = create_heart_sprite(full=False)
        self.magic_full = create_magic_sprite(full=True)
        self.magic_empty = create_magic_sprite(full=False)
        
        # Spell icons
        self.spell_names = ['Shield', 'Swift', 'Fireball', 'Thunder']
        self.spell_colors = [CYAN, LIME, ORANGE, YELLOW]
    
    def draw_health_bar(self, surface, current, maximum, x=20, y=20):
        """Draw health hearts"""
        for i in range(maximum):
            if i < current:
                sprite = self.heart_full
            else:
                sprite = self.heart_empty
            
            surface.blit(sprite, (x + i * (sprite.get_width() + 4), y))
    
    def draw_magic_bar(self, surface, current, maximum, x=20, y=50):
        """Draw magic crystals"""
        for i in range(maximum):
            if i < current:
                sprite = self.magic_full
            else:
                sprite = self.magic_empty
            
            surface.blit(sprite, (x + i * (sprite.get_width() + 4), y))
    
    def draw_spell_selector(self, surface, selected_spell, spell_manager, x=20, y=85):
        """Draw spell selection UI"""
        for i, (name, color) in enumerate(zip(self.spell_names, self.spell_colors)):
            # Draw slot background
            slot_x = x + i * 55
            
            # Highlight selected
            if i == selected_spell:
                pygame.draw.rect(surface, color, (slot_x - 2, y - 2, 50, 38), 2)
            
            # Draw slot
            pygame.draw.rect(surface, DARK_BLUE, (slot_x, y, 46, 34))
            pygame.draw.rect(surface, color, (slot_x + 2, y + 2, 42, 20))
            
            # Draw spell number
            num_text = self.font_small.render(str(i + 1), True, WHITE)
            surface.blit(num_text, (slot_x + 18, y + 20))
            
            # Draw spell initial
            spell_text = self.font_small.render(name[0], True, DARK_BLUE)
            surface.blit(spell_text, (slot_x + 16, y + 4))
        
        # Show active buffs
        active_buffs = spell_manager.get_active_buffs()
        buff_y = y + 42
        for buff in active_buffs:
            buff_color = CYAN if buff == 'shield' else LIME
            pygame.draw.rect(surface, buff_color, (x, buff_y, 10, 10))
            buff_text = self.font_small.render(buff.capitalize(), True, WHITE)
            surface.blit(buff_text, (x + 15, buff_y - 2))
            buff_y += 15
    
    def draw_score(self, surface, score, x=None, y=20):
        """Draw score"""
        if x is None:
            x = SCREEN_WIDTH - 150
        
        score_text = self.font_medium.render(f"Score: {score}", True, YELLOW)
        surface.blit(score_text, (x, y))
    
    def draw_level_name(self, surface, name, x=None, y=None):
        """Draw level name at top center"""
        if x is None:
            x = SCREEN_WIDTH // 2
        if y is None:
            y = 20
        
        text = self.font_medium.render(name, True, WHITE)
        text_rect = text.get_rect(center=(x, y))
        
        # Background
        pygame.draw.rect(surface, DARK_BLUE, 
                        (text_rect.x - 10, text_rect.y - 5, 
                         text_rect.width + 20, text_rect.height + 10))
        surface.blit(text, text_rect)
    
    def draw_dialog(self, surface, text, speaker=None):
        """Draw dialog box at bottom of screen"""
        box_height = 100
        box_y = SCREEN_HEIGHT - box_height - 20
        
        # Draw box
        pygame.draw.rect(surface, DARK_BLUE, (20, box_y, SCREEN_WIDTH - 40, box_height))
        pygame.draw.rect(surface, WHITE, (20, box_y, SCREEN_WIDTH - 40, box_height), 2)
        
        # Draw speaker name
        if speaker:
            name_text = self.font_medium.render(speaker, True, YELLOW)
            surface.blit(name_text, (40, box_y + 10))
            text_y = box_y + 40
        else:
            text_y = box_y + 20
        
        # Draw text (word wrap)
        words = text.split()
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + word + " "
            if self.font_medium.size(test_line)[0] < SCREEN_WIDTH - 80:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word + " "
        lines.append(current_line)
        
        for i, line in enumerate(lines):
            line_text = self.font_medium.render(line, True, WHITE)
            surface.blit(line_text, (40, text_y + i * 25))
    
    def draw_menu(self, surface, title, options, selected):
        """Draw a menu screen"""
        # Title
        title_text = self.font_large.render(title, True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 150))
        surface.blit(title_text, title_rect)
        
        # Options
        for i, option in enumerate(options):
            if i == selected:
                color = YELLOW
                prefix = "> "
            else:
                color = WHITE
                prefix = "  "
            
            option_text = self.font_medium.render(prefix + option, True, color)
            option_rect = option_text.get_rect(center=(SCREEN_WIDTH // 2, 250 + i * 50))
            surface.blit(option_text, option_rect)
    
    def draw_game_over(self, surface, score):
        """Draw game over screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Game Over text
        text = self.font_large.render("GAME OVER", True, RED)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        surface.blit(text, text_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 80))
        surface.blit(inst_text, inst_rect)
    
    def draw_victory(self, surface, score):
        """Draw victory screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Victory text
        text = self.font_large.render("VICTORY!", True, YELLOW)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 80))
        surface.blit(text, text_rect)
        
        # Story
        story = self.font_medium.render("You saved the Princess!", True, MINT)
        story_rect = story.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20))
        surface.blit(story, story_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 100))
        surface.blit(inst_text, inst_rect)
    
    def draw_pause(self, surface):
        """Draw pause overlay"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 128))
        surface.blit(overlay, (0, 0))
        
        # Pause text
        text = self.font_large.render("PAUSED", True, WHITE)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30))
        surface.blit(text, text_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ESC to resume", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30))
        surface.blit(inst_text, inst_rect)
    
    def draw_hud(self, surface, player):
        """Draw the full HUD"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_spell_selector(surface, player.spell_manager.selected_spell, 
                                player.spell_manager)
        self.draw_score(surface, player.score)
    
    def draw_world_map_hud(self, surface, player, current_location):
        """Draw HUD for world map"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_score(surface, player.score)
        
        # Location name
        if current_location:
            loc_text = self.font_medium.render(current_location, True, WHITE)
            loc_rect = loc_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 30))
            pygame.draw.rect(surface, DARK_BLUE, 
                           (loc_rect.x - 10, loc_rect.y - 5,
                            loc_rect.width + 20, loc_rect.height + 10))
            surface.blit(loc_text, loc_rect)
    
    def draw_controls_help(self, surface):
        """Draw controls help"""
        controls = [
            "Arrow Keys/WASD: Move",
            "Space: Jump",
            "Z: Attack",
            "X: Cast Spell",
            "1-4: Select Spell",
            "Enter: Interact",
            "ESC: Pause"
        ]
        
        y = SCREEN_HEIGHT - len(controls) * 20 - 20
        for control in controls:
            text = self.font_small.render(control, True, LIGHT_GRAY)
            surface.blit(text, (SCREEN_WIDTH - 180, y))
            y += 20

```

```python
"""
World Map for traversing between adventures
"""

import pygame
from settings import *
from sprites import create_world_map_tile


class WorldMapTile:
    """A tile on the world map"""
    
    def __init__(self, x, y, tile_type, walkable=True, level_id=None):
        self.tile_type = tile_type
        self.walkable = walkable
        self.level_id = level_id  # If this tile leads to a level
        
        self.image = create_world_map_tile(tile_type)
        self.rect = pygame.Rect(
            x * TILE_SIZE * PIXEL_SCALE,
            y * TILE_SIZE * PIXEL_SCALE,
            TILE_SIZE * PIXEL_SCALE,
            TILE_SIZE * PIXEL_SCALE
        )
        self.grid_x = x
        self.grid_y = y
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


class LevelMarker:
    """Marker for a level entrance on the world map"""
    
    def __init__(self, grid_x, grid_y, level_id, level_name, level_type):
        self.grid_x = grid_x
        self.grid_y = grid_y
        self.level_id = level_id
        self.level_name = level_name
        self.level_type = level_type
        self.completed = False
        self.unlocked = False
        
        self.image = create_world_map_tile('level_marker')
        self.rect = pygame.Rect(
            grid_x * TILE_SIZE * PIXEL_SCALE,
            grid_y * TILE_SIZE * PIXEL_SCALE,
            TILE_SIZE * PIXEL_SCALE,
            TILE_SIZE * PIXEL_SCALE
        )
        
        # Animation
        self.frame = 0
    
    def update(self):
        self.frame += 1
    
    def draw(self, surface, camera_offset=(0, 0)):
        if not self.unlocked:
            return
        
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Pulsing effect
        import math
        pulse = int(math.sin(self.frame * 0.1) * 3)
        
        # Draw marker
        if self.completed:
            # Completed levels show as green
            completed_img = pygame.Surface(self.image.get_size(), pygame.SRCALPHA)
            completed_img.blit(self.image, (0, 0))
            completed_img.fill((*LIME[:3], 100), special_flags=pygame.BLEND_RGBA_ADD)
            surface.blit(completed_img, (draw_x, draw_y + pulse))
        else:
            surface.blit(self.image, (draw_x, draw_y + pulse))


class WorldMap:
    """The overworld map for traversing between levels"""
    
    def __init__(self):
        self.tiles = []
        self.level_markers = []
        self.map_width = WORLD_MAP_WIDTH
        self.map_height = WORLD_MAP_HEIGHT
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Current level selection
        self.current_marker_index = 0
        
        self.generate_map()
    
    def generate_map(self):
        """Generate the world map"""
        # Define the map layout
        # Legend: G=grass, F=forest, M=mountain, W=water, P=path, C=castle, V=cave, B=boss
        map_data = [
            "MMMMMMMMMWWWWWWWWWWWMMMMMM",
            "MMMMMMMMWWWWWWWWWWWWMMMMMM",
            "MMMMFFFFFGGGGGGGFFFMMMMMM",
            "MMMFFFFFFGGGGGGGGFFMMMMMM",
            "MMFFFFFFFGGCGGGGGFFFMMMMM",
            "MFFFFFFFGGPPGGGGFFFFMMMMM",
            "FFFFFFFFGGPPGGGGFFFFFMMMM",
            "FFFFFFFGGGPPGGGGFFFFFFMMM",
            "FFFFFFGGGGPPPPGGGFFFFFMMM",
            "FFFFFGGGGGGGPPGGGFFFFFFMM",
            "FFFFGGGGGVGGPPGGGFFFFFFMM",
            "FFFGGGGGGGGPPPPPPPFFFFMMM",
            "FFFGGGGGGGPPGGGGGPPFFFMMM",
            "FFGGGGGGGGPPGGGGGGPPPFMMM",
            "FGGGGGGGGGPPGGGGGGGGBFMMM",
            "GGGGGGGGGPPPPGGGGGGGGFMMM",
            "GGGGGGGGGGGPPGGGGGGGFFMMM",
            "WWWWWWWWWWWWWWWWWWWWWWWWW",
            "WWWWWWWWWWWWWWWWWWWWWWWWW",
        ]
        
        tile_map = {
            'G': ('grass', True),
            'F': ('forest', False),
            'M': ('mountain', False),
            'W': ('water', False),
            'P': ('path', True),
            'C': ('castle', True),
            'V': ('cave', True),
            'B': ('boss', True),
        }
        
        # Create tiles
        for y, row in enumerate(map_data):
            for x, char in enumerate(row):
                if char in tile_map:
                    tile_type, walkable = tile_map[char]
                    tile = WorldMapTile(x, y, tile_type, walkable)
                    self.tiles.append(tile)
        
        # Create level markers
        self.level_markers = [
            LevelMarker(10, 4, 'castle', "Castle Entrance", LEVEL_CASTLE),
            LevelMarker(9, 10, 'cave', "Dark Cave", LEVEL_CAVE),
            LevelMarker(19, 14, 'boss', "Cannon's Fortress", LEVEL_BOSS),
        ]
        
        # Start with first level unlocked
        self.level_markers[0].unlocked = True
    
    def get_walkable_tiles(self):
        """Get list of walkable tiles for collision"""
        return [tile for tile in self.tiles if not tile.walkable]
    
    def get_current_level_marker(self, player_rect):
        """Check if player is on a level marker"""
        for marker in self.level_markers:
            if marker.unlocked and player_rect.colliderect(marker.rect):
                return marker
        return None
    
    def complete_level(self, level_id):
        """Mark a level as completed and unlock next"""
        for i, marker in enumerate(self.level_markers):
            if marker.level_id == level_id:
                marker.completed = True
                # Unlock next level
                if i + 1 < len(self.level_markers):
                    self.level_markers[i + 1].unlocked = True
                break
    
    def get_start_position(self):
        """Get the starting position for the player"""
        # Start near the first level marker
        first_marker = self.level_markers[0]
        return (
            first_marker.rect.x,
            first_marker.rect.y + TILE_SIZE * PIXEL_SCALE
        )
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center camera on player
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth camera movement
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.1
        
        # Clamp to map bounds
        max_x = self.map_width * TILE_SIZE * PIXEL_SCALE - SCREEN_WIDTH
        max_y = self.map_height * TILE_SIZE * PIXEL_SCALE - SCREEN_HEIGHT
        
        self.camera_x = max(0, min(self.camera_x, max_x))
        self.camera_y = max(0, min(self.camera_y, max_y))
    
    def update(self, player):
        """Update world map state"""
        self.update_camera(player)
        
        for marker in self.level_markers:
            marker.update()
    
    def draw(self, surface):
        """Draw the world map"""
        camera_offset = (int(self.camera_x), int(self.camera_y))
        
        # Draw tiles
        for tile in self.tiles:
            # Only draw visible tiles
            if (tile.rect.x - camera_offset[0] > -TILE_SIZE * PIXEL_SCALE and
                tile.rect.x - camera_offset[0] < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                tile.rect.y - camera_offset[1] > -TILE_SIZE * PIXEL_SCALE and
                tile.rect.y - camera_offset[1] < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                tile.draw(surface, camera_offset)
        
        # Draw level markers
        for marker in self.level_markers:
            marker.draw(surface, camera_offset)
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def get_location_name(self, player_rect):
        """Get the name of current location"""
        marker = self.get_current_level_marker(player_rect)
        if marker:
            status = " (Completed)" if marker.completed else " (Press ENTER)"
            return marker.level_name + status
        
        # Check tile type
        for tile in self.tiles:
            if player_rect.colliderect(tile.rect):
                names = {
                    'grass': 'Grasslands',
                    'forest': 'Dense Forest',
                    'mountain': 'Mountains',
                    'water': 'Ocean',
                    'path': 'The Road',
                    'castle': 'Castle',
                    'cave': 'Cave Entrance',
                    'boss': "Cannon's Domain"
                }
                return names.get(tile.tile_type, '')
        
        return ''

```

```python
"""
Side-scroller level system for Chain
"""

import pygame
import random
from settings import *
from sprites import create_tile_sprite
from enemies import create_enemy
from items import create_item, ItemManager


class Tile(pygame.sprite.Sprite):
    """A platform/ground tile"""
    
    def __init__(self, x, y, tile_type='grass', variant=0):
        super().__init__()
        self.tile_type = tile_type
        self.image = create_tile_sprite(tile_type, variant)
        self.rect = self.image.get_rect(topleft=(x, y))


class Level:
    """A side-scrolling level"""
    
    def __init__(self, level_id, level_type=LEVEL_FOREST):
        self.level_id = level_id
        self.level_type = level_type
        
        self.tiles = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()
        self.item_manager = ItemManager()
        
        # Level dimensions
        self.width = 0
        self.height = 0
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Level state
        self.completed = False
        self.exit_rect = None
        
        # Player start position
        self.start_x = 100
        self.start_y = 400
        
        # Level name
        self.name = self.get_level_name()
        
        # Generate level
        self.generate()
    
    def get_level_name(self):
        """Get display name for level"""
        names = {
            'castle': 'Castle Entrance',
            'cave': 'Dark Cave',
            'boss': "Cannon's Fortress"
        }
        return names.get(self.level_id, 'Unknown Area')
    
    def generate(self):
        """Generate level based on type"""
        if self.level_id == 'castle':
            self.generate_castle_level()
        elif self.level_id == 'cave':
            self.generate_cave_level()
        elif self.level_id == 'boss':
            self.generate_boss_level()
        else:
            self.generate_forest_level()
    
    def generate_forest_level(self):
        """Generate a forest-themed level"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        # Level size
        self.width = 3000
        self.height = 600
        
        # Ground
        ground_y = self.height - tile_size * 2
        for x in range(0, self.width, tile_size):
            self.tiles.add(Tile(x, ground_y, 'grass', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'dirt', x // tile_size))
        
        # Platforms
        platforms = [
            (200, ground_y - tile_size * 3, 3),
            (500, ground_y - tile_size * 2, 4),
            (800, ground_y - tile_size * 4, 2),
            (1000, ground_y - tile_size * 3, 5),
            (1400, ground_y - tile_size * 2, 3),
            (1700, ground_y - tile_size * 4, 4),
            (2000, ground_y - tile_size * 3, 3),
            (2300, ground_y - tile_size * 2, 5),
        ]
        
        for px, py, length in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, 'grass'))
        
        # Enemies
        self.enemies.add(create_enemy('slime', 400, ground_y - tile_size))
        self.enemies.add(create_enemy('slime', 900, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 600, ground_y - tile_size * 4))
        self.enemies.add(create_enemy('slime', 1200, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 1500, ground_y - tile_size * 3))
        self.enemies.add(create_enemy('knight', 2000, ground_y - tile_size))
        
        # Items
        self.item_manager.spawn_food(550, ground_y - tile_size * 3)
        self.item_manager.spawn_magic_vial(850, ground_y - tile_size * 5)
        self.item_manager.spawn_coin(1050, ground_y - tile_size * 4)
        self.item_manager.spawn_coin(1100, ground_y - tile_size * 4)
        self.item_manager.spawn_food(1750, ground_y - tile_size * 5, feast=True)
        self.item_manager.spawn_heart_container(2350, ground_y - tile_size * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - tile_size * 2, 
                                     tile_size, tile_size * 2)
        
        self.start_y = ground_y - tile_size
    
    def generate_castle_level(self):
        """Generate castle-themed level"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        self.width = 2500
        self.height = 600
        
        # Ground
        ground_y = self.height - tile_size * 2
        for x in range(0, self.width, tile_size):
            self.tiles.add(Tile(x, ground_y, 'brick', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'stone', x // tile_size))
        
        # Castle platforms and structure
        platforms = [
            (150, ground_y - tile_size * 2, 4, 'brick'),
            (450, ground_y - tile_size * 4, 3, 'brick'),
            (700, ground_y - tile_size * 3, 5, 'brick'),
            (1000, ground_y - tile_size * 5, 3, 'stone'),
            (1250, ground_y - tile_size * 3, 4, 'brick'),
            (1550, ground_y - tile_size * 4, 3, 'brick'),
            (1800, ground_y - tile_size * 2, 6, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, tile_type))
        
        # Enemies - more knights in castle
        self.enemies.add(create_enemy('knight', 300, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 550, ground_y - tile_size * 5))
        self.enemies.add(create_enemy('knight', 800, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 1100, ground_y - tile_size * 6))
        self.enemies.add(create_enemy('knight', 1350, ground_y - tile_size))
        self.enemies.add(create_enemy('knight', 1900, ground_y - tile_size))
        
        # Items
        self.item_manager.spawn_food(200, ground_y - tile_size * 3)
        self.item_manager.spawn_magic_vial(500, ground_y - tile_size * 5)
        self.item_manager.spawn_magic_vial(750, ground_y - tile_size * 4, potion=True)
        self.item_manager.spawn_coin(1050, ground_y - tile_size * 6)
        self.item_manager.spawn_food(1600, ground_y - tile_size * 5, feast=True)
        self.item_manager.spawn_magic_bottle(2000, ground_y - tile_size * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - tile_size * 2,
                                     tile_size, tile_size * 2)
        
        self.start_y = ground_y - tile_size
    
    def generate_cave_level(self):
        """Generate cave-themed level"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        self.width = 2800
        self.height = 700
        
        # Cave floor and ceiling
        ground_y = self.height - tile_size * 2
        ceiling_y = tile_size * 2
        
        for x in range(0, self.width, tile_size):
            # Floor
            self.tiles.add(Tile(x, ground_y, 'stone', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'stone', x // tile_size))
            # Ceiling
            self.tiles.add(Tile(x, 0, 'stone', x // tile_size))
            self.tiles.add(Tile(x, tile_size, 'stone', x // tile_size))
        
        # Cave platforms (more varied heights)
        platforms = [
            (200, ground_y - tile_size * 2, 3, 'stone'),
            (400, ground_y - tile_size * 4, 2, 'stone'),
            (550, ground_y - tile_size * 3, 4, 'stone'),
            (800, ground_y - tile_size * 5, 2, 'stone'),
            (950, ground_y - tile_size * 2, 3, 'stone'),
            (1150, ground_y - tile_size * 4, 3, 'stone'),
            (1400, ground_y - tile_size * 3, 2, 'stone'),
            (1550, ground_y - tile_size * 5, 4, 'stone'),
            (1850, ground_y - tile_size * 2, 3, 'stone'),
            (2050, ground_y - tile_size * 4, 2, 'stone'),
            (2250, ground_y - tile_size * 3, 5, 'stone'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, tile_type))
        
        # Lots of bats in cave
        self.enemies.add(create_enemy('bat', 300, ground_y - tile_size * 4))
        self.enemies.add(create_enemy('slime', 500, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 700, ground_y - tile_size * 5))
        self.enemies.add(create_enemy('bat', 900, ground_y - tile_size * 3))
        self.enemies.add(create_enemy('slime', 1100, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 1300, ground_y - tile_size * 4))
        self.enemies.add(create_enemy('knight', 1600, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 1800, ground_y - tile_size * 5))
        self.enemies.add(create_enemy('bat', 2000, ground_y - tile_size * 3))
        self.enemies.add(create_enemy('knight', 2300, ground_y - tile_size))
        
        # Items - magic vials common in cave (magical place)
        self.item_manager.spawn_magic_vial(250, ground_y - tile_size * 3)
        self.item_manager.spawn_magic_vial(600, ground_y - tile_size * 4)
        self.item_manager.spawn_food(850, ground_y - tile_size * 6)
        self.item_manager.spawn_magic_vial(1000, ground_y - tile_size * 3, potion=True)
        self.item_manager.spawn_food(1200, ground_y - tile_size * 5)
        self.item_manager.spawn_magic_vial(1450, ground_y - tile_size * 4)
        self.item_manager.spawn_magic_bottle(1650, ground_y - tile_size * 6)
        self.item_manager.spawn_food(1900, ground_y - tile_size * 3, feast=True)
        self.item_manager.spawn_heart_container(2100, ground_y - tile_size * 5)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - tile_size * 2,
                                     tile_size, tile_size * 2)
        
        self.start_y = ground_y - tile_size
    
    def generate_boss_level(self):
        """Generate boss arena"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        self.width = 1000
        self.height = 600
        
        # Arena floor
        ground_y = self.height - tile_size * 2
        for x in range(0, self.width, tile_size):
            self.tiles.add(Tile(x, ground_y, 'brick', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'stone', x // tile_size))
        
        # Arena walls
        for y in range(0, ground_y, tile_size):
            self.tiles.add(Tile(0, y, 'stone'))
            self.tiles.add(Tile(self.width - tile_size, y, 'stone'))
        
        # Some platforms for dodging
        platforms = [
            (200, ground_y - tile_size * 3, 2, 'brick'),
            (450, ground_y - tile_size * 4, 3, 'brick'),
            (750, ground_y - tile_size * 3, 2, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, tile_type))
        
        # THE BOSS - Cannon!
        self.enemies.add(create_enemy('cannon', 700, ground_y - tile_size * 2))
        
        # Items for the fight
        self.item_manager.spawn_food(100, ground_y - tile_size * 4, feast=True)
        self.item_manager.spawn_magic_vial(250, ground_y - tile_size * 4, potion=True)
        self.item_manager.spawn_food(500, ground_y - tile_size * 5)
        self.item_manager.spawn_magic_vial(800, ground_y - tile_size * 4, potion=True)
        
        # No exit - must defeat boss
        self.exit_rect = None
        
        self.start_x = 150
        self.start_y = ground_y - tile_size
    
    def get_tiles(self):
        """Get all tiles for collision"""
        return self.tiles.sprites()
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center on player horizontally
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth follow
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.05
        
        # Clamp to level bounds
        self.camera_x = max(0, min(self.camera_x, self.width - SCREEN_WIDTH))
        self.camera_y = max(0, min(self.camera_y, self.height - SCREEN_HEIGHT))
    
    def update(self, player):
        """Update level state"""
        self.update_camera(player)
        
        # Update enemies
        tiles = self.get_tiles()
        for enemy in self.enemies:
            enemy.update(player, tiles)
        
        # Update items
        self.item_manager.update()
        
        # Check if boss is defeated
        if self.level_id == 'boss' and len(self.enemies) == 0:
            self.completed = True
        
        # Check if player reached exit
        if self.exit_rect and player.rect.colliderect(self.exit_rect):
            self.completed = True
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def draw(self, surface):
        """Draw the level"""
        camera_offset = self.get_camera_offset()
        
        # Draw background
        self.draw_background(surface)
        
        # Draw tiles
        for tile in self.tiles:
            draw_x = tile.rect.x - camera_offset[0]
            draw_y = tile.rect.y - camera_offset[1]
            
            # Only draw visible tiles
            if (-TILE_SIZE * PIXEL_SCALE < draw_x < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                -TILE_SIZE * PIXEL_SCALE < draw_y < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                surface.blit(tile.image, (draw_x, draw_y))
        
        # Draw exit
        if self.exit_rect:
            exit_x = self.exit_rect.x - camera_offset[0]
            exit_y = self.exit_rect.y - camera_offset[1]
            pygame.draw.rect(surface, YELLOW, (exit_x, exit_y, 
                           self.exit_rect.width, self.exit_rect.height), 2)
            # Draw arrow
            pygame.draw.polygon(surface, YELLOW, [
                (exit_x + 16, exit_y + 10),
                (exit_x + 26, exit_y + 25),
                (exit_x + 6, exit_y + 25)
            ])
        
        # Draw items
        self.item_manager.draw(surface, camera_offset)
        
        # Draw enemies
        for enemy in self.enemies:
            enemy.draw(surface, camera_offset)
    
    def draw_background(self, surface):
        """Draw level background"""
        if self.level_type == LEVEL_CAVE:
            surface.fill(DARK_BROWN)
            # Cave atmosphere
            for i in range(20):
                x = (i * 157 - int(self.camera_x * 0.2)) % SCREEN_WIDTH
                y = (i * 89) % SCREEN_HEIGHT
                pygame.draw.circle(surface, BROWN, (x, y), 30)
        elif self.level_type == LEVEL_CASTLE:
            surface.fill(NAVY)
            # Castle interior
            for i in range(10):
                x = (i * 200 - int(self.camera_x * 0.1)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_BLUE, (x, 0, 80, SCREEN_HEIGHT))
        elif self.level_type == LEVEL_BOSS:
            surface.fill(DARK_RED)
            # Ominous atmosphere
            for i in range(5):
                x = SCREEN_WIDTH // 2 + (i - 2) * 150
                pygame.draw.rect(surface, RED, (x, 0, 20, SCREEN_HEIGHT), 1)
        else:
            # Forest background
            surface.fill(SKY_BLUE)
            # Clouds
            for i in range(8):
                x = (i * 200 - int(self.camera_x * 0.3)) % (SCREEN_WIDTH + 200)
                pygame.draw.ellipse(surface, WHITE, (x, 50 + i * 20, 100, 40))
            # Distant trees
            for i in range(15):
                x = (i * 150 - int(self.camera_x * 0.5)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_GREEN, (x, 300, 40, 200))
                pygame.draw.polygon(surface, GREEN, [
                    (x - 20, 300), (x + 20, 200), (x + 60, 300)
                ])

```

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
        elif event.key == pygame.K_RETURN:
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
        
        # Enemy contact damage
        for enemy in self.current_level.enemies:
            if self.player.rect.colliderect(enemy.rect):
                self.player.take_damage(enemy.damage)
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in enemy.projectiles:
                    if self.player.rect.colliderect(proj.rect):
                        self.player.take_damage(proj.damage)
                        proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

```python
#!/usr/bin/env python3
"""
Chain - A 16-bit Adventure Side-Scroller
========================================

Help Chain rescue the lost princess from the evil Cannon!

Run this file to start the game:
    python main.py

Controls:
    - Arrow Keys / WASD: Move
    - Space: Jump (in levels)
    - Z: Attack
    - X: Cast selected spell
    - 1-4: Select spell
    - Enter: Interact / Enter level
    - ESC: Pause / Menu
"""

from game import Game


def main():
    """Entry point for the game"""
    game = Game()
    game.run()


if __name__ == '__main__':
    main()

```

The game is now running! I've created a complete 16-bit style adventure side-scroller called **Chain**. Here's what I built:

## Game Structure

**Files created:**
- `main.py` - Entry point
- `game.py` - Main game loop and state management
- `settings.py` - All game constants and 16-bit color palette
- `player.py` - Chain character with health, magic, spells, movement
- `enemies.py` - Slimes, Bats, Knights, and the boss Cannon
- `items.py` - Food, magic vials, heart containers, magic bottles
- `spells.py` - Shield, Swift, Fireball, and Thunder spells
- `sprites.py` - Procedural 16-bit pixel art generation
- `world_map.py` - Top-down world map for traversing between levels
- `level.py` - Side-scroller levels with platforms and challenges
- `ui.py` - HUD, menus, dialogs

## Features Implemented

### Points System
- **Health (❤️)** - Starts at 4 max, depleted by enemy hits
- **Magic (✨)** - Starts at 4 max, depleted by casting spells
- **Heart Containers** - Permanently increase max health
- **Magic Bottles** - Permanently increase max magic

### Spells (press 1-4 to select, X to cast)
1. **Shield** - Reduces incoming damage by 50%
2. **Swift** - Increases movement speed and jump height
3. **Fireball** - Ranged projectile attack
4. **Thunder** - Area-of-effect damage spell

### Enemies
- **Slimes** - Easy, hop around
- **Bats** - Medium, fly erratically and swoop
- **Knights** - Hard, armored with shields and charge attacks
- **Cannon** (Boss) - Multi-phase fight with projectiles

### Collectibles
- **Food/Feast** - Restore health
- **Magic Vials/Potions** - Restore magic
- **Heart Containers** - +1 max health
- **Magic Bottles** - +1 max magic
- **Coins** - Score points

### Controls
- **Arrow Keys/WASD** - Move
- **Space** - Jump (in levels)
- **Z** - Attack
- **X** - Cast spell
- **1-4** - Select spell
- **Enter** - Interact/Enter level
- **ESC** - Pause/Menu

### Three Levels
1. **Castle Entrance** - Knights and platforms
2. **Dark Cave** - Bats and tricky jumps (requires spells)
3. **Cannon's Fortress** - Boss arena

The game should have opened in a new window. Navigate the world map to level markers, press Enter to start a level, defeat enemies, collect items, and ultimately face Cannon to save the princess!

---

**User**

There are... some problems.

First: there are gaps between every element on both the world map and the castle map. Please ensure that the elements of both are contiguous.

Second: let's make the elements of the HUD more prominent.

---

**Cursor**

I see the issues. The gaps are caused by a mismatch between tile sizes and positioning. Let me fix both problems.

```python
"""
World Map for traversing between adventures
"""

import pygame
from settings import *
from sprites import create_world_map_tile


class WorldMapTile:
    """A tile on the world map"""
    
    def __init__(self, x, y, tile_type, walkable=True, level_id=None):
        self.tile_type = tile_type
        self.walkable = walkable
        self.level_id = level_id  # If this tile leads to a level
        
        self.image = create_world_map_tile(tile_type)
        # Use actual image size for positioning (16 * PIXEL_SCALE = 32)
        tile_size = self.image.get_width()
        self.rect = pygame.Rect(
            x * tile_size,
            y * tile_size,
            tile_size,
            tile_size
        )
        self.grid_x = x
        self.grid_y = y
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


class LevelMarker:
    """Marker for a level entrance on the world map"""
    
    def __init__(self, grid_x, grid_y, level_id, level_name, level_type):
        self.grid_x = grid_x
        self.grid_y = grid_y
        self.level_id = level_id
        self.level_name = level_name
        self.level_type = level_type
        self.completed = False
        self.unlocked = False
        
        self.image = create_world_map_tile('level_marker')
        self.rect = pygame.Rect(
            grid_x * TILE_SIZE * PIXEL_SCALE,
            grid_y * TILE_SIZE * PIXEL_SCALE,
            TILE_SIZE * PIXEL_SCALE,
            TILE_SIZE * PIXEL_SCALE
        )
        
        # Animation
        self.frame = 0
    
    def update(self):
        self.frame += 1
    
    def draw(self, surface, camera_offset=(0, 0)):
        if not self.unlocked:
            return
        
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Pulsing effect
        import math
        pulse = int(math.sin(self.frame * 0.1) * 3)
        
        # Draw marker
        if self.completed:
            # Completed levels show as green
            completed_img = pygame.Surface(self.image.get_size(), pygame.SRCALPHA)
            completed_img.blit(self.image, (0, 0))
            completed_img.fill((*LIME[:3], 100), special_flags=pygame.BLEND_RGBA_ADD)
            surface.blit(completed_img, (draw_x, draw_y + pulse))
        else:
            surface.blit(self.image, (draw_x, draw_y + pulse))


class WorldMap:
    """The overworld map for traversing between levels"""
    
    def __init__(self):
        self.tiles = []
        self.level_markers = []
        self.map_width = WORLD_MAP_WIDTH
        self.map_height = WORLD_MAP_HEIGHT
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Current level selection
        self.current_marker_index = 0
        
        self.generate_map()
    
    def generate_map(self):
        """Generate the world map"""
        # Define the map layout
        # Legend: G=grass, F=forest, M=mountain, W=water, P=path, C=castle, V=cave, B=boss
        map_data = [
            "MMMMMMMMMWWWWWWWWWWWMMMMMM",
            "MMMMMMMMWWWWWWWWWWWWMMMMMM",
            "MMMMFFFFFGGGGGGGFFFMMMMMM",
            "MMMFFFFFFGGGGGGGGFFMMMMMM",
            "MMFFFFFFFGGCGGGGGFFFMMMMM",
            "MFFFFFFFGGPPGGGGFFFFMMMMM",
            "FFFFFFFFGGPPGGGGFFFFFMMMM",
            "FFFFFFFGGGPPGGGGFFFFFFMMM",
            "FFFFFFGGGGPPPPGGGFFFFFMMM",
            "FFFFFGGGGGGGPPGGGFFFFFFMM",
            "FFFFGGGGGVGGPPGGGFFFFFFMM",
            "FFFGGGGGGGGPPPPPPPFFFFMMM",
            "FFFGGGGGGGPPGGGGGPPFFFMMM",
            "FFGGGGGGGGPPGGGGGGPPPFMMM",
            "FGGGGGGGGGPPGGGGGGGGBFMMM",
            "GGGGGGGGGPPPPGGGGGGGGFMMM",
            "GGGGGGGGGGGPPGGGGGGGFFMMM",
            "WWWWWWWWWWWWWWWWWWWWWWWWW",
            "WWWWWWWWWWWWWWWWWWWWWWWWW",
        ]
        
        tile_map = {
            'G': ('grass', True),
            'F': ('forest', False),
            'M': ('mountain', False),
            'W': ('water', False),
            'P': ('path', True),
            'C': ('castle', True),
            'V': ('cave', True),
            'B': ('boss', True),
        }
        
        # Create tiles
        for y, row in enumerate(map_data):
            for x, char in enumerate(row):
                if char in tile_map:
                    tile_type, walkable = tile_map[char]
                    tile = WorldMapTile(x, y, tile_type, walkable)
                    self.tiles.append(tile)
        
        # Create level markers
        self.level_markers = [
            LevelMarker(10, 4, 'castle', "Castle Entrance", LEVEL_CASTLE),
            LevelMarker(9, 10, 'cave', "Dark Cave", LEVEL_CAVE),
            LevelMarker(19, 14, 'boss', "Cannon's Fortress", LEVEL_BOSS),
        ]
        
        # Start with first level unlocked
        self.level_markers[0].unlocked = True
    
    def get_walkable_tiles(self):
        """Get list of walkable tiles for collision"""
        return [tile for tile in self.tiles if not tile.walkable]
    
    def get_current_level_marker(self, player_rect):
        """Check if player is on a level marker"""
        for marker in self.level_markers:
            if marker.unlocked and player_rect.colliderect(marker.rect):
                return marker
        return None
    
    def complete_level(self, level_id):
        """Mark a level as completed and unlock next"""
        for i, marker in enumerate(self.level_markers):
            if marker.level_id == level_id:
                marker.completed = True
                # Unlock next level
                if i + 1 < len(self.level_markers):
                    self.level_markers[i + 1].unlocked = True
                break
    
    def get_start_position(self):
        """Get the starting position for the player"""
        # Start near the first level marker
        first_marker = self.level_markers[0]
        return (
            first_marker.rect.x,
            first_marker.rect.y + TILE_SIZE * PIXEL_SCALE
        )
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center camera on player
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth camera movement
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.1
        
        # Clamp to map bounds
        max_x = self.map_width * TILE_SIZE * PIXEL_SCALE - SCREEN_WIDTH
        max_y = self.map_height * TILE_SIZE * PIXEL_SCALE - SCREEN_HEIGHT
        
        self.camera_x = max(0, min(self.camera_x, max_x))
        self.camera_y = max(0, min(self.camera_y, max_y))
    
    def update(self, player):
        """Update world map state"""
        self.update_camera(player)
        
        for marker in self.level_markers:
            marker.update()
    
    def draw(self, surface):
        """Draw the world map"""
        camera_offset = (int(self.camera_x), int(self.camera_y))
        
        # Draw tiles
        for tile in self.tiles:
            # Only draw visible tiles
            if (tile.rect.x - camera_offset[0] > -TILE_SIZE * PIXEL_SCALE and
                tile.rect.x - camera_offset[0] < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                tile.rect.y - camera_offset[1] > -TILE_SIZE * PIXEL_SCALE and
                tile.rect.y - camera_offset[1] < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                tile.draw(surface, camera_offset)
        
        # Draw level markers
        for marker in self.level_markers:
            marker.draw(surface, camera_offset)
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def get_location_name(self, player_rect):
        """Get the name of current location"""
        marker = self.get_current_level_marker(player_rect)
        if marker:
            status = " (Completed)" if marker.completed else " (Press ENTER)"
            return marker.level_name + status
        
        # Check tile type
        for tile in self.tiles:
            if player_rect.colliderect(tile.rect):
                names = {
                    'grass': 'Grasslands',
                    'forest': 'Dense Forest',
                    'mountain': 'Mountains',
                    'water': 'Ocean',
                    'path': 'The Road',
                    'castle': 'Castle',
                    'cave': 'Cave Entrance',
                    'boss': "Cannon's Domain"
                }
                return names.get(tile.tile_type, '')
        
        return ''

```

```python
"""
World Map for traversing between adventures
"""

import pygame
from settings import *
from sprites import create_world_map_tile


class WorldMapTile:
    """A tile on the world map"""
    
    def __init__(self, x, y, tile_type, walkable=True, level_id=None):
        self.tile_type = tile_type
        self.walkable = walkable
        self.level_id = level_id  # If this tile leads to a level
        
        self.image = create_world_map_tile(tile_type)
        # Use actual image size for positioning (16 * PIXEL_SCALE = 32)
        tile_size = self.image.get_width()
        self.rect = pygame.Rect(
            x * tile_size,
            y * tile_size,
            tile_size,
            tile_size
        )
        self.grid_x = x
        self.grid_y = y
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


class LevelMarker:
    """Marker for a level entrance on the world map"""
    
    def __init__(self, grid_x, grid_y, level_id, level_name, level_type):
        self.grid_x = grid_x
        self.grid_y = grid_y
        self.level_id = level_id
        self.level_name = level_name
        self.level_type = level_type
        self.completed = False
        self.unlocked = False
        
        self.image = create_world_map_tile('level_marker')
        # Use actual image size for positioning (16 * PIXEL_SCALE = 32)
        tile_size = self.image.get_width()
        self.rect = pygame.Rect(
            grid_x * tile_size,
            grid_y * tile_size,
            tile_size,
            tile_size
        )
        
        # Animation
        self.frame = 0
    
    def update(self):
        self.frame += 1
    
    def draw(self, surface, camera_offset=(0, 0)):
        if not self.unlocked:
            return
        
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Pulsing effect
        import math
        pulse = int(math.sin(self.frame * 0.1) * 3)
        
        # Draw marker
        if self.completed:
            # Completed levels show as green
            completed_img = pygame.Surface(self.image.get_size(), pygame.SRCALPHA)
            completed_img.blit(self.image, (0, 0))
            completed_img.fill((*LIME[:3], 100), special_flags=pygame.BLEND_RGBA_ADD)
            surface.blit(completed_img, (draw_x, draw_y + pulse))
        else:
            surface.blit(self.image, (draw_x, draw_y + pulse))


class WorldMap:
    """The overworld map for traversing between levels"""
    
    def __init__(self):
        self.tiles = []
        self.level_markers = []
        self.map_width = WORLD_MAP_WIDTH
        self.map_height = WORLD_MAP_HEIGHT
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Current level selection
        self.current_marker_index = 0
        
        self.generate_map()
    
    def generate_map(self):
        """Generate the world map"""
        # Define the map layout
        # Legend: G=grass, F=forest, M=mountain, W=water, P=path, C=castle, V=cave, B=boss
        map_data = [
            "MMMMMMMMMWWWWWWWWWWWMMMMMM",
            "MMMMMMMMWWWWWWWWWWWWMMMMMM",
            "MMMMFFFFFGGGGGGGFFFMMMMMM",
            "MMMFFFFFFGGGGGGGGFFMMMMMM",
            "MMFFFFFFFGGCGGGGGFFFMMMMM",
            "MFFFFFFFGGPPGGGGFFFFMMMMM",
            "FFFFFFFFGGPPGGGGFFFFFMMMM",
            "FFFFFFFGGGPPGGGGFFFFFFMMM",
            "FFFFFFGGGGPPPPGGGFFFFFMMM",
            "FFFFFGGGGGGGPPGGGFFFFFFMM",
            "FFFFGGGGGVGGPPGGGFFFFFFMM",
            "FFFGGGGGGGGPPPPPPPFFFFMMM",
            "FFFGGGGGGGPPGGGGGPPFFFMMM",
            "FFGGGGGGGGPPGGGGGGPPPFMMM",
            "FGGGGGGGGGPPGGGGGGGGBFMMM",
            "GGGGGGGGGPPPPGGGGGGGGFMMM",
            "GGGGGGGGGGGPPGGGGGGGFFMMM",
            "WWWWWWWWWWWWWWWWWWWWWWWWW",
            "WWWWWWWWWWWWWWWWWWWWWWWWW",
        ]
        
        tile_map = {
            'G': ('grass', True),
            'F': ('forest', False),
            'M': ('mountain', False),
            'W': ('water', False),
            'P': ('path', True),
            'C': ('castle', True),
            'V': ('cave', True),
            'B': ('boss', True),
        }
        
        # Create tiles
        for y, row in enumerate(map_data):
            for x, char in enumerate(row):
                if char in tile_map:
                    tile_type, walkable = tile_map[char]
                    tile = WorldMapTile(x, y, tile_type, walkable)
                    self.tiles.append(tile)
        
        # Create level markers
        self.level_markers = [
            LevelMarker(10, 4, 'castle', "Castle Entrance", LEVEL_CASTLE),
            LevelMarker(9, 10, 'cave', "Dark Cave", LEVEL_CAVE),
            LevelMarker(19, 14, 'boss', "Cannon's Fortress", LEVEL_BOSS),
        ]
        
        # Start with first level unlocked
        self.level_markers[0].unlocked = True
    
    def get_walkable_tiles(self):
        """Get list of walkable tiles for collision"""
        return [tile for tile in self.tiles if not tile.walkable]
    
    def get_current_level_marker(self, player_rect):
        """Check if player is on a level marker"""
        for marker in self.level_markers:
            if marker.unlocked and player_rect.colliderect(marker.rect):
                return marker
        return None
    
    def complete_level(self, level_id):
        """Mark a level as completed and unlock next"""
        for i, marker in enumerate(self.level_markers):
            if marker.level_id == level_id:
                marker.completed = True
                # Unlock next level
                if i + 1 < len(self.level_markers):
                    self.level_markers[i + 1].unlocked = True
                break
    
    def get_start_position(self):
        """Get the starting position for the player"""
        # Start near the first level marker
        first_marker = self.level_markers[0]
        return (
            first_marker.rect.x,
            first_marker.rect.y + TILE_SIZE * PIXEL_SCALE
        )
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center camera on player
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth camera movement
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.1
        
        # Clamp to map bounds
        max_x = self.map_width * TILE_SIZE * PIXEL_SCALE - SCREEN_WIDTH
        max_y = self.map_height * TILE_SIZE * PIXEL_SCALE - SCREEN_HEIGHT
        
        self.camera_x = max(0, min(self.camera_x, max_x))
        self.camera_y = max(0, min(self.camera_y, max_y))
    
    def update(self, player):
        """Update world map state"""
        self.update_camera(player)
        
        for marker in self.level_markers:
            marker.update()
    
    def draw(self, surface):
        """Draw the world map"""
        camera_offset = (int(self.camera_x), int(self.camera_y))
        
        # Draw tiles
        for tile in self.tiles:
            # Only draw visible tiles
            if (tile.rect.x - camera_offset[0] > -TILE_SIZE * PIXEL_SCALE and
                tile.rect.x - camera_offset[0] < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                tile.rect.y - camera_offset[1] > -TILE_SIZE * PIXEL_SCALE and
                tile.rect.y - camera_offset[1] < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                tile.draw(surface, camera_offset)
        
        # Draw level markers
        for marker in self.level_markers:
            marker.draw(surface, camera_offset)
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def get_location_name(self, player_rect):
        """Get the name of current location"""
        marker = self.get_current_level_marker(player_rect)
        if marker:
            status = " (Completed)" if marker.completed else " (Press ENTER)"
            return marker.level_name + status
        
        # Check tile type
        for tile in self.tiles:
            if player_rect.colliderect(tile.rect):
                names = {
                    'grass': 'Grasslands',
                    'forest': 'Dense Forest',
                    'mountain': 'Mountains',
                    'water': 'Ocean',
                    'path': 'The Road',
                    'castle': 'Castle',
                    'cave': 'Cave Entrance',
                    'boss': "Cannon's Domain"
                }
                return names.get(tile.tile_type, '')
        
        return ''

```

```python
"""
World Map for traversing between adventures
"""

import pygame
from settings import *
from sprites import create_world_map_tile


class WorldMapTile:
    """A tile on the world map"""
    
    def __init__(self, x, y, tile_type, walkable=True, level_id=None):
        self.tile_type = tile_type
        self.walkable = walkable
        self.level_id = level_id  # If this tile leads to a level
        
        self.image = create_world_map_tile(tile_type)
        # Use actual image size for positioning (16 * PIXEL_SCALE = 32)
        tile_size = self.image.get_width()
        self.rect = pygame.Rect(
            x * tile_size,
            y * tile_size,
            tile_size,
            tile_size
        )
        self.grid_x = x
        self.grid_y = y
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


class LevelMarker:
    """Marker for a level entrance on the world map"""
    
    def __init__(self, grid_x, grid_y, level_id, level_name, level_type):
        self.grid_x = grid_x
        self.grid_y = grid_y
        self.level_id = level_id
        self.level_name = level_name
        self.level_type = level_type
        self.completed = False
        self.unlocked = False
        
        self.image = create_world_map_tile('level_marker')
        # Use actual image size for positioning (16 * PIXEL_SCALE = 32)
        tile_size = self.image.get_width()
        self.rect = pygame.Rect(
            grid_x * tile_size,
            grid_y * tile_size,
            tile_size,
            tile_size
        )
        
        # Animation
        self.frame = 0
    
    def update(self):
        self.frame += 1
    
    def draw(self, surface, camera_offset=(0, 0)):
        if not self.unlocked:
            return
        
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Pulsing effect
        import math
        pulse = int(math.sin(self.frame * 0.1) * 3)
        
        # Draw marker
        if self.completed:
            # Completed levels show as green
            completed_img = pygame.Surface(self.image.get_size(), pygame.SRCALPHA)
            completed_img.blit(self.image, (0, 0))
            completed_img.fill((*LIME[:3], 100), special_flags=pygame.BLEND_RGBA_ADD)
            surface.blit(completed_img, (draw_x, draw_y + pulse))
        else:
            surface.blit(self.image, (draw_x, draw_y + pulse))


class WorldMap:
    """The overworld map for traversing between levels"""
    
    def __init__(self):
        self.tiles = []
        self.level_markers = []
        self.map_width = WORLD_MAP_WIDTH
        self.map_height = WORLD_MAP_HEIGHT
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Current level selection
        self.current_marker_index = 0
        
        self.generate_map()
    
    def generate_map(self):
        """Generate the world map"""
        # Define the map layout
        # Legend: G=grass, F=forest, M=mountain, W=water, P=path, C=castle, V=cave, B=boss
        map_data = [
            "MMMMMMMMMWWWWWWWWWWWMMMMMM",
            "MMMMMMMMWWWWWWWWWWWWMMMMMM",
            "MMMMFFFFFGGGGGGGFFFMMMMMM",
            "MMMFFFFFFGGGGGGGGFFMMMMMM",
            "MMFFFFFFFGGCGGGGGFFFMMMMM",
            "MFFFFFFFGGPPGGGGFFFFMMMMM",
            "FFFFFFFFGGPPGGGGFFFFFMMMM",
            "FFFFFFFGGGPPGGGGFFFFFFMMM",
            "FFFFFFGGGGPPPPGGGFFFFFMMM",
            "FFFFFGGGGGGGPPGGGFFFFFFMM",
            "FFFFGGGGGVGGPPGGGFFFFFFMM",
            "FFFGGGGGGGGPPPPPPPFFFFMMM",
            "FFFGGGGGGGPPGGGGGPPFFFMMM",
            "FFGGGGGGGGPPGGGGGGPPPFMMM",
            "FGGGGGGGGGPPGGGGGGGGBFMMM",
            "GGGGGGGGGPPPPGGGGGGGGFMMM",
            "GGGGGGGGGGGPPGGGGGGGFFMMM",
            "WWWWWWWWWWWWWWWWWWWWWWWWW",
            "WWWWWWWWWWWWWWWWWWWWWWWWW",
        ]
        
        tile_map = {
            'G': ('grass', True),
            'F': ('forest', False),
            'M': ('mountain', False),
            'W': ('water', False),
            'P': ('path', True),
            'C': ('castle', True),
            'V': ('cave', True),
            'B': ('boss', True),
        }
        
        # Create tiles
        for y, row in enumerate(map_data):
            for x, char in enumerate(row):
                if char in tile_map:
                    tile_type, walkable = tile_map[char]
                    tile = WorldMapTile(x, y, tile_type, walkable)
                    self.tiles.append(tile)
        
        # Create level markers
        self.level_markers = [
            LevelMarker(10, 4, 'castle', "Castle Entrance", LEVEL_CASTLE),
            LevelMarker(9, 10, 'cave', "Dark Cave", LEVEL_CAVE),
            LevelMarker(19, 14, 'boss', "Cannon's Fortress", LEVEL_BOSS),
        ]
        
        # Start with first level unlocked
        self.level_markers[0].unlocked = True
    
    def get_walkable_tiles(self):
        """Get list of walkable tiles for collision"""
        return [tile for tile in self.tiles if not tile.walkable]
    
    def get_current_level_marker(self, player_rect):
        """Check if player is on a level marker"""
        for marker in self.level_markers:
            if marker.unlocked and player_rect.colliderect(marker.rect):
                return marker
        return None
    
    def complete_level(self, level_id):
        """Mark a level as completed and unlock next"""
        for i, marker in enumerate(self.level_markers):
            if marker.level_id == level_id:
                marker.completed = True
                # Unlock next level
                if i + 1 < len(self.level_markers):
                    self.level_markers[i + 1].unlocked = True
                break
    
    def get_start_position(self):
        """Get the starting position for the player"""
        # Start near the first level marker
        first_marker = self.level_markers[0]
        return (
            first_marker.rect.x,
            first_marker.rect.y + TILE_SIZE * PIXEL_SCALE
        )
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center camera on player
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth camera movement
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.1
        
        # Clamp to map bounds (tile size is 16 * PIXEL_SCALE = 32)
        actual_tile_size = 16 * PIXEL_SCALE
        max_x = self.map_width * actual_tile_size - SCREEN_WIDTH
        max_y = self.map_height * actual_tile_size - SCREEN_HEIGHT
        
        self.camera_x = max(0, min(self.camera_x, max_x))
        self.camera_y = max(0, min(self.camera_y, max_y))
    
    def update(self, player):
        """Update world map state"""
        self.update_camera(player)
        
        for marker in self.level_markers:
            marker.update()
    
    def draw(self, surface):
        """Draw the world map"""
        camera_offset = (int(self.camera_x), int(self.camera_y))
        
        # Draw tiles
        for tile in self.tiles:
            # Only draw visible tiles
            if (tile.rect.x - camera_offset[0] > -TILE_SIZE * PIXEL_SCALE and
                tile.rect.x - camera_offset[0] < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                tile.rect.y - camera_offset[1] > -TILE_SIZE * PIXEL_SCALE and
                tile.rect.y - camera_offset[1] < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                tile.draw(surface, camera_offset)
        
        # Draw level markers
        for marker in self.level_markers:
            marker.draw(surface, camera_offset)
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def get_location_name(self, player_rect):
        """Get the name of current location"""
        marker = self.get_current_level_marker(player_rect)
        if marker:
            status = " (Completed)" if marker.completed else " (Press ENTER)"
            return marker.level_name + status
        
        # Check tile type
        for tile in self.tiles:
            if player_rect.colliderect(tile.rect):
                names = {
                    'grass': 'Grasslands',
                    'forest': 'Dense Forest',
                    'mountain': 'Mountains',
                    'water': 'Ocean',
                    'path': 'The Road',
                    'castle': 'Castle',
                    'cave': 'Cave Entrance',
                    'boss': "Cannon's Domain"
                }
                return names.get(tile.tile_type, '')
        
        return ''

```

```python
"""
Side-scroller level system for Chain
"""

import pygame
import random
from settings import *
from sprites import create_tile_sprite
from enemies import create_enemy
from items import create_item, ItemManager


class Tile(pygame.sprite.Sprite):
    """A platform/ground tile"""
    
    # Actual tile size in pixels (16 base * 2 scale)
    SIZE = 16 * PIXEL_SCALE
    
    def __init__(self, x, y, tile_type='grass', variant=0):
        super().__init__()
        self.tile_type = tile_type
        self.image = create_tile_sprite(tile_type, variant)
        self.rect = self.image.get_rect(topleft=(x, y))


class Level:
    """A side-scrolling level"""
    
    def __init__(self, level_id, level_type=LEVEL_FOREST):
        self.level_id = level_id
        self.level_type = level_type
        
        self.tiles = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()
        self.item_manager = ItemManager()
        
        # Level dimensions
        self.width = 0
        self.height = 0
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Level state
        self.completed = False
        self.exit_rect = None
        
        # Player start position
        self.start_x = 100
        self.start_y = 400
        
        # Level name
        self.name = self.get_level_name()
        
        # Generate level
        self.generate()
    
    def get_level_name(self):
        """Get display name for level"""
        names = {
            'castle': 'Castle Entrance',
            'cave': 'Dark Cave',
            'boss': "Cannon's Fortress"
        }
        return names.get(self.level_id, 'Unknown Area')
    
    def generate(self):
        """Generate level based on type"""
        if self.level_id == 'castle':
            self.generate_castle_level()
        elif self.level_id == 'cave':
            self.generate_cave_level()
        elif self.level_id == 'boss':
            self.generate_boss_level()
        else:
            self.generate_forest_level()
    
    def generate_forest_level(self):
        """Generate a forest-themed level"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        # Level size
        self.width = 3000
        self.height = 600
        
        # Ground
        ground_y = self.height - tile_size * 2
        for x in range(0, self.width, tile_size):
            self.tiles.add(Tile(x, ground_y, 'grass', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'dirt', x // tile_size))
        
        # Platforms
        platforms = [
            (200, ground_y - tile_size * 3, 3),
            (500, ground_y - tile_size * 2, 4),
            (800, ground_y - tile_size * 4, 2),
            (1000, ground_y - tile_size * 3, 5),
            (1400, ground_y - tile_size * 2, 3),
            (1700, ground_y - tile_size * 4, 4),
            (2000, ground_y - tile_size * 3, 3),
            (2300, ground_y - tile_size * 2, 5),
        ]
        
        for px, py, length in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, 'grass'))
        
        # Enemies
        self.enemies.add(create_enemy('slime', 400, ground_y - tile_size))
        self.enemies.add(create_enemy('slime', 900, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 600, ground_y - tile_size * 4))
        self.enemies.add(create_enemy('slime', 1200, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 1500, ground_y - tile_size * 3))
        self.enemies.add(create_enemy('knight', 2000, ground_y - tile_size))
        
        # Items
        self.item_manager.spawn_food(550, ground_y - tile_size * 3)
        self.item_manager.spawn_magic_vial(850, ground_y - tile_size * 5)
        self.item_manager.spawn_coin(1050, ground_y - tile_size * 4)
        self.item_manager.spawn_coin(1100, ground_y - tile_size * 4)
        self.item_manager.spawn_food(1750, ground_y - tile_size * 5, feast=True)
        self.item_manager.spawn_heart_container(2350, ground_y - tile_size * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - tile_size * 2, 
                                     tile_size, tile_size * 2)
        
        self.start_y = ground_y - tile_size
    
    def generate_castle_level(self):
        """Generate castle-themed level"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        self.width = 2500
        self.height = 600
        
        # Ground
        ground_y = self.height - tile_size * 2
        for x in range(0, self.width, tile_size):
            self.tiles.add(Tile(x, ground_y, 'brick', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'stone', x // tile_size))
        
        # Castle platforms and structure
        platforms = [
            (150, ground_y - tile_size * 2, 4, 'brick'),
            (450, ground_y - tile_size * 4, 3, 'brick'),
            (700, ground_y - tile_size * 3, 5, 'brick'),
            (1000, ground_y - tile_size * 5, 3, 'stone'),
            (1250, ground_y - tile_size * 3, 4, 'brick'),
            (1550, ground_y - tile_size * 4, 3, 'brick'),
            (1800, ground_y - tile_size * 2, 6, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, tile_type))
        
        # Enemies - more knights in castle
        self.enemies.add(create_enemy('knight', 300, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 550, ground_y - tile_size * 5))
        self.enemies.add(create_enemy('knight', 800, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 1100, ground_y - tile_size * 6))
        self.enemies.add(create_enemy('knight', 1350, ground_y - tile_size))
        self.enemies.add(create_enemy('knight', 1900, ground_y - tile_size))
        
        # Items
        self.item_manager.spawn_food(200, ground_y - tile_size * 3)
        self.item_manager.spawn_magic_vial(500, ground_y - tile_size * 5)
        self.item_manager.spawn_magic_vial(750, ground_y - tile_size * 4, potion=True)
        self.item_manager.spawn_coin(1050, ground_y - tile_size * 6)
        self.item_manager.spawn_food(1600, ground_y - tile_size * 5, feast=True)
        self.item_manager.spawn_magic_bottle(2000, ground_y - tile_size * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - tile_size * 2,
                                     tile_size, tile_size * 2)
        
        self.start_y = ground_y - tile_size
    
    def generate_cave_level(self):
        """Generate cave-themed level"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        self.width = 2800
        self.height = 700
        
        # Cave floor and ceiling
        ground_y = self.height - tile_size * 2
        ceiling_y = tile_size * 2
        
        for x in range(0, self.width, tile_size):
            # Floor
            self.tiles.add(Tile(x, ground_y, 'stone', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'stone', x // tile_size))
            # Ceiling
            self.tiles.add(Tile(x, 0, 'stone', x // tile_size))
            self.tiles.add(Tile(x, tile_size, 'stone', x // tile_size))
        
        # Cave platforms (more varied heights)
        platforms = [
            (200, ground_y - tile_size * 2, 3, 'stone'),
            (400, ground_y - tile_size * 4, 2, 'stone'),
            (550, ground_y - tile_size * 3, 4, 'stone'),
            (800, ground_y - tile_size * 5, 2, 'stone'),
            (950, ground_y - tile_size * 2, 3, 'stone'),
            (1150, ground_y - tile_size * 4, 3, 'stone'),
            (1400, ground_y - tile_size * 3, 2, 'stone'),
            (1550, ground_y - tile_size * 5, 4, 'stone'),
            (1850, ground_y - tile_size * 2, 3, 'stone'),
            (2050, ground_y - tile_size * 4, 2, 'stone'),
            (2250, ground_y - tile_size * 3, 5, 'stone'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, tile_type))
        
        # Lots of bats in cave
        self.enemies.add(create_enemy('bat', 300, ground_y - tile_size * 4))
        self.enemies.add(create_enemy('slime', 500, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 700, ground_y - tile_size * 5))
        self.enemies.add(create_enemy('bat', 900, ground_y - tile_size * 3))
        self.enemies.add(create_enemy('slime', 1100, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 1300, ground_y - tile_size * 4))
        self.enemies.add(create_enemy('knight', 1600, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 1800, ground_y - tile_size * 5))
        self.enemies.add(create_enemy('bat', 2000, ground_y - tile_size * 3))
        self.enemies.add(create_enemy('knight', 2300, ground_y - tile_size))
        
        # Items - magic vials common in cave (magical place)
        self.item_manager.spawn_magic_vial(250, ground_y - tile_size * 3)
        self.item_manager.spawn_magic_vial(600, ground_y - tile_size * 4)
        self.item_manager.spawn_food(850, ground_y - tile_size * 6)
        self.item_manager.spawn_magic_vial(1000, ground_y - tile_size * 3, potion=True)
        self.item_manager.spawn_food(1200, ground_y - tile_size * 5)
        self.item_manager.spawn_magic_vial(1450, ground_y - tile_size * 4)
        self.item_manager.spawn_magic_bottle(1650, ground_y - tile_size * 6)
        self.item_manager.spawn_food(1900, ground_y - tile_size * 3, feast=True)
        self.item_manager.spawn_heart_container(2100, ground_y - tile_size * 5)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - tile_size * 2,
                                     tile_size, tile_size * 2)
        
        self.start_y = ground_y - tile_size
    
    def generate_boss_level(self):
        """Generate boss arena"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        self.width = 1000
        self.height = 600
        
        # Arena floor
        ground_y = self.height - tile_size * 2
        for x in range(0, self.width, tile_size):
            self.tiles.add(Tile(x, ground_y, 'brick', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'stone', x // tile_size))
        
        # Arena walls
        for y in range(0, ground_y, tile_size):
            self.tiles.add(Tile(0, y, 'stone'))
            self.tiles.add(Tile(self.width - tile_size, y, 'stone'))
        
        # Some platforms for dodging
        platforms = [
            (200, ground_y - tile_size * 3, 2, 'brick'),
            (450, ground_y - tile_size * 4, 3, 'brick'),
            (750, ground_y - tile_size * 3, 2, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, tile_type))
        
        # THE BOSS - Cannon!
        self.enemies.add(create_enemy('cannon', 700, ground_y - tile_size * 2))
        
        # Items for the fight
        self.item_manager.spawn_food(100, ground_y - tile_size * 4, feast=True)
        self.item_manager.spawn_magic_vial(250, ground_y - tile_size * 4, potion=True)
        self.item_manager.spawn_food(500, ground_y - tile_size * 5)
        self.item_manager.spawn_magic_vial(800, ground_y - tile_size * 4, potion=True)
        
        # No exit - must defeat boss
        self.exit_rect = None
        
        self.start_x = 150
        self.start_y = ground_y - tile_size
    
    def get_tiles(self):
        """Get all tiles for collision"""
        return self.tiles.sprites()
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center on player horizontally
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth follow
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.05
        
        # Clamp to level bounds
        self.camera_x = max(0, min(self.camera_x, self.width - SCREEN_WIDTH))
        self.camera_y = max(0, min(self.camera_y, self.height - SCREEN_HEIGHT))
    
    def update(self, player):
        """Update level state"""
        self.update_camera(player)
        
        # Update enemies
        tiles = self.get_tiles()
        for enemy in self.enemies:
            enemy.update(player, tiles)
        
        # Update items
        self.item_manager.update()
        
        # Check if boss is defeated
        if self.level_id == 'boss' and len(self.enemies) == 0:
            self.completed = True
        
        # Check if player reached exit
        if self.exit_rect and player.rect.colliderect(self.exit_rect):
            self.completed = True
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def draw(self, surface):
        """Draw the level"""
        camera_offset = self.get_camera_offset()
        
        # Draw background
        self.draw_background(surface)
        
        # Draw tiles
        for tile in self.tiles:
            draw_x = tile.rect.x - camera_offset[0]
            draw_y = tile.rect.y - camera_offset[1]
            
            # Only draw visible tiles
            if (-TILE_SIZE * PIXEL_SCALE < draw_x < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                -TILE_SIZE * PIXEL_SCALE < draw_y < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                surface.blit(tile.image, (draw_x, draw_y))
        
        # Draw exit
        if self.exit_rect:
            exit_x = self.exit_rect.x - camera_offset[0]
            exit_y = self.exit_rect.y - camera_offset[1]
            pygame.draw.rect(surface, YELLOW, (exit_x, exit_y, 
                           self.exit_rect.width, self.exit_rect.height), 2)
            # Draw arrow
            pygame.draw.polygon(surface, YELLOW, [
                (exit_x + 16, exit_y + 10),
                (exit_x + 26, exit_y + 25),
                (exit_x + 6, exit_y + 25)
            ])
        
        # Draw items
        self.item_manager.draw(surface, camera_offset)
        
        # Draw enemies
        for enemy in self.enemies:
            enemy.draw(surface, camera_offset)
    
    def draw_background(self, surface):
        """Draw level background"""
        if self.level_type == LEVEL_CAVE:
            surface.fill(DARK_BROWN)
            # Cave atmosphere
            for i in range(20):
                x = (i * 157 - int(self.camera_x * 0.2)) % SCREEN_WIDTH
                y = (i * 89) % SCREEN_HEIGHT
                pygame.draw.circle(surface, BROWN, (x, y), 30)
        elif self.level_type == LEVEL_CASTLE:
            surface.fill(NAVY)
            # Castle interior
            for i in range(10):
                x = (i * 200 - int(self.camera_x * 0.1)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_BLUE, (x, 0, 80, SCREEN_HEIGHT))
        elif self.level_type == LEVEL_BOSS:
            surface.fill(DARK_RED)
            # Ominous atmosphere
            for i in range(5):
                x = SCREEN_WIDTH // 2 + (i - 2) * 150
                pygame.draw.rect(surface, RED, (x, 0, 20, SCREEN_HEIGHT), 1)
        else:
            # Forest background
            surface.fill(SKY_BLUE)
            # Clouds
            for i in range(8):
                x = (i * 200 - int(self.camera_x * 0.3)) % (SCREEN_WIDTH + 200)
                pygame.draw.ellipse(surface, WHITE, (x, 50 + i * 20, 100, 40))
            # Distant trees
            for i in range(15):
                x = (i * 150 - int(self.camera_x * 0.5)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_GREEN, (x, 300, 40, 200))
                pygame.draw.polygon(surface, GREEN, [
                    (x - 20, 300), (x + 20, 200), (x + 60, 300)
                ])

```

```python
"""
Side-scroller level system for Chain
"""

import pygame
import random
from settings import *
from sprites import create_tile_sprite
from enemies import create_enemy
from items import create_item, ItemManager


class Tile(pygame.sprite.Sprite):
    """A platform/ground tile"""
    
    # Actual tile size in pixels (16 base * 2 scale)
    SIZE = 16 * PIXEL_SCALE
    
    def __init__(self, x, y, tile_type='grass', variant=0):
        super().__init__()
        self.tile_type = tile_type
        self.image = create_tile_sprite(tile_type, variant)
        self.rect = self.image.get_rect(topleft=(x, y))


class Level:
    """A side-scrolling level"""
    
    def __init__(self, level_id, level_type=LEVEL_FOREST):
        self.level_id = level_id
        self.level_type = level_type
        
        self.tiles = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()
        self.item_manager = ItemManager()
        
        # Level dimensions
        self.width = 0
        self.height = 0
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Level state
        self.completed = False
        self.exit_rect = None
        
        # Player start position
        self.start_x = 100
        self.start_y = 400
        
        # Level name
        self.name = self.get_level_name()
        
        # Generate level
        self.generate()
    
    def get_level_name(self):
        """Get display name for level"""
        names = {
            'castle': 'Castle Entrance',
            'cave': 'Dark Cave',
            'boss': "Cannon's Fortress"
        }
        return names.get(self.level_id, 'Unknown Area')
    
    def generate(self):
        """Generate level based on type"""
        if self.level_id == 'castle':
            self.generate_castle_level()
        elif self.level_id == 'cave':
            self.generate_cave_level()
        elif self.level_id == 'boss':
            self.generate_boss_level()
        else:
            self.generate_forest_level()
    
    def generate_forest_level(self):
        """Generate a forest-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        # Level size
        self.width = 3000
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'grass', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'dirt', x // ts))
        
        # Platforms
        platforms = [
            (200, ground_y - ts * 3, 3),
            (500, ground_y - ts * 2, 4),
            (800, ground_y - ts * 4, 2),
            (1000, ground_y - ts * 3, 5),
            (1400, ground_y - ts * 2, 3),
            (1700, ground_y - ts * 4, 4),
            (2000, ground_y - ts * 3, 3),
            (2300, ground_y - ts * 2, 5),
        ]
        
        for px, py, length in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, 'grass'))
        
        # Enemies
        self.enemies.add(create_enemy('slime', 400, ground_y - ts))
        self.enemies.add(create_enemy('slime', 900, ground_y - ts))
        self.enemies.add(create_enemy('bat', 600, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 1200, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1500, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2000, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(550, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(850, ground_y - ts * 5)
        self.item_manager.spawn_coin(1050, ground_y - ts * 4)
        self.item_manager.spawn_coin(1100, ground_y - ts * 4)
        self.item_manager.spawn_food(1750, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_heart_container(2350, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2, 
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_castle_level(self):
        """Generate castle-themed level"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        self.width = 2500
        self.height = 600
        
        # Ground
        ground_y = self.height - tile_size * 2
        for x in range(0, self.width, tile_size):
            self.tiles.add(Tile(x, ground_y, 'brick', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'stone', x // tile_size))
        
        # Castle platforms and structure
        platforms = [
            (150, ground_y - tile_size * 2, 4, 'brick'),
            (450, ground_y - tile_size * 4, 3, 'brick'),
            (700, ground_y - tile_size * 3, 5, 'brick'),
            (1000, ground_y - tile_size * 5, 3, 'stone'),
            (1250, ground_y - tile_size * 3, 4, 'brick'),
            (1550, ground_y - tile_size * 4, 3, 'brick'),
            (1800, ground_y - tile_size * 2, 6, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, tile_type))
        
        # Enemies - more knights in castle
        self.enemies.add(create_enemy('knight', 300, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 550, ground_y - tile_size * 5))
        self.enemies.add(create_enemy('knight', 800, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 1100, ground_y - tile_size * 6))
        self.enemies.add(create_enemy('knight', 1350, ground_y - tile_size))
        self.enemies.add(create_enemy('knight', 1900, ground_y - tile_size))
        
        # Items
        self.item_manager.spawn_food(200, ground_y - tile_size * 3)
        self.item_manager.spawn_magic_vial(500, ground_y - tile_size * 5)
        self.item_manager.spawn_magic_vial(750, ground_y - tile_size * 4, potion=True)
        self.item_manager.spawn_coin(1050, ground_y - tile_size * 6)
        self.item_manager.spawn_food(1600, ground_y - tile_size * 5, feast=True)
        self.item_manager.spawn_magic_bottle(2000, ground_y - tile_size * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - tile_size * 2,
                                     tile_size, tile_size * 2)
        
        self.start_y = ground_y - tile_size
    
    def generate_cave_level(self):
        """Generate cave-themed level"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        self.width = 2800
        self.height = 700
        
        # Cave floor and ceiling
        ground_y = self.height - tile_size * 2
        ceiling_y = tile_size * 2
        
        for x in range(0, self.width, tile_size):
            # Floor
            self.tiles.add(Tile(x, ground_y, 'stone', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'stone', x // tile_size))
            # Ceiling
            self.tiles.add(Tile(x, 0, 'stone', x // tile_size))
            self.tiles.add(Tile(x, tile_size, 'stone', x // tile_size))
        
        # Cave platforms (more varied heights)
        platforms = [
            (200, ground_y - tile_size * 2, 3, 'stone'),
            (400, ground_y - tile_size * 4, 2, 'stone'),
            (550, ground_y - tile_size * 3, 4, 'stone'),
            (800, ground_y - tile_size * 5, 2, 'stone'),
            (950, ground_y - tile_size * 2, 3, 'stone'),
            (1150, ground_y - tile_size * 4, 3, 'stone'),
            (1400, ground_y - tile_size * 3, 2, 'stone'),
            (1550, ground_y - tile_size * 5, 4, 'stone'),
            (1850, ground_y - tile_size * 2, 3, 'stone'),
            (2050, ground_y - tile_size * 4, 2, 'stone'),
            (2250, ground_y - tile_size * 3, 5, 'stone'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, tile_type))
        
        # Lots of bats in cave
        self.enemies.add(create_enemy('bat', 300, ground_y - tile_size * 4))
        self.enemies.add(create_enemy('slime', 500, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 700, ground_y - tile_size * 5))
        self.enemies.add(create_enemy('bat', 900, ground_y - tile_size * 3))
        self.enemies.add(create_enemy('slime', 1100, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 1300, ground_y - tile_size * 4))
        self.enemies.add(create_enemy('knight', 1600, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 1800, ground_y - tile_size * 5))
        self.enemies.add(create_enemy('bat', 2000, ground_y - tile_size * 3))
        self.enemies.add(create_enemy('knight', 2300, ground_y - tile_size))
        
        # Items - magic vials common in cave (magical place)
        self.item_manager.spawn_magic_vial(250, ground_y - tile_size * 3)
        self.item_manager.spawn_magic_vial(600, ground_y - tile_size * 4)
        self.item_manager.spawn_food(850, ground_y - tile_size * 6)
        self.item_manager.spawn_magic_vial(1000, ground_y - tile_size * 3, potion=True)
        self.item_manager.spawn_food(1200, ground_y - tile_size * 5)
        self.item_manager.spawn_magic_vial(1450, ground_y - tile_size * 4)
        self.item_manager.spawn_magic_bottle(1650, ground_y - tile_size * 6)
        self.item_manager.spawn_food(1900, ground_y - tile_size * 3, feast=True)
        self.item_manager.spawn_heart_container(2100, ground_y - tile_size * 5)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - tile_size * 2,
                                     tile_size, tile_size * 2)
        
        self.start_y = ground_y - tile_size
    
    def generate_boss_level(self):
        """Generate boss arena"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        self.width = 1000
        self.height = 600
        
        # Arena floor
        ground_y = self.height - tile_size * 2
        for x in range(0, self.width, tile_size):
            self.tiles.add(Tile(x, ground_y, 'brick', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'stone', x // tile_size))
        
        # Arena walls
        for y in range(0, ground_y, tile_size):
            self.tiles.add(Tile(0, y, 'stone'))
            self.tiles.add(Tile(self.width - tile_size, y, 'stone'))
        
        # Some platforms for dodging
        platforms = [
            (200, ground_y - tile_size * 3, 2, 'brick'),
            (450, ground_y - tile_size * 4, 3, 'brick'),
            (750, ground_y - tile_size * 3, 2, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, tile_type))
        
        # THE BOSS - Cannon!
        self.enemies.add(create_enemy('cannon', 700, ground_y - tile_size * 2))
        
        # Items for the fight
        self.item_manager.spawn_food(100, ground_y - tile_size * 4, feast=True)
        self.item_manager.spawn_magic_vial(250, ground_y - tile_size * 4, potion=True)
        self.item_manager.spawn_food(500, ground_y - tile_size * 5)
        self.item_manager.spawn_magic_vial(800, ground_y - tile_size * 4, potion=True)
        
        # No exit - must defeat boss
        self.exit_rect = None
        
        self.start_x = 150
        self.start_y = ground_y - tile_size
    
    def get_tiles(self):
        """Get all tiles for collision"""
        return self.tiles.sprites()
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center on player horizontally
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth follow
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.05
        
        # Clamp to level bounds
        self.camera_x = max(0, min(self.camera_x, self.width - SCREEN_WIDTH))
        self.camera_y = max(0, min(self.camera_y, self.height - SCREEN_HEIGHT))
    
    def update(self, player):
        """Update level state"""
        self.update_camera(player)
        
        # Update enemies
        tiles = self.get_tiles()
        for enemy in self.enemies:
            enemy.update(player, tiles)
        
        # Update items
        self.item_manager.update()
        
        # Check if boss is defeated
        if self.level_id == 'boss' and len(self.enemies) == 0:
            self.completed = True
        
        # Check if player reached exit
        if self.exit_rect and player.rect.colliderect(self.exit_rect):
            self.completed = True
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def draw(self, surface):
        """Draw the level"""
        camera_offset = self.get_camera_offset()
        
        # Draw background
        self.draw_background(surface)
        
        # Draw tiles
        for tile in self.tiles:
            draw_x = tile.rect.x - camera_offset[0]
            draw_y = tile.rect.y - camera_offset[1]
            
            # Only draw visible tiles
            if (-TILE_SIZE * PIXEL_SCALE < draw_x < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                -TILE_SIZE * PIXEL_SCALE < draw_y < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                surface.blit(tile.image, (draw_x, draw_y))
        
        # Draw exit
        if self.exit_rect:
            exit_x = self.exit_rect.x - camera_offset[0]
            exit_y = self.exit_rect.y - camera_offset[1]
            pygame.draw.rect(surface, YELLOW, (exit_x, exit_y, 
                           self.exit_rect.width, self.exit_rect.height), 2)
            # Draw arrow
            pygame.draw.polygon(surface, YELLOW, [
                (exit_x + 16, exit_y + 10),
                (exit_x + 26, exit_y + 25),
                (exit_x + 6, exit_y + 25)
            ])
        
        # Draw items
        self.item_manager.draw(surface, camera_offset)
        
        # Draw enemies
        for enemy in self.enemies:
            enemy.draw(surface, camera_offset)
    
    def draw_background(self, surface):
        """Draw level background"""
        if self.level_type == LEVEL_CAVE:
            surface.fill(DARK_BROWN)
            # Cave atmosphere
            for i in range(20):
                x = (i * 157 - int(self.camera_x * 0.2)) % SCREEN_WIDTH
                y = (i * 89) % SCREEN_HEIGHT
                pygame.draw.circle(surface, BROWN, (x, y), 30)
        elif self.level_type == LEVEL_CASTLE:
            surface.fill(NAVY)
            # Castle interior
            for i in range(10):
                x = (i * 200 - int(self.camera_x * 0.1)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_BLUE, (x, 0, 80, SCREEN_HEIGHT))
        elif self.level_type == LEVEL_BOSS:
            surface.fill(DARK_RED)
            # Ominous atmosphere
            for i in range(5):
                x = SCREEN_WIDTH // 2 + (i - 2) * 150
                pygame.draw.rect(surface, RED, (x, 0, 20, SCREEN_HEIGHT), 1)
        else:
            # Forest background
            surface.fill(SKY_BLUE)
            # Clouds
            for i in range(8):
                x = (i * 200 - int(self.camera_x * 0.3)) % (SCREEN_WIDTH + 200)
                pygame.draw.ellipse(surface, WHITE, (x, 50 + i * 20, 100, 40))
            # Distant trees
            for i in range(15):
                x = (i * 150 - int(self.camera_x * 0.5)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_GREEN, (x, 300, 40, 200))
                pygame.draw.polygon(surface, GREEN, [
                    (x - 20, 300), (x + 20, 200), (x + 60, 300)
                ])

```

```python
"""
Side-scroller level system for Chain
"""

import pygame
import random
from settings import *
from sprites import create_tile_sprite
from enemies import create_enemy
from items import create_item, ItemManager


class Tile(pygame.sprite.Sprite):
    """A platform/ground tile"""
    
    # Actual tile size in pixels (16 base * 2 scale)
    SIZE = 16 * PIXEL_SCALE
    
    def __init__(self, x, y, tile_type='grass', variant=0):
        super().__init__()
        self.tile_type = tile_type
        self.image = create_tile_sprite(tile_type, variant)
        self.rect = self.image.get_rect(topleft=(x, y))


class Level:
    """A side-scrolling level"""
    
    def __init__(self, level_id, level_type=LEVEL_FOREST):
        self.level_id = level_id
        self.level_type = level_type
        
        self.tiles = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()
        self.item_manager = ItemManager()
        
        # Level dimensions
        self.width = 0
        self.height = 0
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Level state
        self.completed = False
        self.exit_rect = None
        
        # Player start position
        self.start_x = 100
        self.start_y = 400
        
        # Level name
        self.name = self.get_level_name()
        
        # Generate level
        self.generate()
    
    def get_level_name(self):
        """Get display name for level"""
        names = {
            'castle': 'Castle Entrance',
            'cave': 'Dark Cave',
            'boss': "Cannon's Fortress"
        }
        return names.get(self.level_id, 'Unknown Area')
    
    def generate(self):
        """Generate level based on type"""
        if self.level_id == 'castle':
            self.generate_castle_level()
        elif self.level_id == 'cave':
            self.generate_cave_level()
        elif self.level_id == 'boss':
            self.generate_boss_level()
        else:
            self.generate_forest_level()
    
    def generate_forest_level(self):
        """Generate a forest-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        # Level size
        self.width = 3000
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'grass', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'dirt', x // ts))
        
        # Platforms
        platforms = [
            (200, ground_y - ts * 3, 3),
            (500, ground_y - ts * 2, 4),
            (800, ground_y - ts * 4, 2),
            (1000, ground_y - ts * 3, 5),
            (1400, ground_y - ts * 2, 3),
            (1700, ground_y - ts * 4, 4),
            (2000, ground_y - ts * 3, 3),
            (2300, ground_y - ts * 2, 5),
        ]
        
        for px, py, length in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, 'grass'))
        
        # Enemies
        self.enemies.add(create_enemy('slime', 400, ground_y - ts))
        self.enemies.add(create_enemy('slime', 900, ground_y - ts))
        self.enemies.add(create_enemy('bat', 600, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 1200, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1500, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2000, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(550, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(850, ground_y - ts * 5)
        self.item_manager.spawn_coin(1050, ground_y - ts * 4)
        self.item_manager.spawn_coin(1100, ground_y - ts * 4)
        self.item_manager.spawn_food(1750, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_heart_container(2350, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2, 
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_castle_level(self):
        """Generate castle-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 2500
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Castle platforms and structure
        platforms = [
            (150, ground_y - ts * 2, 4, 'brick'),
            (450, ground_y - ts * 4, 3, 'brick'),
            (700, ground_y - ts * 3, 5, 'brick'),
            (1000, ground_y - ts * 5, 3, 'stone'),
            (1250, ground_y - ts * 3, 4, 'brick'),
            (1550, ground_y - ts * 4, 3, 'brick'),
            (1800, ground_y - ts * 2, 6, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # Enemies - more knights in castle
        self.enemies.add(create_enemy('knight', 300, ground_y - ts))
        self.enemies.add(create_enemy('bat', 550, ground_y - ts * 5))
        self.enemies.add(create_enemy('knight', 800, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1100, ground_y - ts * 6))
        self.enemies.add(create_enemy('knight', 1350, ground_y - ts))
        self.enemies.add(create_enemy('knight', 1900, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(200, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(500, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(750, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_coin(1050, ground_y - ts * 6)
        self.item_manager.spawn_food(1600, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_magic_bottle(2000, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_cave_level(self):
        """Generate cave-themed level"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        self.width = 2800
        self.height = 700
        
        # Cave floor and ceiling
        ground_y = self.height - tile_size * 2
        ceiling_y = tile_size * 2
        
        for x in range(0, self.width, tile_size):
            # Floor
            self.tiles.add(Tile(x, ground_y, 'stone', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'stone', x // tile_size))
            # Ceiling
            self.tiles.add(Tile(x, 0, 'stone', x // tile_size))
            self.tiles.add(Tile(x, tile_size, 'stone', x // tile_size))
        
        # Cave platforms (more varied heights)
        platforms = [
            (200, ground_y - tile_size * 2, 3, 'stone'),
            (400, ground_y - tile_size * 4, 2, 'stone'),
            (550, ground_y - tile_size * 3, 4, 'stone'),
            (800, ground_y - tile_size * 5, 2, 'stone'),
            (950, ground_y - tile_size * 2, 3, 'stone'),
            (1150, ground_y - tile_size * 4, 3, 'stone'),
            (1400, ground_y - tile_size * 3, 2, 'stone'),
            (1550, ground_y - tile_size * 5, 4, 'stone'),
            (1850, ground_y - tile_size * 2, 3, 'stone'),
            (2050, ground_y - tile_size * 4, 2, 'stone'),
            (2250, ground_y - tile_size * 3, 5, 'stone'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, tile_type))
        
        # Lots of bats in cave
        self.enemies.add(create_enemy('bat', 300, ground_y - tile_size * 4))
        self.enemies.add(create_enemy('slime', 500, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 700, ground_y - tile_size * 5))
        self.enemies.add(create_enemy('bat', 900, ground_y - tile_size * 3))
        self.enemies.add(create_enemy('slime', 1100, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 1300, ground_y - tile_size * 4))
        self.enemies.add(create_enemy('knight', 1600, ground_y - tile_size))
        self.enemies.add(create_enemy('bat', 1800, ground_y - tile_size * 5))
        self.enemies.add(create_enemy('bat', 2000, ground_y - tile_size * 3))
        self.enemies.add(create_enemy('knight', 2300, ground_y - tile_size))
        
        # Items - magic vials common in cave (magical place)
        self.item_manager.spawn_magic_vial(250, ground_y - tile_size * 3)
        self.item_manager.spawn_magic_vial(600, ground_y - tile_size * 4)
        self.item_manager.spawn_food(850, ground_y - tile_size * 6)
        self.item_manager.spawn_magic_vial(1000, ground_y - tile_size * 3, potion=True)
        self.item_manager.spawn_food(1200, ground_y - tile_size * 5)
        self.item_manager.spawn_magic_vial(1450, ground_y - tile_size * 4)
        self.item_manager.spawn_magic_bottle(1650, ground_y - tile_size * 6)
        self.item_manager.spawn_food(1900, ground_y - tile_size * 3, feast=True)
        self.item_manager.spawn_heart_container(2100, ground_y - tile_size * 5)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - tile_size * 2,
                                     tile_size, tile_size * 2)
        
        self.start_y = ground_y - tile_size
    
    def generate_boss_level(self):
        """Generate boss arena"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        self.width = 1000
        self.height = 600
        
        # Arena floor
        ground_y = self.height - tile_size * 2
        for x in range(0, self.width, tile_size):
            self.tiles.add(Tile(x, ground_y, 'brick', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'stone', x // tile_size))
        
        # Arena walls
        for y in range(0, ground_y, tile_size):
            self.tiles.add(Tile(0, y, 'stone'))
            self.tiles.add(Tile(self.width - tile_size, y, 'stone'))
        
        # Some platforms for dodging
        platforms = [
            (200, ground_y - tile_size * 3, 2, 'brick'),
            (450, ground_y - tile_size * 4, 3, 'brick'),
            (750, ground_y - tile_size * 3, 2, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, tile_type))
        
        # THE BOSS - Cannon!
        self.enemies.add(create_enemy('cannon', 700, ground_y - tile_size * 2))
        
        # Items for the fight
        self.item_manager.spawn_food(100, ground_y - tile_size * 4, feast=True)
        self.item_manager.spawn_magic_vial(250, ground_y - tile_size * 4, potion=True)
        self.item_manager.spawn_food(500, ground_y - tile_size * 5)
        self.item_manager.spawn_magic_vial(800, ground_y - tile_size * 4, potion=True)
        
        # No exit - must defeat boss
        self.exit_rect = None
        
        self.start_x = 150
        self.start_y = ground_y - tile_size
    
    def get_tiles(self):
        """Get all tiles for collision"""
        return self.tiles.sprites()
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center on player horizontally
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth follow
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.05
        
        # Clamp to level bounds
        self.camera_x = max(0, min(self.camera_x, self.width - SCREEN_WIDTH))
        self.camera_y = max(0, min(self.camera_y, self.height - SCREEN_HEIGHT))
    
    def update(self, player):
        """Update level state"""
        self.update_camera(player)
        
        # Update enemies
        tiles = self.get_tiles()
        for enemy in self.enemies:
            enemy.update(player, tiles)
        
        # Update items
        self.item_manager.update()
        
        # Check if boss is defeated
        if self.level_id == 'boss' and len(self.enemies) == 0:
            self.completed = True
        
        # Check if player reached exit
        if self.exit_rect and player.rect.colliderect(self.exit_rect):
            self.completed = True
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def draw(self, surface):
        """Draw the level"""
        camera_offset = self.get_camera_offset()
        
        # Draw background
        self.draw_background(surface)
        
        # Draw tiles
        for tile in self.tiles:
            draw_x = tile.rect.x - camera_offset[0]
            draw_y = tile.rect.y - camera_offset[1]
            
            # Only draw visible tiles
            if (-TILE_SIZE * PIXEL_SCALE < draw_x < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                -TILE_SIZE * PIXEL_SCALE < draw_y < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                surface.blit(tile.image, (draw_x, draw_y))
        
        # Draw exit
        if self.exit_rect:
            exit_x = self.exit_rect.x - camera_offset[0]
            exit_y = self.exit_rect.y - camera_offset[1]
            pygame.draw.rect(surface, YELLOW, (exit_x, exit_y, 
                           self.exit_rect.width, self.exit_rect.height), 2)
            # Draw arrow
            pygame.draw.polygon(surface, YELLOW, [
                (exit_x + 16, exit_y + 10),
                (exit_x + 26, exit_y + 25),
                (exit_x + 6, exit_y + 25)
            ])
        
        # Draw items
        self.item_manager.draw(surface, camera_offset)
        
        # Draw enemies
        for enemy in self.enemies:
            enemy.draw(surface, camera_offset)
    
    def draw_background(self, surface):
        """Draw level background"""
        if self.level_type == LEVEL_CAVE:
            surface.fill(DARK_BROWN)
            # Cave atmosphere
            for i in range(20):
                x = (i * 157 - int(self.camera_x * 0.2)) % SCREEN_WIDTH
                y = (i * 89) % SCREEN_HEIGHT
                pygame.draw.circle(surface, BROWN, (x, y), 30)
        elif self.level_type == LEVEL_CASTLE:
            surface.fill(NAVY)
            # Castle interior
            for i in range(10):
                x = (i * 200 - int(self.camera_x * 0.1)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_BLUE, (x, 0, 80, SCREEN_HEIGHT))
        elif self.level_type == LEVEL_BOSS:
            surface.fill(DARK_RED)
            # Ominous atmosphere
            for i in range(5):
                x = SCREEN_WIDTH // 2 + (i - 2) * 150
                pygame.draw.rect(surface, RED, (x, 0, 20, SCREEN_HEIGHT), 1)
        else:
            # Forest background
            surface.fill(SKY_BLUE)
            # Clouds
            for i in range(8):
                x = (i * 200 - int(self.camera_x * 0.3)) % (SCREEN_WIDTH + 200)
                pygame.draw.ellipse(surface, WHITE, (x, 50 + i * 20, 100, 40))
            # Distant trees
            for i in range(15):
                x = (i * 150 - int(self.camera_x * 0.5)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_GREEN, (x, 300, 40, 200))
                pygame.draw.polygon(surface, GREEN, [
                    (x - 20, 300), (x + 20, 200), (x + 60, 300)
                ])

```

```python
"""
Side-scroller level system for Chain
"""

import pygame
import random
from settings import *
from sprites import create_tile_sprite
from enemies import create_enemy
from items import create_item, ItemManager


class Tile(pygame.sprite.Sprite):
    """A platform/ground tile"""
    
    # Actual tile size in pixels (16 base * 2 scale)
    SIZE = 16 * PIXEL_SCALE
    
    def __init__(self, x, y, tile_type='grass', variant=0):
        super().__init__()
        self.tile_type = tile_type
        self.image = create_tile_sprite(tile_type, variant)
        self.rect = self.image.get_rect(topleft=(x, y))


class Level:
    """A side-scrolling level"""
    
    def __init__(self, level_id, level_type=LEVEL_FOREST):
        self.level_id = level_id
        self.level_type = level_type
        
        self.tiles = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()
        self.item_manager = ItemManager()
        
        # Level dimensions
        self.width = 0
        self.height = 0
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Level state
        self.completed = False
        self.exit_rect = None
        
        # Player start position
        self.start_x = 100
        self.start_y = 400
        
        # Level name
        self.name = self.get_level_name()
        
        # Generate level
        self.generate()
    
    def get_level_name(self):
        """Get display name for level"""
        names = {
            'castle': 'Castle Entrance',
            'cave': 'Dark Cave',
            'boss': "Cannon's Fortress"
        }
        return names.get(self.level_id, 'Unknown Area')
    
    def generate(self):
        """Generate level based on type"""
        if self.level_id == 'castle':
            self.generate_castle_level()
        elif self.level_id == 'cave':
            self.generate_cave_level()
        elif self.level_id == 'boss':
            self.generate_boss_level()
        else:
            self.generate_forest_level()
    
    def generate_forest_level(self):
        """Generate a forest-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        # Level size
        self.width = 3000
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'grass', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'dirt', x // ts))
        
        # Platforms
        platforms = [
            (200, ground_y - ts * 3, 3),
            (500, ground_y - ts * 2, 4),
            (800, ground_y - ts * 4, 2),
            (1000, ground_y - ts * 3, 5),
            (1400, ground_y - ts * 2, 3),
            (1700, ground_y - ts * 4, 4),
            (2000, ground_y - ts * 3, 3),
            (2300, ground_y - ts * 2, 5),
        ]
        
        for px, py, length in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, 'grass'))
        
        # Enemies
        self.enemies.add(create_enemy('slime', 400, ground_y - ts))
        self.enemies.add(create_enemy('slime', 900, ground_y - ts))
        self.enemies.add(create_enemy('bat', 600, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 1200, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1500, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2000, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(550, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(850, ground_y - ts * 5)
        self.item_manager.spawn_coin(1050, ground_y - ts * 4)
        self.item_manager.spawn_coin(1100, ground_y - ts * 4)
        self.item_manager.spawn_food(1750, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_heart_container(2350, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2, 
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_castle_level(self):
        """Generate castle-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 2500
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Castle platforms and structure
        platforms = [
            (150, ground_y - ts * 2, 4, 'brick'),
            (450, ground_y - ts * 4, 3, 'brick'),
            (700, ground_y - ts * 3, 5, 'brick'),
            (1000, ground_y - ts * 5, 3, 'stone'),
            (1250, ground_y - ts * 3, 4, 'brick'),
            (1550, ground_y - ts * 4, 3, 'brick'),
            (1800, ground_y - ts * 2, 6, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # Enemies - more knights in castle
        self.enemies.add(create_enemy('knight', 300, ground_y - ts))
        self.enemies.add(create_enemy('bat', 550, ground_y - ts * 5))
        self.enemies.add(create_enemy('knight', 800, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1100, ground_y - ts * 6))
        self.enemies.add(create_enemy('knight', 1350, ground_y - ts))
        self.enemies.add(create_enemy('knight', 1900, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(200, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(500, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(750, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_coin(1050, ground_y - ts * 6)
        self.item_manager.spawn_food(1600, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_magic_bottle(2000, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_cave_level(self):
        """Generate cave-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 2800
        self.height = 700
        
        # Cave floor and ceiling
        ground_y = self.height - ts * 2
        
        for x in range(0, self.width, ts):
            # Floor
            self.tiles.add(Tile(x, ground_y, 'stone', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
            # Ceiling
            self.tiles.add(Tile(x, 0, 'stone', x // ts))
            self.tiles.add(Tile(x, ts, 'stone', x // ts))
        
        # Cave platforms (more varied heights)
        platforms = [
            (200, ground_y - ts * 2, 3, 'stone'),
            (400, ground_y - ts * 4, 2, 'stone'),
            (550, ground_y - ts * 3, 4, 'stone'),
            (800, ground_y - ts * 5, 2, 'stone'),
            (950, ground_y - ts * 2, 3, 'stone'),
            (1150, ground_y - ts * 4, 3, 'stone'),
            (1400, ground_y - ts * 3, 2, 'stone'),
            (1550, ground_y - ts * 5, 4, 'stone'),
            (1850, ground_y - ts * 2, 3, 'stone'),
            (2050, ground_y - ts * 4, 2, 'stone'),
            (2250, ground_y - ts * 3, 5, 'stone'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # Lots of bats in cave
        self.enemies.add(create_enemy('bat', 300, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 500, ground_y - ts))
        self.enemies.add(create_enemy('bat', 700, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 900, ground_y - ts * 3))
        self.enemies.add(create_enemy('slime', 1100, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1300, ground_y - ts * 4))
        self.enemies.add(create_enemy('knight', 1600, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1800, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 2000, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2300, ground_y - ts))
        
        # Items - magic vials common in cave (magical place)
        self.item_manager.spawn_magic_vial(250, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(600, ground_y - ts * 4)
        self.item_manager.spawn_food(850, ground_y - ts * 6)
        self.item_manager.spawn_magic_vial(1000, ground_y - ts * 3, potion=True)
        self.item_manager.spawn_food(1200, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(1450, ground_y - ts * 4)
        self.item_manager.spawn_magic_bottle(1650, ground_y - ts * 6)
        self.item_manager.spawn_food(1900, ground_y - ts * 3, feast=True)
        self.item_manager.spawn_heart_container(2100, ground_y - ts * 5)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_boss_level(self):
        """Generate boss arena"""
        tile_size = TILE_SIZE * PIXEL_SCALE
        
        self.width = 1000
        self.height = 600
        
        # Arena floor
        ground_y = self.height - tile_size * 2
        for x in range(0, self.width, tile_size):
            self.tiles.add(Tile(x, ground_y, 'brick', x // tile_size))
            self.tiles.add(Tile(x, ground_y + tile_size, 'stone', x // tile_size))
        
        # Arena walls
        for y in range(0, ground_y, tile_size):
            self.tiles.add(Tile(0, y, 'stone'))
            self.tiles.add(Tile(self.width - tile_size, y, 'stone'))
        
        # Some platforms for dodging
        platforms = [
            (200, ground_y - tile_size * 3, 2, 'brick'),
            (450, ground_y - tile_size * 4, 3, 'brick'),
            (750, ground_y - tile_size * 3, 2, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * tile_size, py, tile_type))
        
        # THE BOSS - Cannon!
        self.enemies.add(create_enemy('cannon', 700, ground_y - tile_size * 2))
        
        # Items for the fight
        self.item_manager.spawn_food(100, ground_y - tile_size * 4, feast=True)
        self.item_manager.spawn_magic_vial(250, ground_y - tile_size * 4, potion=True)
        self.item_manager.spawn_food(500, ground_y - tile_size * 5)
        self.item_manager.spawn_magic_vial(800, ground_y - tile_size * 4, potion=True)
        
        # No exit - must defeat boss
        self.exit_rect = None
        
        self.start_x = 150
        self.start_y = ground_y - tile_size
    
    def get_tiles(self):
        """Get all tiles for collision"""
        return self.tiles.sprites()
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center on player horizontally
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth follow
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.05
        
        # Clamp to level bounds
        self.camera_x = max(0, min(self.camera_x, self.width - SCREEN_WIDTH))
        self.camera_y = max(0, min(self.camera_y, self.height - SCREEN_HEIGHT))
    
    def update(self, player):
        """Update level state"""
        self.update_camera(player)
        
        # Update enemies
        tiles = self.get_tiles()
        for enemy in self.enemies:
            enemy.update(player, tiles)
        
        # Update items
        self.item_manager.update()
        
        # Check if boss is defeated
        if self.level_id == 'boss' and len(self.enemies) == 0:
            self.completed = True
        
        # Check if player reached exit
        if self.exit_rect and player.rect.colliderect(self.exit_rect):
            self.completed = True
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def draw(self, surface):
        """Draw the level"""
        camera_offset = self.get_camera_offset()
        
        # Draw background
        self.draw_background(surface)
        
        # Draw tiles
        for tile in self.tiles:
            draw_x = tile.rect.x - camera_offset[0]
            draw_y = tile.rect.y - camera_offset[1]
            
            # Only draw visible tiles
            if (-TILE_SIZE * PIXEL_SCALE < draw_x < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                -TILE_SIZE * PIXEL_SCALE < draw_y < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                surface.blit(tile.image, (draw_x, draw_y))
        
        # Draw exit
        if self.exit_rect:
            exit_x = self.exit_rect.x - camera_offset[0]
            exit_y = self.exit_rect.y - camera_offset[1]
            pygame.draw.rect(surface, YELLOW, (exit_x, exit_y, 
                           self.exit_rect.width, self.exit_rect.height), 2)
            # Draw arrow
            pygame.draw.polygon(surface, YELLOW, [
                (exit_x + 16, exit_y + 10),
                (exit_x + 26, exit_y + 25),
                (exit_x + 6, exit_y + 25)
            ])
        
        # Draw items
        self.item_manager.draw(surface, camera_offset)
        
        # Draw enemies
        for enemy in self.enemies:
            enemy.draw(surface, camera_offset)
    
    def draw_background(self, surface):
        """Draw level background"""
        if self.level_type == LEVEL_CAVE:
            surface.fill(DARK_BROWN)
            # Cave atmosphere
            for i in range(20):
                x = (i * 157 - int(self.camera_x * 0.2)) % SCREEN_WIDTH
                y = (i * 89) % SCREEN_HEIGHT
                pygame.draw.circle(surface, BROWN, (x, y), 30)
        elif self.level_type == LEVEL_CASTLE:
            surface.fill(NAVY)
            # Castle interior
            for i in range(10):
                x = (i * 200 - int(self.camera_x * 0.1)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_BLUE, (x, 0, 80, SCREEN_HEIGHT))
        elif self.level_type == LEVEL_BOSS:
            surface.fill(DARK_RED)
            # Ominous atmosphere
            for i in range(5):
                x = SCREEN_WIDTH // 2 + (i - 2) * 150
                pygame.draw.rect(surface, RED, (x, 0, 20, SCREEN_HEIGHT), 1)
        else:
            # Forest background
            surface.fill(SKY_BLUE)
            # Clouds
            for i in range(8):
                x = (i * 200 - int(self.camera_x * 0.3)) % (SCREEN_WIDTH + 200)
                pygame.draw.ellipse(surface, WHITE, (x, 50 + i * 20, 100, 40))
            # Distant trees
            for i in range(15):
                x = (i * 150 - int(self.camera_x * 0.5)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_GREEN, (x, 300, 40, 200))
                pygame.draw.polygon(surface, GREEN, [
                    (x - 20, 300), (x + 20, 200), (x + 60, 300)
                ])

```

```python
"""
Side-scroller level system for Chain
"""

import pygame
import random
from settings import *
from sprites import create_tile_sprite
from enemies import create_enemy
from items import create_item, ItemManager


class Tile(pygame.sprite.Sprite):
    """A platform/ground tile"""
    
    # Actual tile size in pixels (16 base * 2 scale)
    SIZE = 16 * PIXEL_SCALE
    
    def __init__(self, x, y, tile_type='grass', variant=0):
        super().__init__()
        self.tile_type = tile_type
        self.image = create_tile_sprite(tile_type, variant)
        self.rect = self.image.get_rect(topleft=(x, y))


class Level:
    """A side-scrolling level"""
    
    def __init__(self, level_id, level_type=LEVEL_FOREST):
        self.level_id = level_id
        self.level_type = level_type
        
        self.tiles = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()
        self.item_manager = ItemManager()
        
        # Level dimensions
        self.width = 0
        self.height = 0
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Level state
        self.completed = False
        self.exit_rect = None
        
        # Player start position
        self.start_x = 100
        self.start_y = 400
        
        # Level name
        self.name = self.get_level_name()
        
        # Generate level
        self.generate()
    
    def get_level_name(self):
        """Get display name for level"""
        names = {
            'castle': 'Castle Entrance',
            'cave': 'Dark Cave',
            'boss': "Cannon's Fortress"
        }
        return names.get(self.level_id, 'Unknown Area')
    
    def generate(self):
        """Generate level based on type"""
        if self.level_id == 'castle':
            self.generate_castle_level()
        elif self.level_id == 'cave':
            self.generate_cave_level()
        elif self.level_id == 'boss':
            self.generate_boss_level()
        else:
            self.generate_forest_level()
    
    def generate_forest_level(self):
        """Generate a forest-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        # Level size
        self.width = 3000
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'grass', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'dirt', x // ts))
        
        # Platforms
        platforms = [
            (200, ground_y - ts * 3, 3),
            (500, ground_y - ts * 2, 4),
            (800, ground_y - ts * 4, 2),
            (1000, ground_y - ts * 3, 5),
            (1400, ground_y - ts * 2, 3),
            (1700, ground_y - ts * 4, 4),
            (2000, ground_y - ts * 3, 3),
            (2300, ground_y - ts * 2, 5),
        ]
        
        for px, py, length in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, 'grass'))
        
        # Enemies
        self.enemies.add(create_enemy('slime', 400, ground_y - ts))
        self.enemies.add(create_enemy('slime', 900, ground_y - ts))
        self.enemies.add(create_enemy('bat', 600, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 1200, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1500, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2000, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(550, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(850, ground_y - ts * 5)
        self.item_manager.spawn_coin(1050, ground_y - ts * 4)
        self.item_manager.spawn_coin(1100, ground_y - ts * 4)
        self.item_manager.spawn_food(1750, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_heart_container(2350, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2, 
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_castle_level(self):
        """Generate castle-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 2500
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Castle platforms and structure
        platforms = [
            (150, ground_y - ts * 2, 4, 'brick'),
            (450, ground_y - ts * 4, 3, 'brick'),
            (700, ground_y - ts * 3, 5, 'brick'),
            (1000, ground_y - ts * 5, 3, 'stone'),
            (1250, ground_y - ts * 3, 4, 'brick'),
            (1550, ground_y - ts * 4, 3, 'brick'),
            (1800, ground_y - ts * 2, 6, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # Enemies - more knights in castle
        self.enemies.add(create_enemy('knight', 300, ground_y - ts))
        self.enemies.add(create_enemy('bat', 550, ground_y - ts * 5))
        self.enemies.add(create_enemy('knight', 800, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1100, ground_y - ts * 6))
        self.enemies.add(create_enemy('knight', 1350, ground_y - ts))
        self.enemies.add(create_enemy('knight', 1900, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(200, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(500, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(750, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_coin(1050, ground_y - ts * 6)
        self.item_manager.spawn_food(1600, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_magic_bottle(2000, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_cave_level(self):
        """Generate cave-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 2800
        self.height = 700
        
        # Cave floor and ceiling
        ground_y = self.height - ts * 2
        
        for x in range(0, self.width, ts):
            # Floor
            self.tiles.add(Tile(x, ground_y, 'stone', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
            # Ceiling
            self.tiles.add(Tile(x, 0, 'stone', x // ts))
            self.tiles.add(Tile(x, ts, 'stone', x // ts))
        
        # Cave platforms (more varied heights)
        platforms = [
            (200, ground_y - ts * 2, 3, 'stone'),
            (400, ground_y - ts * 4, 2, 'stone'),
            (550, ground_y - ts * 3, 4, 'stone'),
            (800, ground_y - ts * 5, 2, 'stone'),
            (950, ground_y - ts * 2, 3, 'stone'),
            (1150, ground_y - ts * 4, 3, 'stone'),
            (1400, ground_y - ts * 3, 2, 'stone'),
            (1550, ground_y - ts * 5, 4, 'stone'),
            (1850, ground_y - ts * 2, 3, 'stone'),
            (2050, ground_y - ts * 4, 2, 'stone'),
            (2250, ground_y - ts * 3, 5, 'stone'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # Lots of bats in cave
        self.enemies.add(create_enemy('bat', 300, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 500, ground_y - ts))
        self.enemies.add(create_enemy('bat', 700, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 900, ground_y - ts * 3))
        self.enemies.add(create_enemy('slime', 1100, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1300, ground_y - ts * 4))
        self.enemies.add(create_enemy('knight', 1600, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1800, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 2000, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2300, ground_y - ts))
        
        # Items - magic vials common in cave (magical place)
        self.item_manager.spawn_magic_vial(250, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(600, ground_y - ts * 4)
        self.item_manager.spawn_food(850, ground_y - ts * 6)
        self.item_manager.spawn_magic_vial(1000, ground_y - ts * 3, potion=True)
        self.item_manager.spawn_food(1200, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(1450, ground_y - ts * 4)
        self.item_manager.spawn_magic_bottle(1650, ground_y - ts * 6)
        self.item_manager.spawn_food(1900, ground_y - ts * 3, feast=True)
        self.item_manager.spawn_heart_container(2100, ground_y - ts * 5)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_boss_level(self):
        """Generate boss arena"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 1000
        self.height = 600
        
        # Arena floor
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Arena walls
        for y in range(0, ground_y, ts):
            self.tiles.add(Tile(0, y, 'stone'))
            self.tiles.add(Tile(self.width - ts, y, 'stone'))
        
        # Some platforms for dodging
        platforms = [
            (200, ground_y - ts * 3, 2, 'brick'),
            (450, ground_y - ts * 4, 3, 'brick'),
            (750, ground_y - ts * 3, 2, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # THE BOSS - Cannon!
        self.enemies.add(create_enemy('cannon', 700, ground_y - ts * 2))
        
        # Items for the fight
        self.item_manager.spawn_food(100, ground_y - ts * 4, feast=True)
        self.item_manager.spawn_magic_vial(250, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_food(500, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(800, ground_y - ts * 4, potion=True)
        
        # No exit - must defeat boss
        self.exit_rect = None
        
        self.start_x = 150
        self.start_y = ground_y - ts
    
    def get_tiles(self):
        """Get all tiles for collision"""
        return self.tiles.sprites()
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center on player horizontally
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth follow
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.05
        
        # Clamp to level bounds
        self.camera_x = max(0, min(self.camera_x, self.width - SCREEN_WIDTH))
        self.camera_y = max(0, min(self.camera_y, self.height - SCREEN_HEIGHT))
    
    def update(self, player):
        """Update level state"""
        self.update_camera(player)
        
        # Update enemies
        tiles = self.get_tiles()
        for enemy in self.enemies:
            enemy.update(player, tiles)
        
        # Update items
        self.item_manager.update()
        
        # Check if boss is defeated
        if self.level_id == 'boss' and len(self.enemies) == 0:
            self.completed = True
        
        # Check if player reached exit
        if self.exit_rect and player.rect.colliderect(self.exit_rect):
            self.completed = True
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def draw(self, surface):
        """Draw the level"""
        camera_offset = self.get_camera_offset()
        
        # Draw background
        self.draw_background(surface)
        
        # Draw tiles
        for tile in self.tiles:
            draw_x = tile.rect.x - camera_offset[0]
            draw_y = tile.rect.y - camera_offset[1]
            
            # Only draw visible tiles
            if (-TILE_SIZE * PIXEL_SCALE < draw_x < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                -TILE_SIZE * PIXEL_SCALE < draw_y < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                surface.blit(tile.image, (draw_x, draw_y))
        
        # Draw exit
        if self.exit_rect:
            exit_x = self.exit_rect.x - camera_offset[0]
            exit_y = self.exit_rect.y - camera_offset[1]
            pygame.draw.rect(surface, YELLOW, (exit_x, exit_y, 
                           self.exit_rect.width, self.exit_rect.height), 2)
            # Draw arrow
            pygame.draw.polygon(surface, YELLOW, [
                (exit_x + 16, exit_y + 10),
                (exit_x + 26, exit_y + 25),
                (exit_x + 6, exit_y + 25)
            ])
        
        # Draw items
        self.item_manager.draw(surface, camera_offset)
        
        # Draw enemies
        for enemy in self.enemies:
            enemy.draw(surface, camera_offset)
    
    def draw_background(self, surface):
        """Draw level background"""
        if self.level_type == LEVEL_CAVE:
            surface.fill(DARK_BROWN)
            # Cave atmosphere
            for i in range(20):
                x = (i * 157 - int(self.camera_x * 0.2)) % SCREEN_WIDTH
                y = (i * 89) % SCREEN_HEIGHT
                pygame.draw.circle(surface, BROWN, (x, y), 30)
        elif self.level_type == LEVEL_CASTLE:
            surface.fill(NAVY)
            # Castle interior
            for i in range(10):
                x = (i * 200 - int(self.camera_x * 0.1)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_BLUE, (x, 0, 80, SCREEN_HEIGHT))
        elif self.level_type == LEVEL_BOSS:
            surface.fill(DARK_RED)
            # Ominous atmosphere
            for i in range(5):
                x = SCREEN_WIDTH // 2 + (i - 2) * 150
                pygame.draw.rect(surface, RED, (x, 0, 20, SCREEN_HEIGHT), 1)
        else:
            # Forest background
            surface.fill(SKY_BLUE)
            # Clouds
            for i in range(8):
                x = (i * 200 - int(self.camera_x * 0.3)) % (SCREEN_WIDTH + 200)
                pygame.draw.ellipse(surface, WHITE, (x, 50 + i * 20, 100, 40))
            # Distant trees
            for i in range(15):
                x = (i * 150 - int(self.camera_x * 0.5)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_GREEN, (x, 300, 40, 200))
                pygame.draw.polygon(surface, GREEN, [
                    (x - 20, 300), (x + 20, 200), (x + 60, 300)
                ])

```

Now let me make the HUD more prominent:

```python
"""
User Interface elements for Chain
"""

import pygame
from settings import *
from sprites import create_heart_sprite, create_magic_sprite


class UI:
    """Handles all UI rendering"""
    
    def __init__(self):
        # Initialize font
        pygame.font.init()
        self.font_large = pygame.font.Font(None, 56)
        self.font_medium = pygame.font.Font(None, 36)
        self.font_small = pygame.font.Font(None, 28)
        self.font_tiny = pygame.font.Font(None, 22)
        
        # Cache sprites and scale them up for prominence
        heart_full = create_heart_sprite(full=True)
        heart_empty = create_heart_sprite(full=False)
        magic_full = create_magic_sprite(full=True)
        magic_empty = create_magic_sprite(full=False)
        
        # Scale up HUD sprites by 1.5x for better visibility
        scale = 1.5
        self.heart_full = pygame.transform.scale(heart_full, 
            (int(heart_full.get_width() * scale), int(heart_full.get_height() * scale)))
        self.heart_empty = pygame.transform.scale(heart_empty, 
            (int(heart_empty.get_width() * scale), int(heart_empty.get_height() * scale)))
        self.magic_full = pygame.transform.scale(magic_full, 
            (int(magic_full.get_width() * scale), int(magic_full.get_height() * scale)))
        self.magic_empty = pygame.transform.scale(magic_empty, 
            (int(magic_empty.get_width() * scale), int(magic_empty.get_height() * scale)))
        
        # Spell icons
        self.spell_names = ['Shield', 'Swift', 'Fireball', 'Thunder']
        self.spell_colors = [CYAN, LIME, ORANGE, YELLOW]
    
    def draw_health_bar(self, surface, current, maximum, x=20, y=20):
        """Draw health hearts"""
        for i in range(maximum):
            if i < current:
                sprite = self.heart_full
            else:
                sprite = self.heart_empty
            
            surface.blit(sprite, (x + i * (sprite.get_width() + 4), y))
    
    def draw_magic_bar(self, surface, current, maximum, x=20, y=50):
        """Draw magic crystals"""
        for i in range(maximum):
            if i < current:
                sprite = self.magic_full
            else:
                sprite = self.magic_empty
            
            surface.blit(sprite, (x + i * (sprite.get_width() + 4), y))
    
    def draw_spell_selector(self, surface, selected_spell, spell_manager, x=20, y=85):
        """Draw spell selection UI"""
        for i, (name, color) in enumerate(zip(self.spell_names, self.spell_colors)):
            # Draw slot background
            slot_x = x + i * 55
            
            # Highlight selected
            if i == selected_spell:
                pygame.draw.rect(surface, color, (slot_x - 2, y - 2, 50, 38), 2)
            
            # Draw slot
            pygame.draw.rect(surface, DARK_BLUE, (slot_x, y, 46, 34))
            pygame.draw.rect(surface, color, (slot_x + 2, y + 2, 42, 20))
            
            # Draw spell number
            num_text = self.font_small.render(str(i + 1), True, WHITE)
            surface.blit(num_text, (slot_x + 18, y + 20))
            
            # Draw spell initial
            spell_text = self.font_small.render(name[0], True, DARK_BLUE)
            surface.blit(spell_text, (slot_x + 16, y + 4))
        
        # Show active buffs
        active_buffs = spell_manager.get_active_buffs()
        buff_y = y + 42
        for buff in active_buffs:
            buff_color = CYAN if buff == 'shield' else LIME
            pygame.draw.rect(surface, buff_color, (x, buff_y, 10, 10))
            buff_text = self.font_small.render(buff.capitalize(), True, WHITE)
            surface.blit(buff_text, (x + 15, buff_y - 2))
            buff_y += 15
    
    def draw_score(self, surface, score, x=None, y=20):
        """Draw score"""
        if x is None:
            x = SCREEN_WIDTH - 150
        
        score_text = self.font_medium.render(f"Score: {score}", True, YELLOW)
        surface.blit(score_text, (x, y))
    
    def draw_level_name(self, surface, name, x=None, y=None):
        """Draw level name at top center"""
        if x is None:
            x = SCREEN_WIDTH // 2
        if y is None:
            y = 20
        
        text = self.font_medium.render(name, True, WHITE)
        text_rect = text.get_rect(center=(x, y))
        
        # Background
        pygame.draw.rect(surface, DARK_BLUE, 
                        (text_rect.x - 10, text_rect.y - 5, 
                         text_rect.width + 20, text_rect.height + 10))
        surface.blit(text, text_rect)
    
    def draw_dialog(self, surface, text, speaker=None):
        """Draw dialog box at bottom of screen"""
        box_height = 100
        box_y = SCREEN_HEIGHT - box_height - 20
        
        # Draw box
        pygame.draw.rect(surface, DARK_BLUE, (20, box_y, SCREEN_WIDTH - 40, box_height))
        pygame.draw.rect(surface, WHITE, (20, box_y, SCREEN_WIDTH - 40, box_height), 2)
        
        # Draw speaker name
        if speaker:
            name_text = self.font_medium.render(speaker, True, YELLOW)
            surface.blit(name_text, (40, box_y + 10))
            text_y = box_y + 40
        else:
            text_y = box_y + 20
        
        # Draw text (word wrap)
        words = text.split()
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + word + " "
            if self.font_medium.size(test_line)[0] < SCREEN_WIDTH - 80:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word + " "
        lines.append(current_line)
        
        for i, line in enumerate(lines):
            line_text = self.font_medium.render(line, True, WHITE)
            surface.blit(line_text, (40, text_y + i * 25))
    
    def draw_menu(self, surface, title, options, selected):
        """Draw a menu screen"""
        # Title
        title_text = self.font_large.render(title, True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 150))
        surface.blit(title_text, title_rect)
        
        # Options
        for i, option in enumerate(options):
            if i == selected:
                color = YELLOW
                prefix = "> "
            else:
                color = WHITE
                prefix = "  "
            
            option_text = self.font_medium.render(prefix + option, True, color)
            option_rect = option_text.get_rect(center=(SCREEN_WIDTH // 2, 250 + i * 50))
            surface.blit(option_text, option_rect)
    
    def draw_game_over(self, surface, score):
        """Draw game over screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Game Over text
        text = self.font_large.render("GAME OVER", True, RED)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        surface.blit(text, text_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 80))
        surface.blit(inst_text, inst_rect)
    
    def draw_victory(self, surface, score):
        """Draw victory screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Victory text
        text = self.font_large.render("VICTORY!", True, YELLOW)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 80))
        surface.blit(text, text_rect)
        
        # Story
        story = self.font_medium.render("You saved the Princess!", True, MINT)
        story_rect = story.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20))
        surface.blit(story, story_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 100))
        surface.blit(inst_text, inst_rect)
    
    def draw_pause(self, surface):
        """Draw pause overlay"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 128))
        surface.blit(overlay, (0, 0))
        
        # Pause text
        text = self.font_large.render("PAUSED", True, WHITE)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30))
        surface.blit(text, text_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ESC to resume", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30))
        surface.blit(inst_text, inst_rect)
    
    def draw_hud(self, surface, player):
        """Draw the full HUD"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_spell_selector(surface, player.spell_manager.selected_spell, 
                                player.spell_manager)
        self.draw_score(surface, player.score)
    
    def draw_world_map_hud(self, surface, player, current_location):
        """Draw HUD for world map"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_score(surface, player.score)
        
        # Location name
        if current_location:
            loc_text = self.font_medium.render(current_location, True, WHITE)
            loc_rect = loc_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 30))
            pygame.draw.rect(surface, DARK_BLUE, 
                           (loc_rect.x - 10, loc_rect.y - 5,
                            loc_rect.width + 20, loc_rect.height + 10))
            surface.blit(loc_text, loc_rect)
    
    def draw_controls_help(self, surface):
        """Draw controls help"""
        controls = [
            "Arrow Keys/WASD: Move",
            "Space: Jump",
            "Z: Attack",
            "X: Cast Spell",
            "1-4: Select Spell",
            "Enter: Interact",
            "ESC: Pause"
        ]
        
        y = SCREEN_HEIGHT - len(controls) * 20 - 20
        for control in controls:
            text = self.font_small.render(control, True, LIGHT_GRAY)
            surface.blit(text, (SCREEN_WIDTH - 180, y))
            y += 20

```

```python
"""
User Interface elements for Chain
"""

import pygame
from settings import *
from sprites import create_heart_sprite, create_magic_sprite


class UI:
    """Handles all UI rendering"""
    
    def __init__(self):
        # Initialize font
        pygame.font.init()
        self.font_large = pygame.font.Font(None, 56)
        self.font_medium = pygame.font.Font(None, 36)
        self.font_small = pygame.font.Font(None, 28)
        self.font_tiny = pygame.font.Font(None, 22)
        
        # Cache sprites and scale them up for prominence
        heart_full = create_heart_sprite(full=True)
        heart_empty = create_heart_sprite(full=False)
        magic_full = create_magic_sprite(full=True)
        magic_empty = create_magic_sprite(full=False)
        
        # Scale up HUD sprites by 1.5x for better visibility
        scale = 1.5
        self.heart_full = pygame.transform.scale(heart_full, 
            (int(heart_full.get_width() * scale), int(heart_full.get_height() * scale)))
        self.heart_empty = pygame.transform.scale(heart_empty, 
            (int(heart_empty.get_width() * scale), int(heart_empty.get_height() * scale)))
        self.magic_full = pygame.transform.scale(magic_full, 
            (int(magic_full.get_width() * scale), int(magic_full.get_height() * scale)))
        self.magic_empty = pygame.transform.scale(magic_empty, 
            (int(magic_empty.get_width() * scale), int(magic_empty.get_height() * scale)))
        
        # Spell icons
        self.spell_names = ['Shield', 'Swift', 'Fireball', 'Thunder']
        self.spell_colors = [CYAN, LIME, ORANGE, YELLOW]
    
    def draw_health_bar(self, surface, current, maximum, x=16, y=16):
        """Draw health hearts with background panel"""
        # Calculate panel size
        heart_w = self.heart_full.get_width()
        heart_h = self.heart_full.get_height()
        panel_width = maximum * (heart_w + 6) + 20
        panel_height = heart_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, RED, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("HP", True, RED)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw hearts
        for i in range(maximum):
            if i < current:
                sprite = self.heart_full
            else:
                sprite = self.heart_empty
            
            surface.blit(sprite, (x + 24 + i * (heart_w + 6), y))
    
    def draw_magic_bar(self, surface, current, maximum, x=20, y=50):
        """Draw magic crystals"""
        for i in range(maximum):
            if i < current:
                sprite = self.magic_full
            else:
                sprite = self.magic_empty
            
            surface.blit(sprite, (x + i * (sprite.get_width() + 4), y))
    
    def draw_spell_selector(self, surface, selected_spell, spell_manager, x=20, y=85):
        """Draw spell selection UI"""
        for i, (name, color) in enumerate(zip(self.spell_names, self.spell_colors)):
            # Draw slot background
            slot_x = x + i * 55
            
            # Highlight selected
            if i == selected_spell:
                pygame.draw.rect(surface, color, (slot_x - 2, y - 2, 50, 38), 2)
            
            # Draw slot
            pygame.draw.rect(surface, DARK_BLUE, (slot_x, y, 46, 34))
            pygame.draw.rect(surface, color, (slot_x + 2, y + 2, 42, 20))
            
            # Draw spell number
            num_text = self.font_small.render(str(i + 1), True, WHITE)
            surface.blit(num_text, (slot_x + 18, y + 20))
            
            # Draw spell initial
            spell_text = self.font_small.render(name[0], True, DARK_BLUE)
            surface.blit(spell_text, (slot_x + 16, y + 4))
        
        # Show active buffs
        active_buffs = spell_manager.get_active_buffs()
        buff_y = y + 42
        for buff in active_buffs:
            buff_color = CYAN if buff == 'shield' else LIME
            pygame.draw.rect(surface, buff_color, (x, buff_y, 10, 10))
            buff_text = self.font_small.render(buff.capitalize(), True, WHITE)
            surface.blit(buff_text, (x + 15, buff_y - 2))
            buff_y += 15
    
    def draw_score(self, surface, score, x=None, y=20):
        """Draw score"""
        if x is None:
            x = SCREEN_WIDTH - 150
        
        score_text = self.font_medium.render(f"Score: {score}", True, YELLOW)
        surface.blit(score_text, (x, y))
    
    def draw_level_name(self, surface, name, x=None, y=None):
        """Draw level name at top center"""
        if x is None:
            x = SCREEN_WIDTH // 2
        if y is None:
            y = 20
        
        text = self.font_medium.render(name, True, WHITE)
        text_rect = text.get_rect(center=(x, y))
        
        # Background
        pygame.draw.rect(surface, DARK_BLUE, 
                        (text_rect.x - 10, text_rect.y - 5, 
                         text_rect.width + 20, text_rect.height + 10))
        surface.blit(text, text_rect)
    
    def draw_dialog(self, surface, text, speaker=None):
        """Draw dialog box at bottom of screen"""
        box_height = 100
        box_y = SCREEN_HEIGHT - box_height - 20
        
        # Draw box
        pygame.draw.rect(surface, DARK_BLUE, (20, box_y, SCREEN_WIDTH - 40, box_height))
        pygame.draw.rect(surface, WHITE, (20, box_y, SCREEN_WIDTH - 40, box_height), 2)
        
        # Draw speaker name
        if speaker:
            name_text = self.font_medium.render(speaker, True, YELLOW)
            surface.blit(name_text, (40, box_y + 10))
            text_y = box_y + 40
        else:
            text_y = box_y + 20
        
        # Draw text (word wrap)
        words = text.split()
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + word + " "
            if self.font_medium.size(test_line)[0] < SCREEN_WIDTH - 80:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word + " "
        lines.append(current_line)
        
        for i, line in enumerate(lines):
            line_text = self.font_medium.render(line, True, WHITE)
            surface.blit(line_text, (40, text_y + i * 25))
    
    def draw_menu(self, surface, title, options, selected):
        """Draw a menu screen"""
        # Title
        title_text = self.font_large.render(title, True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 150))
        surface.blit(title_text, title_rect)
        
        # Options
        for i, option in enumerate(options):
            if i == selected:
                color = YELLOW
                prefix = "> "
            else:
                color = WHITE
                prefix = "  "
            
            option_text = self.font_medium.render(prefix + option, True, color)
            option_rect = option_text.get_rect(center=(SCREEN_WIDTH // 2, 250 + i * 50))
            surface.blit(option_text, option_rect)
    
    def draw_game_over(self, surface, score):
        """Draw game over screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Game Over text
        text = self.font_large.render("GAME OVER", True, RED)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        surface.blit(text, text_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 80))
        surface.blit(inst_text, inst_rect)
    
    def draw_victory(self, surface, score):
        """Draw victory screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Victory text
        text = self.font_large.render("VICTORY!", True, YELLOW)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 80))
        surface.blit(text, text_rect)
        
        # Story
        story = self.font_medium.render("You saved the Princess!", True, MINT)
        story_rect = story.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20))
        surface.blit(story, story_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 100))
        surface.blit(inst_text, inst_rect)
    
    def draw_pause(self, surface):
        """Draw pause overlay"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 128))
        surface.blit(overlay, (0, 0))
        
        # Pause text
        text = self.font_large.render("PAUSED", True, WHITE)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30))
        surface.blit(text, text_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ESC to resume", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30))
        surface.blit(inst_text, inst_rect)
    
    def draw_hud(self, surface, player):
        """Draw the full HUD"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_spell_selector(surface, player.spell_manager.selected_spell, 
                                player.spell_manager)
        self.draw_score(surface, player.score)
    
    def draw_world_map_hud(self, surface, player, current_location):
        """Draw HUD for world map"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_score(surface, player.score)
        
        # Location name
        if current_location:
            loc_text = self.font_medium.render(current_location, True, WHITE)
            loc_rect = loc_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 30))
            pygame.draw.rect(surface, DARK_BLUE, 
                           (loc_rect.x - 10, loc_rect.y - 5,
                            loc_rect.width + 20, loc_rect.height + 10))
            surface.blit(loc_text, loc_rect)
    
    def draw_controls_help(self, surface):
        """Draw controls help"""
        controls = [
            "Arrow Keys/WASD: Move",
            "Space: Jump",
            "Z: Attack",
            "X: Cast Spell",
            "1-4: Select Spell",
            "Enter: Interact",
            "ESC: Pause"
        ]
        
        y = SCREEN_HEIGHT - len(controls) * 20 - 20
        for control in controls:
            text = self.font_small.render(control, True, LIGHT_GRAY)
            surface.blit(text, (SCREEN_WIDTH - 180, y))
            y += 20

```

```python
"""
User Interface elements for Chain
"""

import pygame
from settings import *
from sprites import create_heart_sprite, create_magic_sprite


class UI:
    """Handles all UI rendering"""
    
    def __init__(self):
        # Initialize font
        pygame.font.init()
        self.font_large = pygame.font.Font(None, 56)
        self.font_medium = pygame.font.Font(None, 36)
        self.font_small = pygame.font.Font(None, 28)
        self.font_tiny = pygame.font.Font(None, 22)
        
        # Cache sprites and scale them up for prominence
        heart_full = create_heart_sprite(full=True)
        heart_empty = create_heart_sprite(full=False)
        magic_full = create_magic_sprite(full=True)
        magic_empty = create_magic_sprite(full=False)
        
        # Scale up HUD sprites by 1.5x for better visibility
        scale = 1.5
        self.heart_full = pygame.transform.scale(heart_full, 
            (int(heart_full.get_width() * scale), int(heart_full.get_height() * scale)))
        self.heart_empty = pygame.transform.scale(heart_empty, 
            (int(heart_empty.get_width() * scale), int(heart_empty.get_height() * scale)))
        self.magic_full = pygame.transform.scale(magic_full, 
            (int(magic_full.get_width() * scale), int(magic_full.get_height() * scale)))
        self.magic_empty = pygame.transform.scale(magic_empty, 
            (int(magic_empty.get_width() * scale), int(magic_empty.get_height() * scale)))
        
        # Spell icons
        self.spell_names = ['Shield', 'Swift', 'Fireball', 'Thunder']
        self.spell_colors = [CYAN, LIME, ORANGE, YELLOW]
    
    def draw_health_bar(self, surface, current, maximum, x=16, y=16):
        """Draw health hearts with background panel"""
        # Calculate panel size
        heart_w = self.heart_full.get_width()
        heart_h = self.heart_full.get_height()
        panel_width = maximum * (heart_w + 6) + 20
        panel_height = heart_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, RED, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("HP", True, RED)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw hearts
        for i in range(maximum):
            if i < current:
                sprite = self.heart_full
            else:
                sprite = self.heart_empty
            
            surface.blit(sprite, (x + 24 + i * (heart_w + 6), y))
    
    def draw_magic_bar(self, surface, current, maximum, x=16, y=60):
        """Draw magic crystals with background panel"""
        # Calculate panel size
        magic_w = self.magic_full.get_width()
        magic_h = self.magic_full.get_height()
        panel_width = maximum * (magic_w + 6) + 20
        panel_height = magic_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, CYAN, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("MP", True, CYAN)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw crystals
        for i in range(maximum):
            if i < current:
                sprite = self.magic_full
            else:
                sprite = self.magic_empty
            
            surface.blit(sprite, (x + 24 + i * (magic_w + 6), y))
    
    def draw_spell_selector(self, surface, selected_spell, spell_manager, x=20, y=85):
        """Draw spell selection UI"""
        for i, (name, color) in enumerate(zip(self.spell_names, self.spell_colors)):
            # Draw slot background
            slot_x = x + i * 55
            
            # Highlight selected
            if i == selected_spell:
                pygame.draw.rect(surface, color, (slot_x - 2, y - 2, 50, 38), 2)
            
            # Draw slot
            pygame.draw.rect(surface, DARK_BLUE, (slot_x, y, 46, 34))
            pygame.draw.rect(surface, color, (slot_x + 2, y + 2, 42, 20))
            
            # Draw spell number
            num_text = self.font_small.render(str(i + 1), True, WHITE)
            surface.blit(num_text, (slot_x + 18, y + 20))
            
            # Draw spell initial
            spell_text = self.font_small.render(name[0], True, DARK_BLUE)
            surface.blit(spell_text, (slot_x + 16, y + 4))
        
        # Show active buffs
        active_buffs = spell_manager.get_active_buffs()
        buff_y = y + 42
        for buff in active_buffs:
            buff_color = CYAN if buff == 'shield' else LIME
            pygame.draw.rect(surface, buff_color, (x, buff_y, 10, 10))
            buff_text = self.font_small.render(buff.capitalize(), True, WHITE)
            surface.blit(buff_text, (x + 15, buff_y - 2))
            buff_y += 15
    
    def draw_score(self, surface, score, x=None, y=20):
        """Draw score"""
        if x is None:
            x = SCREEN_WIDTH - 150
        
        score_text = self.font_medium.render(f"Score: {score}", True, YELLOW)
        surface.blit(score_text, (x, y))
    
    def draw_level_name(self, surface, name, x=None, y=None):
        """Draw level name at top center"""
        if x is None:
            x = SCREEN_WIDTH // 2
        if y is None:
            y = 20
        
        text = self.font_medium.render(name, True, WHITE)
        text_rect = text.get_rect(center=(x, y))
        
        # Background
        pygame.draw.rect(surface, DARK_BLUE, 
                        (text_rect.x - 10, text_rect.y - 5, 
                         text_rect.width + 20, text_rect.height + 10))
        surface.blit(text, text_rect)
    
    def draw_dialog(self, surface, text, speaker=None):
        """Draw dialog box at bottom of screen"""
        box_height = 100
        box_y = SCREEN_HEIGHT - box_height - 20
        
        # Draw box
        pygame.draw.rect(surface, DARK_BLUE, (20, box_y, SCREEN_WIDTH - 40, box_height))
        pygame.draw.rect(surface, WHITE, (20, box_y, SCREEN_WIDTH - 40, box_height), 2)
        
        # Draw speaker name
        if speaker:
            name_text = self.font_medium.render(speaker, True, YELLOW)
            surface.blit(name_text, (40, box_y + 10))
            text_y = box_y + 40
        else:
            text_y = box_y + 20
        
        # Draw text (word wrap)
        words = text.split()
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + word + " "
            if self.font_medium.size(test_line)[0] < SCREEN_WIDTH - 80:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word + " "
        lines.append(current_line)
        
        for i, line in enumerate(lines):
            line_text = self.font_medium.render(line, True, WHITE)
            surface.blit(line_text, (40, text_y + i * 25))
    
    def draw_menu(self, surface, title, options, selected):
        """Draw a menu screen"""
        # Title
        title_text = self.font_large.render(title, True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 150))
        surface.blit(title_text, title_rect)
        
        # Options
        for i, option in enumerate(options):
            if i == selected:
                color = YELLOW
                prefix = "> "
            else:
                color = WHITE
                prefix = "  "
            
            option_text = self.font_medium.render(prefix + option, True, color)
            option_rect = option_text.get_rect(center=(SCREEN_WIDTH // 2, 250 + i * 50))
            surface.blit(option_text, option_rect)
    
    def draw_game_over(self, surface, score):
        """Draw game over screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Game Over text
        text = self.font_large.render("GAME OVER", True, RED)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        surface.blit(text, text_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 80))
        surface.blit(inst_text, inst_rect)
    
    def draw_victory(self, surface, score):
        """Draw victory screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Victory text
        text = self.font_large.render("VICTORY!", True, YELLOW)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 80))
        surface.blit(text, text_rect)
        
        # Story
        story = self.font_medium.render("You saved the Princess!", True, MINT)
        story_rect = story.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20))
        surface.blit(story, story_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 100))
        surface.blit(inst_text, inst_rect)
    
    def draw_pause(self, surface):
        """Draw pause overlay"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 128))
        surface.blit(overlay, (0, 0))
        
        # Pause text
        text = self.font_large.render("PAUSED", True, WHITE)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30))
        surface.blit(text, text_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ESC to resume", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30))
        surface.blit(inst_text, inst_rect)
    
    def draw_hud(self, surface, player):
        """Draw the full HUD"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_spell_selector(surface, player.spell_manager.selected_spell, 
                                player.spell_manager)
        self.draw_score(surface, player.score)
    
    def draw_world_map_hud(self, surface, player, current_location):
        """Draw HUD for world map"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_score(surface, player.score)
        
        # Location name
        if current_location:
            loc_text = self.font_medium.render(current_location, True, WHITE)
            loc_rect = loc_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 30))
            pygame.draw.rect(surface, DARK_BLUE, 
                           (loc_rect.x - 10, loc_rect.y - 5,
                            loc_rect.width + 20, loc_rect.height + 10))
            surface.blit(loc_text, loc_rect)
    
    def draw_controls_help(self, surface):
        """Draw controls help"""
        controls = [
            "Arrow Keys/WASD: Move",
            "Space: Jump",
            "Z: Attack",
            "X: Cast Spell",
            "1-4: Select Spell",
            "Enter: Interact",
            "ESC: Pause"
        ]
        
        y = SCREEN_HEIGHT - len(controls) * 20 - 20
        for control in controls:
            text = self.font_small.render(control, True, LIGHT_GRAY)
            surface.blit(text, (SCREEN_WIDTH - 180, y))
            y += 20

```

```python
"""
User Interface elements for Chain
"""

import pygame
from settings import *
from sprites import create_heart_sprite, create_magic_sprite


class UI:
    """Handles all UI rendering"""
    
    def __init__(self):
        # Initialize font
        pygame.font.init()
        self.font_large = pygame.font.Font(None, 56)
        self.font_medium = pygame.font.Font(None, 36)
        self.font_small = pygame.font.Font(None, 28)
        self.font_tiny = pygame.font.Font(None, 22)
        
        # Cache sprites and scale them up for prominence
        heart_full = create_heart_sprite(full=True)
        heart_empty = create_heart_sprite(full=False)
        magic_full = create_magic_sprite(full=True)
        magic_empty = create_magic_sprite(full=False)
        
        # Scale up HUD sprites by 1.5x for better visibility
        scale = 1.5
        self.heart_full = pygame.transform.scale(heart_full, 
            (int(heart_full.get_width() * scale), int(heart_full.get_height() * scale)))
        self.heart_empty = pygame.transform.scale(heart_empty, 
            (int(heart_empty.get_width() * scale), int(heart_empty.get_height() * scale)))
        self.magic_full = pygame.transform.scale(magic_full, 
            (int(magic_full.get_width() * scale), int(magic_full.get_height() * scale)))
        self.magic_empty = pygame.transform.scale(magic_empty, 
            (int(magic_empty.get_width() * scale), int(magic_empty.get_height() * scale)))
        
        # Spell icons
        self.spell_names = ['Shield', 'Swift', 'Fireball', 'Thunder']
        self.spell_colors = [CYAN, LIME, ORANGE, YELLOW]
    
    def draw_health_bar(self, surface, current, maximum, x=16, y=16):
        """Draw health hearts with background panel"""
        # Calculate panel size
        heart_w = self.heart_full.get_width()
        heart_h = self.heart_full.get_height()
        panel_width = maximum * (heart_w + 6) + 20
        panel_height = heart_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, RED, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("HP", True, RED)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw hearts
        for i in range(maximum):
            if i < current:
                sprite = self.heart_full
            else:
                sprite = self.heart_empty
            
            surface.blit(sprite, (x + 24 + i * (heart_w + 6), y))
    
    def draw_magic_bar(self, surface, current, maximum, x=16, y=60):
        """Draw magic crystals with background panel"""
        # Calculate panel size
        magic_w = self.magic_full.get_width()
        magic_h = self.magic_full.get_height()
        panel_width = maximum * (magic_w + 6) + 20
        panel_height = magic_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, CYAN, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("MP", True, CYAN)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw crystals
        for i in range(maximum):
            if i < current:
                sprite = self.magic_full
            else:
                sprite = self.magic_empty
            
            surface.blit(sprite, (x + 24 + i * (magic_w + 6), y))
    
    def draw_spell_selector(self, surface, selected_spell, spell_manager, x=16, y=110):
        """Draw spell selection UI with background panel"""
        slot_width = 60
        slot_height = 50
        panel_width = 4 * slot_width + 30
        panel_height = slot_height + 40
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, YELLOW, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("SPELLS", True, YELLOW)
        surface.blit(label, (x, y - 6))
        
        for i, (name, color) in enumerate(zip(self.spell_names, self.spell_colors)):
            # Draw slot background
            slot_x = x + i * slot_width + 4
            slot_y = y + 12
            
            # Draw slot base
            pygame.draw.rect(surface, DARK_BROWN, (slot_x, slot_y, slot_width - 8, slot_height - 10))
            
            # Highlight selected with glow effect
            if i == selected_spell:
                pygame.draw.rect(surface, color, (slot_x - 3, slot_y - 3, slot_width - 2, slot_height - 4), 3)
                pygame.draw.rect(surface, WHITE, (slot_x, slot_y, slot_width - 8, slot_height - 10), 1)
            
            # Draw spell icon area
            pygame.draw.rect(surface, color, (slot_x + 4, slot_y + 4, slot_width - 16, 24))
            
            # Draw spell initial
            spell_text = self.font_medium.render(name[0], True, DARK_BLUE)
            surface.blit(spell_text, (slot_x + 14, slot_y + 6))
            
            # Draw spell number
            num_text = self.font_tiny.render(str(i + 1), True, LIGHT_GRAY)
            surface.blit(num_text, (slot_x + 20, slot_y + 30))
        
        # Show active buffs below spell bar
        active_buffs = spell_manager.get_active_buffs()
        if active_buffs:
            buff_y = y + panel_height - 4
            pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, buff_y, panel_width, 24))
            buff_x = x
            for buff in active_buffs:
                buff_color = CYAN if buff == 'shield' else LIME
                pygame.draw.rect(surface, buff_color, (buff_x, buff_y + 4, 12, 12))
                buff_text = self.font_tiny.render(buff.upper(), True, buff_color)
                surface.blit(buff_text, (buff_x + 16, buff_y + 4))
                buff_x += 80
    
    def draw_score(self, surface, score, x=None, y=20):
        """Draw score"""
        if x is None:
            x = SCREEN_WIDTH - 150
        
        score_text = self.font_medium.render(f"Score: {score}", True, YELLOW)
        surface.blit(score_text, (x, y))
    
    def draw_level_name(self, surface, name, x=None, y=None):
        """Draw level name at top center"""
        if x is None:
            x = SCREEN_WIDTH // 2
        if y is None:
            y = 20
        
        text = self.font_medium.render(name, True, WHITE)
        text_rect = text.get_rect(center=(x, y))
        
        # Background
        pygame.draw.rect(surface, DARK_BLUE, 
                        (text_rect.x - 10, text_rect.y - 5, 
                         text_rect.width + 20, text_rect.height + 10))
        surface.blit(text, text_rect)
    
    def draw_dialog(self, surface, text, speaker=None):
        """Draw dialog box at bottom of screen"""
        box_height = 100
        box_y = SCREEN_HEIGHT - box_height - 20
        
        # Draw box
        pygame.draw.rect(surface, DARK_BLUE, (20, box_y, SCREEN_WIDTH - 40, box_height))
        pygame.draw.rect(surface, WHITE, (20, box_y, SCREEN_WIDTH - 40, box_height), 2)
        
        # Draw speaker name
        if speaker:
            name_text = self.font_medium.render(speaker, True, YELLOW)
            surface.blit(name_text, (40, box_y + 10))
            text_y = box_y + 40
        else:
            text_y = box_y + 20
        
        # Draw text (word wrap)
        words = text.split()
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + word + " "
            if self.font_medium.size(test_line)[0] < SCREEN_WIDTH - 80:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word + " "
        lines.append(current_line)
        
        for i, line in enumerate(lines):
            line_text = self.font_medium.render(line, True, WHITE)
            surface.blit(line_text, (40, text_y + i * 25))
    
    def draw_menu(self, surface, title, options, selected):
        """Draw a menu screen"""
        # Title
        title_text = self.font_large.render(title, True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 150))
        surface.blit(title_text, title_rect)
        
        # Options
        for i, option in enumerate(options):
            if i == selected:
                color = YELLOW
                prefix = "> "
            else:
                color = WHITE
                prefix = "  "
            
            option_text = self.font_medium.render(prefix + option, True, color)
            option_rect = option_text.get_rect(center=(SCREEN_WIDTH // 2, 250 + i * 50))
            surface.blit(option_text, option_rect)
    
    def draw_game_over(self, surface, score):
        """Draw game over screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Game Over text
        text = self.font_large.render("GAME OVER", True, RED)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        surface.blit(text, text_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 80))
        surface.blit(inst_text, inst_rect)
    
    def draw_victory(self, surface, score):
        """Draw victory screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Victory text
        text = self.font_large.render("VICTORY!", True, YELLOW)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 80))
        surface.blit(text, text_rect)
        
        # Story
        story = self.font_medium.render("You saved the Princess!", True, MINT)
        story_rect = story.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20))
        surface.blit(story, story_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 100))
        surface.blit(inst_text, inst_rect)
    
    def draw_pause(self, surface):
        """Draw pause overlay"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 128))
        surface.blit(overlay, (0, 0))
        
        # Pause text
        text = self.font_large.render("PAUSED", True, WHITE)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30))
        surface.blit(text, text_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ESC to resume", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30))
        surface.blit(inst_text, inst_rect)
    
    def draw_hud(self, surface, player):
        """Draw the full HUD"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_spell_selector(surface, player.spell_manager.selected_spell, 
                                player.spell_manager)
        self.draw_score(surface, player.score)
    
    def draw_world_map_hud(self, surface, player, current_location):
        """Draw HUD for world map"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_score(surface, player.score)
        
        # Location name
        if current_location:
            loc_text = self.font_medium.render(current_location, True, WHITE)
            loc_rect = loc_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 30))
            pygame.draw.rect(surface, DARK_BLUE, 
                           (loc_rect.x - 10, loc_rect.y - 5,
                            loc_rect.width + 20, loc_rect.height + 10))
            surface.blit(loc_text, loc_rect)
    
    def draw_controls_help(self, surface):
        """Draw controls help"""
        controls = [
            "Arrow Keys/WASD: Move",
            "Space: Jump",
            "Z: Attack",
            "X: Cast Spell",
            "1-4: Select Spell",
            "Enter: Interact",
            "ESC: Pause"
        ]
        
        y = SCREEN_HEIGHT - len(controls) * 20 - 20
        for control in controls:
            text = self.font_small.render(control, True, LIGHT_GRAY)
            surface.blit(text, (SCREEN_WIDTH - 180, y))
            y += 20

```

```python
"""
User Interface elements for Chain
"""

import pygame
from settings import *
from sprites import create_heart_sprite, create_magic_sprite


class UI:
    """Handles all UI rendering"""
    
    def __init__(self):
        # Initialize font
        pygame.font.init()
        self.font_large = pygame.font.Font(None, 56)
        self.font_medium = pygame.font.Font(None, 36)
        self.font_small = pygame.font.Font(None, 28)
        self.font_tiny = pygame.font.Font(None, 22)
        
        # Cache sprites and scale them up for prominence
        heart_full = create_heart_sprite(full=True)
        heart_empty = create_heart_sprite(full=False)
        magic_full = create_magic_sprite(full=True)
        magic_empty = create_magic_sprite(full=False)
        
        # Scale up HUD sprites by 1.5x for better visibility
        scale = 1.5
        self.heart_full = pygame.transform.scale(heart_full, 
            (int(heart_full.get_width() * scale), int(heart_full.get_height() * scale)))
        self.heart_empty = pygame.transform.scale(heart_empty, 
            (int(heart_empty.get_width() * scale), int(heart_empty.get_height() * scale)))
        self.magic_full = pygame.transform.scale(magic_full, 
            (int(magic_full.get_width() * scale), int(magic_full.get_height() * scale)))
        self.magic_empty = pygame.transform.scale(magic_empty, 
            (int(magic_empty.get_width() * scale), int(magic_empty.get_height() * scale)))
        
        # Spell icons
        self.spell_names = ['Shield', 'Swift', 'Fireball', 'Thunder']
        self.spell_colors = [CYAN, LIME, ORANGE, YELLOW]
    
    def draw_health_bar(self, surface, current, maximum, x=16, y=16):
        """Draw health hearts with background panel"""
        # Calculate panel size
        heart_w = self.heart_full.get_width()
        heart_h = self.heart_full.get_height()
        panel_width = maximum * (heart_w + 6) + 20
        panel_height = heart_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, RED, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("HP", True, RED)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw hearts
        for i in range(maximum):
            if i < current:
                sprite = self.heart_full
            else:
                sprite = self.heart_empty
            
            surface.blit(sprite, (x + 24 + i * (heart_w + 6), y))
    
    def draw_magic_bar(self, surface, current, maximum, x=16, y=60):
        """Draw magic crystals with background panel"""
        # Calculate panel size
        magic_w = self.magic_full.get_width()
        magic_h = self.magic_full.get_height()
        panel_width = maximum * (magic_w + 6) + 20
        panel_height = magic_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, CYAN, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("MP", True, CYAN)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw crystals
        for i in range(maximum):
            if i < current:
                sprite = self.magic_full
            else:
                sprite = self.magic_empty
            
            surface.blit(sprite, (x + 24 + i * (magic_w + 6), y))
    
    def draw_spell_selector(self, surface, selected_spell, spell_manager, x=16, y=110):
        """Draw spell selection UI with background panel"""
        slot_width = 60
        slot_height = 50
        panel_width = 4 * slot_width + 30
        panel_height = slot_height + 40
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, YELLOW, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("SPELLS", True, YELLOW)
        surface.blit(label, (x, y - 6))
        
        for i, (name, color) in enumerate(zip(self.spell_names, self.spell_colors)):
            # Draw slot background
            slot_x = x + i * slot_width + 4
            slot_y = y + 12
            
            # Draw slot base
            pygame.draw.rect(surface, DARK_BROWN, (slot_x, slot_y, slot_width - 8, slot_height - 10))
            
            # Highlight selected with glow effect
            if i == selected_spell:
                pygame.draw.rect(surface, color, (slot_x - 3, slot_y - 3, slot_width - 2, slot_height - 4), 3)
                pygame.draw.rect(surface, WHITE, (slot_x, slot_y, slot_width - 8, slot_height - 10), 1)
            
            # Draw spell icon area
            pygame.draw.rect(surface, color, (slot_x + 4, slot_y + 4, slot_width - 16, 24))
            
            # Draw spell initial
            spell_text = self.font_medium.render(name[0], True, DARK_BLUE)
            surface.blit(spell_text, (slot_x + 14, slot_y + 6))
            
            # Draw spell number
            num_text = self.font_tiny.render(str(i + 1), True, LIGHT_GRAY)
            surface.blit(num_text, (slot_x + 20, slot_y + 30))
        
        # Show active buffs below spell bar
        active_buffs = spell_manager.get_active_buffs()
        if active_buffs:
            buff_y = y + panel_height - 4
            pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, buff_y, panel_width, 24))
            buff_x = x
            for buff in active_buffs:
                buff_color = CYAN if buff == 'shield' else LIME
                pygame.draw.rect(surface, buff_color, (buff_x, buff_y + 4, 12, 12))
                buff_text = self.font_tiny.render(buff.upper(), True, buff_color)
                surface.blit(buff_text, (buff_x + 16, buff_y + 4))
                buff_x += 80
    
    def draw_score(self, surface, score, x=None, y=16):
        """Draw score with background panel"""
        if x is None:
            x = SCREEN_WIDTH - 180
        
        score_str = f"SCORE: {score:,}"
        text_width = self.font_medium.size(score_str)[0]
        panel_width = text_width + 24
        panel_height = 40
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, YELLOW, (x - 8, y - 8, panel_width, panel_height), 2)
        
        score_text = self.font_medium.render(score_str, True, YELLOW)
        surface.blit(score_text, (x + 4, y + 2))
    
    def draw_level_name(self, surface, name, x=None, y=None):
        """Draw level name at top center"""
        if x is None:
            x = SCREEN_WIDTH // 2
        if y is None:
            y = 20
        
        text = self.font_medium.render(name, True, WHITE)
        text_rect = text.get_rect(center=(x, y))
        
        # Background
        pygame.draw.rect(surface, DARK_BLUE, 
                        (text_rect.x - 10, text_rect.y - 5, 
                         text_rect.width + 20, text_rect.height + 10))
        surface.blit(text, text_rect)
    
    def draw_dialog(self, surface, text, speaker=None):
        """Draw dialog box at bottom of screen"""
        box_height = 100
        box_y = SCREEN_HEIGHT - box_height - 20
        
        # Draw box
        pygame.draw.rect(surface, DARK_BLUE, (20, box_y, SCREEN_WIDTH - 40, box_height))
        pygame.draw.rect(surface, WHITE, (20, box_y, SCREEN_WIDTH - 40, box_height), 2)
        
        # Draw speaker name
        if speaker:
            name_text = self.font_medium.render(speaker, True, YELLOW)
            surface.blit(name_text, (40, box_y + 10))
            text_y = box_y + 40
        else:
            text_y = box_y + 20
        
        # Draw text (word wrap)
        words = text.split()
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + word + " "
            if self.font_medium.size(test_line)[0] < SCREEN_WIDTH - 80:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word + " "
        lines.append(current_line)
        
        for i, line in enumerate(lines):
            line_text = self.font_medium.render(line, True, WHITE)
            surface.blit(line_text, (40, text_y + i * 25))
    
    def draw_menu(self, surface, title, options, selected):
        """Draw a menu screen"""
        # Title
        title_text = self.font_large.render(title, True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 150))
        surface.blit(title_text, title_rect)
        
        # Options
        for i, option in enumerate(options):
            if i == selected:
                color = YELLOW
                prefix = "> "
            else:
                color = WHITE
                prefix = "  "
            
            option_text = self.font_medium.render(prefix + option, True, color)
            option_rect = option_text.get_rect(center=(SCREEN_WIDTH // 2, 250 + i * 50))
            surface.blit(option_text, option_rect)
    
    def draw_game_over(self, surface, score):
        """Draw game over screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Game Over text
        text = self.font_large.render("GAME OVER", True, RED)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        surface.blit(text, text_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 80))
        surface.blit(inst_text, inst_rect)
    
    def draw_victory(self, surface, score):
        """Draw victory screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Victory text
        text = self.font_large.render("VICTORY!", True, YELLOW)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 80))
        surface.blit(text, text_rect)
        
        # Story
        story = self.font_medium.render("You saved the Princess!", True, MINT)
        story_rect = story.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20))
        surface.blit(story, story_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 100))
        surface.blit(inst_text, inst_rect)
    
    def draw_pause(self, surface):
        """Draw pause overlay"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 128))
        surface.blit(overlay, (0, 0))
        
        # Pause text
        text = self.font_large.render("PAUSED", True, WHITE)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30))
        surface.blit(text, text_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ESC to resume", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30))
        surface.blit(inst_text, inst_rect)
    
    def draw_hud(self, surface, player):
        """Draw the full HUD"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_spell_selector(surface, player.spell_manager.selected_spell, 
                                player.spell_manager)
        self.draw_score(surface, player.score)
    
    def draw_world_map_hud(self, surface, player, current_location):
        """Draw HUD for world map"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_score(surface, player.score)
        
        # Location name
        if current_location:
            loc_text = self.font_medium.render(current_location, True, WHITE)
            loc_rect = loc_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 30))
            pygame.draw.rect(surface, DARK_BLUE, 
                           (loc_rect.x - 10, loc_rect.y - 5,
                            loc_rect.width + 20, loc_rect.height + 10))
            surface.blit(loc_text, loc_rect)
    
    def draw_controls_help(self, surface):
        """Draw controls help"""
        controls = [
            "Arrow Keys/WASD: Move",
            "Space: Jump",
            "Z: Attack",
            "X: Cast Spell",
            "1-4: Select Spell",
            "Enter: Interact",
            "ESC: Pause"
        ]
        
        y = SCREEN_HEIGHT - len(controls) * 20 - 20
        for control in controls:
            text = self.font_small.render(control, True, LIGHT_GRAY)
            surface.blit(text, (SCREEN_WIDTH - 180, y))
            y += 20

```

```python
"""
User Interface elements for Chain
"""

import pygame
from settings import *
from sprites import create_heart_sprite, create_magic_sprite


class UI:
    """Handles all UI rendering"""
    
    def __init__(self):
        # Initialize font
        pygame.font.init()
        self.font_large = pygame.font.Font(None, 56)
        self.font_medium = pygame.font.Font(None, 36)
        self.font_small = pygame.font.Font(None, 28)
        self.font_tiny = pygame.font.Font(None, 22)
        
        # Cache sprites and scale them up for prominence
        heart_full = create_heart_sprite(full=True)
        heart_empty = create_heart_sprite(full=False)
        magic_full = create_magic_sprite(full=True)
        magic_empty = create_magic_sprite(full=False)
        
        # Scale up HUD sprites by 1.5x for better visibility
        scale = 1.5
        self.heart_full = pygame.transform.scale(heart_full, 
            (int(heart_full.get_width() * scale), int(heart_full.get_height() * scale)))
        self.heart_empty = pygame.transform.scale(heart_empty, 
            (int(heart_empty.get_width() * scale), int(heart_empty.get_height() * scale)))
        self.magic_full = pygame.transform.scale(magic_full, 
            (int(magic_full.get_width() * scale), int(magic_full.get_height() * scale)))
        self.magic_empty = pygame.transform.scale(magic_empty, 
            (int(magic_empty.get_width() * scale), int(magic_empty.get_height() * scale)))
        
        # Spell icons
        self.spell_names = ['Shield', 'Swift', 'Fireball', 'Thunder']
        self.spell_colors = [CYAN, LIME, ORANGE, YELLOW]
    
    def draw_health_bar(self, surface, current, maximum, x=16, y=16):
        """Draw health hearts with background panel"""
        # Calculate panel size
        heart_w = self.heart_full.get_width()
        heart_h = self.heart_full.get_height()
        panel_width = maximum * (heart_w + 6) + 20
        panel_height = heart_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, RED, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("HP", True, RED)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw hearts
        for i in range(maximum):
            if i < current:
                sprite = self.heart_full
            else:
                sprite = self.heart_empty
            
            surface.blit(sprite, (x + 24 + i * (heart_w + 6), y))
    
    def draw_magic_bar(self, surface, current, maximum, x=16, y=60):
        """Draw magic crystals with background panel"""
        # Calculate panel size
        magic_w = self.magic_full.get_width()
        magic_h = self.magic_full.get_height()
        panel_width = maximum * (magic_w + 6) + 20
        panel_height = magic_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, CYAN, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("MP", True, CYAN)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw crystals
        for i in range(maximum):
            if i < current:
                sprite = self.magic_full
            else:
                sprite = self.magic_empty
            
            surface.blit(sprite, (x + 24 + i * (magic_w + 6), y))
    
    def draw_spell_selector(self, surface, selected_spell, spell_manager, x=16, y=110):
        """Draw spell selection UI with background panel"""
        slot_width = 60
        slot_height = 50
        panel_width = 4 * slot_width + 30
        panel_height = slot_height + 40
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, YELLOW, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("SPELLS", True, YELLOW)
        surface.blit(label, (x, y - 6))
        
        for i, (name, color) in enumerate(zip(self.spell_names, self.spell_colors)):
            # Draw slot background
            slot_x = x + i * slot_width + 4
            slot_y = y + 12
            
            # Draw slot base
            pygame.draw.rect(surface, DARK_BROWN, (slot_x, slot_y, slot_width - 8, slot_height - 10))
            
            # Highlight selected with glow effect
            if i == selected_spell:
                pygame.draw.rect(surface, color, (slot_x - 3, slot_y - 3, slot_width - 2, slot_height - 4), 3)
                pygame.draw.rect(surface, WHITE, (slot_x, slot_y, slot_width - 8, slot_height - 10), 1)
            
            # Draw spell icon area
            pygame.draw.rect(surface, color, (slot_x + 4, slot_y + 4, slot_width - 16, 24))
            
            # Draw spell initial
            spell_text = self.font_medium.render(name[0], True, DARK_BLUE)
            surface.blit(spell_text, (slot_x + 14, slot_y + 6))
            
            # Draw spell number
            num_text = self.font_tiny.render(str(i + 1), True, LIGHT_GRAY)
            surface.blit(num_text, (slot_x + 20, slot_y + 30))
        
        # Show active buffs below spell bar
        active_buffs = spell_manager.get_active_buffs()
        if active_buffs:
            buff_y = y + panel_height - 4
            pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, buff_y, panel_width, 24))
            buff_x = x
            for buff in active_buffs:
                buff_color = CYAN if buff == 'shield' else LIME
                pygame.draw.rect(surface, buff_color, (buff_x, buff_y + 4, 12, 12))
                buff_text = self.font_tiny.render(buff.upper(), True, buff_color)
                surface.blit(buff_text, (buff_x + 16, buff_y + 4))
                buff_x += 80
    
    def draw_score(self, surface, score, x=None, y=16):
        """Draw score with background panel"""
        if x is None:
            x = SCREEN_WIDTH - 180
        
        score_str = f"SCORE: {score:,}"
        text_width = self.font_medium.size(score_str)[0]
        panel_width = text_width + 24
        panel_height = 40
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, YELLOW, (x - 8, y - 8, panel_width, panel_height), 2)
        
        score_text = self.font_medium.render(score_str, True, YELLOW)
        surface.blit(score_text, (x + 4, y + 2))
    
    def draw_level_name(self, surface, name, x=None, y=None):
        """Draw level name at top center with prominent styling"""
        if x is None:
            x = SCREEN_WIDTH // 2
        if y is None:
            y = 24
        
        text = self.font_medium.render(name, True, WHITE)
        text_rect = text.get_rect(center=(x, y))
        
        # Background panel
        panel_rect = pygame.Rect(text_rect.x - 16, text_rect.y - 8, 
                                 text_rect.width + 32, text_rect.height + 16)
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 220), panel_rect)
        pygame.draw.rect(surface, WHITE, panel_rect, 2)
        pygame.draw.rect(surface, YELLOW, panel_rect.inflate(-4, -4), 1)
        
        surface.blit(text, text_rect)
    
    def draw_dialog(self, surface, text, speaker=None):
        """Draw dialog box at bottom of screen"""
        box_height = 100
        box_y = SCREEN_HEIGHT - box_height - 20
        
        # Draw box
        pygame.draw.rect(surface, DARK_BLUE, (20, box_y, SCREEN_WIDTH - 40, box_height))
        pygame.draw.rect(surface, WHITE, (20, box_y, SCREEN_WIDTH - 40, box_height), 2)
        
        # Draw speaker name
        if speaker:
            name_text = self.font_medium.render(speaker, True, YELLOW)
            surface.blit(name_text, (40, box_y + 10))
            text_y = box_y + 40
        else:
            text_y = box_y + 20
        
        # Draw text (word wrap)
        words = text.split()
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + word + " "
            if self.font_medium.size(test_line)[0] < SCREEN_WIDTH - 80:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word + " "
        lines.append(current_line)
        
        for i, line in enumerate(lines):
            line_text = self.font_medium.render(line, True, WHITE)
            surface.blit(line_text, (40, text_y + i * 25))
    
    def draw_menu(self, surface, title, options, selected):
        """Draw a menu screen"""
        # Title
        title_text = self.font_large.render(title, True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 150))
        surface.blit(title_text, title_rect)
        
        # Options
        for i, option in enumerate(options):
            if i == selected:
                color = YELLOW
                prefix = "> "
            else:
                color = WHITE
                prefix = "  "
            
            option_text = self.font_medium.render(prefix + option, True, color)
            option_rect = option_text.get_rect(center=(SCREEN_WIDTH // 2, 250 + i * 50))
            surface.blit(option_text, option_rect)
    
    def draw_game_over(self, surface, score):
        """Draw game over screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Game Over text
        text = self.font_large.render("GAME OVER", True, RED)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        surface.blit(text, text_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 80))
        surface.blit(inst_text, inst_rect)
    
    def draw_victory(self, surface, score):
        """Draw victory screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Victory text
        text = self.font_large.render("VICTORY!", True, YELLOW)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 80))
        surface.blit(text, text_rect)
        
        # Story
        story = self.font_medium.render("You saved the Princess!", True, MINT)
        story_rect = story.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20))
        surface.blit(story, story_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 100))
        surface.blit(inst_text, inst_rect)
    
    def draw_pause(self, surface):
        """Draw pause overlay"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 128))
        surface.blit(overlay, (0, 0))
        
        # Pause text
        text = self.font_large.render("PAUSED", True, WHITE)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30))
        surface.blit(text, text_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ESC to resume", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30))
        surface.blit(inst_text, inst_rect)
    
    def draw_hud(self, surface, player):
        """Draw the full HUD"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_spell_selector(surface, player.spell_manager.selected_spell, 
                                player.spell_manager)
        self.draw_score(surface, player.score)
    
    def draw_world_map_hud(self, surface, player, current_location):
        """Draw HUD for world map"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_score(surface, player.score)
        
        # Location name
        if current_location:
            loc_text = self.font_medium.render(current_location, True, WHITE)
            loc_rect = loc_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 30))
            pygame.draw.rect(surface, DARK_BLUE, 
                           (loc_rect.x - 10, loc_rect.y - 5,
                            loc_rect.width + 20, loc_rect.height + 10))
            surface.blit(loc_text, loc_rect)
    
    def draw_controls_help(self, surface):
        """Draw controls help"""
        controls = [
            "Arrow Keys/WASD: Move",
            "Space: Jump",
            "Z: Attack",
            "X: Cast Spell",
            "1-4: Select Spell",
            "Enter: Interact",
            "ESC: Pause"
        ]
        
        y = SCREEN_HEIGHT - len(controls) * 20 - 20
        for control in controls:
            text = self.font_small.render(control, True, LIGHT_GRAY)
            surface.blit(text, (SCREEN_WIDTH - 180, y))
            y += 20

```

```python
"""
User Interface elements for Chain
"""

import pygame
from settings import *
from sprites import create_heart_sprite, create_magic_sprite


class UI:
    """Handles all UI rendering"""
    
    def __init__(self):
        # Initialize font
        pygame.font.init()
        self.font_large = pygame.font.Font(None, 56)
        self.font_medium = pygame.font.Font(None, 36)
        self.font_small = pygame.font.Font(None, 28)
        self.font_tiny = pygame.font.Font(None, 22)
        
        # Cache sprites and scale them up for prominence
        heart_full = create_heart_sprite(full=True)
        heart_empty = create_heart_sprite(full=False)
        magic_full = create_magic_sprite(full=True)
        magic_empty = create_magic_sprite(full=False)
        
        # Scale up HUD sprites by 1.5x for better visibility
        scale = 1.5
        self.heart_full = pygame.transform.scale(heart_full, 
            (int(heart_full.get_width() * scale), int(heart_full.get_height() * scale)))
        self.heart_empty = pygame.transform.scale(heart_empty, 
            (int(heart_empty.get_width() * scale), int(heart_empty.get_height() * scale)))
        self.magic_full = pygame.transform.scale(magic_full, 
            (int(magic_full.get_width() * scale), int(magic_full.get_height() * scale)))
        self.magic_empty = pygame.transform.scale(magic_empty, 
            (int(magic_empty.get_width() * scale), int(magic_empty.get_height() * scale)))
        
        # Spell icons
        self.spell_names = ['Shield', 'Swift', 'Fireball', 'Thunder']
        self.spell_colors = [CYAN, LIME, ORANGE, YELLOW]
    
    def draw_health_bar(self, surface, current, maximum, x=16, y=16):
        """Draw health hearts with background panel"""
        # Calculate panel size
        heart_w = self.heart_full.get_width()
        heart_h = self.heart_full.get_height()
        panel_width = maximum * (heart_w + 6) + 20
        panel_height = heart_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, RED, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("HP", True, RED)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw hearts
        for i in range(maximum):
            if i < current:
                sprite = self.heart_full
            else:
                sprite = self.heart_empty
            
            surface.blit(sprite, (x + 24 + i * (heart_w + 6), y))
    
    def draw_magic_bar(self, surface, current, maximum, x=16, y=60):
        """Draw magic crystals with background panel"""
        # Calculate panel size
        magic_w = self.magic_full.get_width()
        magic_h = self.magic_full.get_height()
        panel_width = maximum * (magic_w + 6) + 20
        panel_height = magic_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, CYAN, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("MP", True, CYAN)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw crystals
        for i in range(maximum):
            if i < current:
                sprite = self.magic_full
            else:
                sprite = self.magic_empty
            
            surface.blit(sprite, (x + 24 + i * (magic_w + 6), y))
    
    def draw_spell_selector(self, surface, selected_spell, spell_manager, x=16, y=110):
        """Draw spell selection UI with background panel"""
        slot_width = 60
        slot_height = 50
        panel_width = 4 * slot_width + 30
        panel_height = slot_height + 40
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, YELLOW, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("SPELLS", True, YELLOW)
        surface.blit(label, (x, y - 6))
        
        for i, (name, color) in enumerate(zip(self.spell_names, self.spell_colors)):
            # Draw slot background
            slot_x = x + i * slot_width + 4
            slot_y = y + 12
            
            # Draw slot base
            pygame.draw.rect(surface, DARK_BROWN, (slot_x, slot_y, slot_width - 8, slot_height - 10))
            
            # Highlight selected with glow effect
            if i == selected_spell:
                pygame.draw.rect(surface, color, (slot_x - 3, slot_y - 3, slot_width - 2, slot_height - 4), 3)
                pygame.draw.rect(surface, WHITE, (slot_x, slot_y, slot_width - 8, slot_height - 10), 1)
            
            # Draw spell icon area
            pygame.draw.rect(surface, color, (slot_x + 4, slot_y + 4, slot_width - 16, 24))
            
            # Draw spell initial
            spell_text = self.font_medium.render(name[0], True, DARK_BLUE)
            surface.blit(spell_text, (slot_x + 14, slot_y + 6))
            
            # Draw spell number
            num_text = self.font_tiny.render(str(i + 1), True, LIGHT_GRAY)
            surface.blit(num_text, (slot_x + 20, slot_y + 30))
        
        # Show active buffs below spell bar
        active_buffs = spell_manager.get_active_buffs()
        if active_buffs:
            buff_y = y + panel_height - 4
            pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, buff_y, panel_width, 24))
            buff_x = x
            for buff in active_buffs:
                buff_color = CYAN if buff == 'shield' else LIME
                pygame.draw.rect(surface, buff_color, (buff_x, buff_y + 4, 12, 12))
                buff_text = self.font_tiny.render(buff.upper(), True, buff_color)
                surface.blit(buff_text, (buff_x + 16, buff_y + 4))
                buff_x += 80
    
    def draw_score(self, surface, score, x=None, y=16):
        """Draw score with background panel"""
        if x is None:
            x = SCREEN_WIDTH - 180
        
        score_str = f"SCORE: {score:,}"
        text_width = self.font_medium.size(score_str)[0]
        panel_width = text_width + 24
        panel_height = 40
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, YELLOW, (x - 8, y - 8, panel_width, panel_height), 2)
        
        score_text = self.font_medium.render(score_str, True, YELLOW)
        surface.blit(score_text, (x + 4, y + 2))
    
    def draw_level_name(self, surface, name, x=None, y=None):
        """Draw level name at top center with prominent styling"""
        if x is None:
            x = SCREEN_WIDTH // 2
        if y is None:
            y = 24
        
        text = self.font_medium.render(name, True, WHITE)
        text_rect = text.get_rect(center=(x, y))
        
        # Background panel
        panel_rect = pygame.Rect(text_rect.x - 16, text_rect.y - 8, 
                                 text_rect.width + 32, text_rect.height + 16)
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 220), panel_rect)
        pygame.draw.rect(surface, WHITE, panel_rect, 2)
        pygame.draw.rect(surface, YELLOW, panel_rect.inflate(-4, -4), 1)
        
        surface.blit(text, text_rect)
    
    def draw_dialog(self, surface, text, speaker=None):
        """Draw dialog box at bottom of screen"""
        box_height = 100
        box_y = SCREEN_HEIGHT - box_height - 20
        
        # Draw box
        pygame.draw.rect(surface, DARK_BLUE, (20, box_y, SCREEN_WIDTH - 40, box_height))
        pygame.draw.rect(surface, WHITE, (20, box_y, SCREEN_WIDTH - 40, box_height), 2)
        
        # Draw speaker name
        if speaker:
            name_text = self.font_medium.render(speaker, True, YELLOW)
            surface.blit(name_text, (40, box_y + 10))
            text_y = box_y + 40
        else:
            text_y = box_y + 20
        
        # Draw text (word wrap)
        words = text.split()
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + word + " "
            if self.font_medium.size(test_line)[0] < SCREEN_WIDTH - 80:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word + " "
        lines.append(current_line)
        
        for i, line in enumerate(lines):
            line_text = self.font_medium.render(line, True, WHITE)
            surface.blit(line_text, (40, text_y + i * 25))
    
    def draw_menu(self, surface, title, options, selected):
        """Draw a menu screen"""
        # Title
        title_text = self.font_large.render(title, True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 150))
        surface.blit(title_text, title_rect)
        
        # Options
        for i, option in enumerate(options):
            if i == selected:
                color = YELLOW
                prefix = "> "
            else:
                color = WHITE
                prefix = "  "
            
            option_text = self.font_medium.render(prefix + option, True, color)
            option_rect = option_text.get_rect(center=(SCREEN_WIDTH // 2, 250 + i * 50))
            surface.blit(option_text, option_rect)
    
    def draw_game_over(self, surface, score):
        """Draw game over screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Game Over text
        text = self.font_large.render("GAME OVER", True, RED)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        surface.blit(text, text_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 80))
        surface.blit(inst_text, inst_rect)
    
    def draw_victory(self, surface, score):
        """Draw victory screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Victory text
        text = self.font_large.render("VICTORY!", True, YELLOW)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 80))
        surface.blit(text, text_rect)
        
        # Story
        story = self.font_medium.render("You saved the Princess!", True, MINT)
        story_rect = story.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20))
        surface.blit(story, story_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 100))
        surface.blit(inst_text, inst_rect)
    
    def draw_pause(self, surface):
        """Draw pause overlay"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 128))
        surface.blit(overlay, (0, 0))
        
        # Pause text
        text = self.font_large.render("PAUSED", True, WHITE)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30))
        surface.blit(text, text_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ESC to resume", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30))
        surface.blit(inst_text, inst_rect)
    
    def draw_hud(self, surface, player):
        """Draw the full HUD"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_spell_selector(surface, player.spell_manager.selected_spell, 
                                player.spell_manager)
        self.draw_score(surface, player.score)
    
    def draw_world_map_hud(self, surface, player, current_location):
        """Draw HUD for world map"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_score(surface, player.score)
        
        # Location name with prominent panel
        if current_location:
            loc_text = self.font_medium.render(current_location, True, WHITE)
            loc_rect = loc_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 35))
            
            panel_rect = pygame.Rect(loc_rect.x - 20, loc_rect.y - 10,
                                    loc_rect.width + 40, loc_rect.height + 20)
            pygame.draw.rect(surface, (*DARK_BLUE[:3], 230), panel_rect)
            pygame.draw.rect(surface, YELLOW, panel_rect, 3)
            pygame.draw.rect(surface, WHITE, panel_rect.inflate(-4, -4), 1)
            
            surface.blit(loc_text, loc_rect)
    
    def draw_controls_help(self, surface):
        """Draw controls help"""
        controls = [
            "Arrow Keys/WASD: Move",
            "Space: Jump",
            "Z: Attack",
            "X: Cast Spell",
            "1-4: Select Spell",
            "Enter: Interact",
            "ESC: Pause"
        ]
        
        y = SCREEN_HEIGHT - len(controls) * 20 - 20
        for control in controls:
            text = self.font_small.render(control, True, LIGHT_GRAY)
            surface.blit(text, (SCREEN_WIDTH - 180, y))
            y += 20

```

The game is still running. Please close it and restart it with:

```bash
python main.py
```

The fixes I made:

1. **Fixed tile gaps**: The issue was that tiles were positioned at `TILE_SIZE * PIXEL_SCALE = 64` pixel intervals, but the actual tile images were only `16 * PIXEL_SCALE = 32` pixels. Now both the world map and level tiles use the actual image size for positioning, eliminating the gaps.

2. **Enhanced HUD elements**:
   - **Health bar**: Now has a dark panel background with a red border and "HP" label, hearts are 1.5x larger
   - **Magic bar**: Dark panel with cyan border and "MP" label, crystals are 1.5x larger  
   - **Spell selector**: Prominent panel with yellow border, larger spell slots with glow effect on selected spell, active buffs displayed below
   - **Score**: Has its own panel with yellow border in the top-right
   - **Level name**: Centered at top with double-bordered panel
   - **Location name** (world map): Larger panel at bottom with golden border

```shellscript
python main.py
```

---

**User**

WHen taking damage, there should be a cooldown period of 2 seconds.

---

**Cursor**

```python
"""
Game settings and constants for Chain
"""

# Display settings
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60
TILE_SIZE = 32
PIXEL_SCALE = 2  # For that chunky 16-bit look

# Game title
TITLE = "Chain - Quest for the Lost Princess"

# Colors - 16-bit palette inspired
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
DARK_BLUE = (24, 20, 37)
NAVY = (38, 43, 68)
PURPLE = (58, 68, 102)
SLATE = (90, 105, 136)
LIGHT_SLATE = (139, 155, 180)
SKY_BLUE = (87, 114, 119)
TEAL = (62, 137, 137)
CYAN = (116, 196, 182)
MINT = (177, 220, 176)

RED = (172, 50, 50)
DARK_RED = (102, 46, 46)
ORANGE = (223, 113, 38)
YELLOW = (251, 191, 69)
CREAM = (247, 228, 182)

GREEN = (75, 105, 47)
DARK_GREEN = (55, 75, 37)
LIME = (106, 190, 48)

PINK = (215, 123, 186)
MAGENTA = (143, 77, 137)

BROWN = (102, 57, 49)
DARK_BROWN = (63, 40, 50)
TAN = (143, 86, 59)
BEIGE = (217, 160, 102)

GRAY = (89, 86, 82)
LIGHT_GRAY = (155, 156, 130)

# Player settings
PLAYER_SPEED = 4
PLAYER_JUMP_SPEED = -12
PLAYER_GRAVITY = 0.5
PLAYER_MAX_HEALTH = 4
PLAYER_MAX_MAGIC = 4
PLAYER_ATTACK_COOLDOWN = 30  # frames
PLAYER_INVINCIBILITY_FRAMES = 120  # 2 seconds at 60 FPS

# Spell costs
SPELL_COSTS = {
    'shield': 1,
    'swift': 1,
    'fireball': 2,
    'thunder': 3
}

# Spell durations (in frames, for buffs)
SPELL_DURATIONS = {
    'shield': 300,  # 5 seconds
    'swift': 240,   # 4 seconds
}

# Buff effects
SHIELD_DAMAGE_REDUCTION = 0.5
SWIFT_SPEED_MULTIPLIER = 1.5
SWIFT_JUMP_MULTIPLIER = 1.3

# Projectile settings
FIREBALL_SPEED = 8
FIREBALL_DAMAGE = 2
THUNDER_RADIUS = 80
THUNDER_DAMAGE = 3

# Enemy settings
ENEMY_TYPES = {
    'slime': {
        'health': 2,
        'damage': 1,
        'speed': 1,
        'score': 10,
        'color': LIME
    },
    'bat': {
        'health': 1,
        'damage': 1,
        'speed': 2.5,
        'score': 20,
        'color': PURPLE
    },
    'knight': {
        'health': 4,
        'damage': 2,
        'speed': 1.5,
        'score': 50,
        'color': SLATE
    },
    'cannon': {
        'health': 20,
        'damage': 3,
        'speed': 2,
        'score': 500,
        'color': DARK_RED
    }
}

# Item settings
ITEM_TYPES = {
    'food': {
        'heal': 1,
        'color': ORANGE
    },
    'feast': {
        'heal': 2,
        'color': YELLOW
    },
    'magic_vial': {
        'restore': 1,
        'color': CYAN
    },
    'magic_potion': {
        'restore': 2,
        'color': TEAL
    },
    'heart_container': {
        'max_health_increase': 1,
        'color': RED
    },
    'magic_bottle': {
        'max_magic_increase': 1,
        'color': MAGENTA
    }
}

# World map settings
WORLD_MAP_WIDTH = 25
WORLD_MAP_HEIGHT = 19
WORLD_PLAYER_SPEED = 3

# Level types
LEVEL_FOREST = 'forest'
LEVEL_CAVE = 'cave'
LEVEL_CASTLE = 'castle'
LEVEL_BOSS = 'boss'

# Game states
STATE_MENU = 'menu'
STATE_WORLD_MAP = 'world_map'
STATE_LEVEL = 'level'
STATE_PAUSE = 'pause'
STATE_GAME_OVER = 'game_over'
STATE_VICTORY = 'victory'

```

Done! The damage cooldown is now 2 seconds (120 frames at 60 FPS). During this invincibility period, Chain will flash and be immune to all damage.

---

**User**

  The road in the world map currently connects top to bottom, but not left to right. Can we fix that?

---

**Cursor**

I see the issue. The path tile only draws a vertical strip. Let me fix it to fill the entire tile so paths connect in all directions:

```python
"""
Sprite rendering utilities for 16-bit pixel art style
"""

import pygame
from settings import *


def create_pixel_surface(width, height, scale=PIXEL_SCALE):
    """Create a surface for pixel art that will be scaled up"""
    return pygame.Surface((width, height), pygame.SRCALPHA)


def scale_surface(surface, scale=PIXEL_SCALE):
    """Scale a surface up for that chunky 16-bit look"""
    w, h = surface.get_size()
    return pygame.transform.scale(surface, (w * scale, h * scale))


def draw_pixel_rect(surface, color, rect, scale=1):
    """Draw a rectangle with pixel-perfect edges"""
    pygame.draw.rect(surface, color, rect)


def create_chain_sprite(facing_right=True, frame=0):
    """Create Chain's sprite - the hero"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    # Body (tunic)
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (4, 6, 8, 7))
    
    # Head
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (5, 2, 6, 5))
    
    # Hair (blue-ish)
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (5, 1, 6, 2))
    pygame.draw.rect(surface, hair_color, (4, 2, 1, 2))
    if facing_right:
        pygame.draw.rect(surface, hair_color, (11, 2, 1, 3))
    else:
        pygame.draw.rect(surface, hair_color, (4, 2, 1, 3))
    
    # Eyes
    eye_color = DARK_BLUE
    if facing_right:
        pygame.draw.rect(surface, eye_color, (9, 4, 1, 1))
    else:
        pygame.draw.rect(surface, eye_color, (6, 4, 1, 1))
    
    # Legs (animated)
    leg_color = BROWN
    if frame % 2 == 0:
        pygame.draw.rect(surface, leg_color, (5, 13, 2, 3))
        pygame.draw.rect(surface, leg_color, (9, 13, 2, 3))
    else:
        pygame.draw.rect(surface, leg_color, (4, 13, 2, 3))
        pygame.draw.rect(surface, leg_color, (10, 13, 2, 3))
    
    # Boots
    boot_color = DARK_BROWN
    if frame % 2 == 0:
        pygame.draw.rect(surface, boot_color, (5, 15, 2, 1))
        pygame.draw.rect(surface, boot_color, (9, 15, 2, 1))
    else:
        pygame.draw.rect(surface, boot_color, (4, 15, 2, 1))
        pygame.draw.rect(surface, boot_color, (10, 15, 2, 1))
    
    # Belt
    belt_color = BROWN
    pygame.draw.rect(surface, belt_color, (4, 10, 8, 1))
    
    # Belt buckle (chain link symbol)
    pygame.draw.rect(surface, YELLOW, (7, 10, 2, 1))
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_chain_attack_sprite(facing_right=True):
    """Create Chain's attack sprite with sword"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    # Base character (offset to make room for sword)
    offset_x = 4 if facing_right else 4
    
    # Body
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (offset_x + 4, 6, 8, 7))
    
    # Head
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (offset_x + 5, 2, 6, 5))
    
    # Hair
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (offset_x + 5, 1, 6, 2))
    
    # Eyes
    eye_color = DARK_BLUE
    if facing_right:
        pygame.draw.rect(surface, eye_color, (offset_x + 9, 4, 1, 1))
    else:
        pygame.draw.rect(surface, eye_color, (offset_x + 6, 4, 1, 1))
    
    # Legs
    leg_color = BROWN
    pygame.draw.rect(surface, leg_color, (offset_x + 5, 13, 2, 3))
    pygame.draw.rect(surface, leg_color, (offset_x + 9, 13, 2, 3))
    
    # Sword
    sword_color = LIGHT_SLATE
    sword_handle = BROWN
    if facing_right:
        pygame.draw.rect(surface, sword_handle, (offset_x + 12, 6, 2, 3))
        pygame.draw.rect(surface, sword_color, (offset_x + 14, 4, 6, 2))
        pygame.draw.rect(surface, YELLOW, (offset_x + 12, 5, 3, 1))  # Guard
    else:
        pygame.draw.rect(surface, sword_handle, (offset_x - 2, 6, 2, 3))
        pygame.draw.rect(surface, sword_color, (offset_x - 8, 4, 6, 2))
        pygame.draw.rect(surface, YELLOW, (offset_x - 3, 5, 3, 1))  # Guard
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_slime_sprite(frame=0):
    """Create slime enemy sprite"""
    size = 12
    surface = create_pixel_surface(size, size)
    
    color = LIME
    dark = DARK_GREEN
    
    # Body (bouncy animation)
    if frame % 20 < 10:
        pygame.draw.rect(surface, dark, (1, 6, 10, 6))
        pygame.draw.rect(surface, color, (2, 4, 8, 6))
        pygame.draw.rect(surface, color, (3, 3, 6, 2))
    else:
        pygame.draw.rect(surface, dark, (0, 8, 12, 4))
        pygame.draw.rect(surface, color, (1, 6, 10, 4))
        pygame.draw.rect(surface, color, (2, 5, 8, 2))
    
    # Eyes
    pygame.draw.rect(surface, WHITE, (3, 5, 2, 2))
    pygame.draw.rect(surface, WHITE, (7, 5, 2, 2))
    pygame.draw.rect(surface, BLACK, (4, 6, 1, 1))
    pygame.draw.rect(surface, BLACK, (8, 6, 1, 1))
    
    return scale_surface(surface)


def create_bat_sprite(frame=0):
    """Create bat enemy sprite"""
    size = 14
    surface = create_pixel_surface(size, size)
    
    color = PURPLE
    dark = DARK_BLUE
    
    # Body
    pygame.draw.rect(surface, color, (5, 5, 4, 5))
    pygame.draw.rect(surface, dark, (6, 4, 2, 2))
    
    # Wings (animated)
    if frame % 10 < 5:
        # Wings up
        pygame.draw.rect(surface, color, (0, 3, 5, 3))
        pygame.draw.rect(surface, color, (9, 3, 5, 3))
        pygame.draw.rect(surface, color, (1, 2, 3, 2))
        pygame.draw.rect(surface, color, (10, 2, 3, 2))
    else:
        # Wings down
        pygame.draw.rect(surface, color, (0, 6, 5, 3))
        pygame.draw.rect(surface, color, (9, 6, 5, 3))
        pygame.draw.rect(surface, color, (1, 8, 3, 2))
        pygame.draw.rect(surface, color, (10, 8, 3, 2))
    
    # Eyes (red, menacing)
    pygame.draw.rect(surface, RED, (5, 5, 1, 1))
    pygame.draw.rect(surface, RED, (8, 5, 1, 1))
    
    # Ears
    pygame.draw.rect(surface, color, (5, 3, 1, 2))
    pygame.draw.rect(surface, color, (8, 3, 1, 2))
    
    return scale_surface(surface)


def create_knight_sprite(facing_right=True, frame=0):
    """Create knight enemy sprite - armored and tough"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    armor_color = SLATE
    armor_dark = GRAY
    visor_color = DARK_BLUE
    
    # Body (armor)
    pygame.draw.rect(surface, armor_dark, (4, 6, 8, 7))
    pygame.draw.rect(surface, armor_color, (5, 5, 6, 6))
    
    # Helmet
    pygame.draw.rect(surface, armor_dark, (4, 1, 8, 5))
    pygame.draw.rect(surface, armor_color, (5, 2, 6, 3))
    
    # Visor
    pygame.draw.rect(surface, visor_color, (6, 3, 4, 2))
    pygame.draw.rect(surface, RED, (7, 3, 1, 1))  # Glowing eye
    pygame.draw.rect(surface, RED, (9, 3, 1, 1))  # Glowing eye
    
    # Shield
    if facing_right:
        pygame.draw.rect(surface, armor_dark, (2, 6, 3, 5))
        pygame.draw.rect(surface, armor_color, (2, 7, 2, 3))
    else:
        pygame.draw.rect(surface, armor_dark, (11, 6, 3, 5))
        pygame.draw.rect(surface, armor_color, (12, 7, 2, 3))
    
    # Sword
    sword_color = LIGHT_SLATE
    if facing_right:
        pygame.draw.rect(surface, sword_color, (12, 4, 2, 6))
        pygame.draw.rect(surface, sword_color, (13, 2, 1, 3))
    else:
        pygame.draw.rect(surface, sword_color, (2, 4, 2, 6))
        pygame.draw.rect(surface, sword_color, (2, 2, 1, 3))
    
    # Legs (armored)
    if frame % 2 == 0:
        pygame.draw.rect(surface, armor_dark, (5, 13, 2, 3))
        pygame.draw.rect(surface, armor_dark, (9, 13, 2, 3))
    else:
        pygame.draw.rect(surface, armor_dark, (4, 13, 2, 3))
        pygame.draw.rect(surface, armor_dark, (10, 13, 2, 3))
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_cannon_sprite(frame=0):
    """Create Cannon (boss) sprite - the archenemy"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    # Cape
    cape_color = DARK_RED
    pygame.draw.rect(surface, cape_color, (2, 6, 20, 14))
    pygame.draw.rect(surface, RED, (4, 8, 16, 10))
    
    # Body (dark armor)
    armor_color = DARK_BLUE
    armor_accent = NAVY
    pygame.draw.rect(surface, armor_color, (7, 6, 10, 10))
    pygame.draw.rect(surface, armor_accent, (8, 7, 8, 8))
    
    # Head (helmet with crown)
    pygame.draw.rect(surface, armor_color, (8, 1, 8, 6))
    pygame.draw.rect(surface, DARK_RED, (9, 3, 6, 3))  # Visor
    
    # Crown spikes
    pygame.draw.rect(surface, YELLOW, (8, 0, 2, 2))
    pygame.draw.rect(surface, YELLOW, (11, 0, 2, 1))
    pygame.draw.rect(surface, YELLOW, (14, 0, 2, 2))
    
    # Evil eyes
    pygame.draw.rect(surface, YELLOW, (10, 3, 1, 1))
    pygame.draw.rect(surface, YELLOW, (13, 3, 1, 1))
    
    # Cannon arm (signature weapon)
    cannon_color = GRAY
    if frame % 30 < 15:
        pygame.draw.rect(surface, cannon_color, (17, 8, 6, 4))
        pygame.draw.rect(surface, DARK_BROWN, (16, 9, 2, 2))
        pygame.draw.rect(surface, ORANGE, (22, 9, 2, 2))  # Charging
    else:
        pygame.draw.rect(surface, cannon_color, (17, 8, 6, 4))
        pygame.draw.rect(surface, DARK_BROWN, (16, 9, 2, 2))
    
    # Legs
    pygame.draw.rect(surface, armor_color, (8, 16, 3, 6))
    pygame.draw.rect(surface, armor_color, (13, 16, 3, 6))
    pygame.draw.rect(surface, DARK_BROWN, (8, 21, 3, 2))
    pygame.draw.rect(surface, DARK_BROWN, (13, 21, 3, 2))
    
    return scale_surface(surface)


def create_heart_sprite(full=True, is_container=False):
    """Create heart sprite for health display"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if is_container:
        color = YELLOW
        outline = ORANGE
    elif full:
        color = RED
        outline = DARK_RED
    else:
        color = GRAY
        outline = DARK_BROWN
    
    # Heart shape
    pygame.draw.rect(surface, outline, (1, 2, 3, 3))
    pygame.draw.rect(surface, outline, (6, 2, 3, 3))
    pygame.draw.rect(surface, outline, (0, 3, 2, 3))
    pygame.draw.rect(surface, outline, (8, 3, 2, 3))
    pygame.draw.rect(surface, outline, (2, 5, 6, 3))
    pygame.draw.rect(surface, outline, (3, 8, 4, 1))
    pygame.draw.rect(surface, outline, (4, 9, 2, 1))
    
    # Fill
    pygame.draw.rect(surface, color, (2, 3, 2, 2))
    pygame.draw.rect(surface, color, (6, 3, 2, 2))
    pygame.draw.rect(surface, color, (1, 4, 2, 2))
    pygame.draw.rect(surface, color, (7, 4, 2, 2))
    pygame.draw.rect(surface, color, (3, 5, 4, 2))
    pygame.draw.rect(surface, color, (4, 7, 2, 1))
    
    # Highlight
    if full or is_container:
        pygame.draw.rect(surface, WHITE, (2, 3, 1, 1))
    
    return scale_surface(surface)


def create_magic_sprite(full=True, is_bottle=False):
    """Create magic point sprite (star/crystal)"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if is_bottle:
        color = MAGENTA
        outline = PURPLE
    elif full:
        color = CYAN
        outline = TEAL
    else:
        color = GRAY
        outline = DARK_BROWN
    
    # Crystal/star shape
    pygame.draw.rect(surface, outline, (4, 0, 2, 2))
    pygame.draw.rect(surface, outline, (3, 2, 4, 2))
    pygame.draw.rect(surface, outline, (0, 3, 10, 2))
    pygame.draw.rect(surface, outline, (2, 5, 6, 2))
    pygame.draw.rect(surface, outline, (3, 7, 4, 2))
    pygame.draw.rect(surface, outline, (4, 9, 2, 1))
    
    # Fill
    pygame.draw.rect(surface, color, (4, 1, 2, 1))
    pygame.draw.rect(surface, color, (3, 3, 4, 1))
    pygame.draw.rect(surface, color, (1, 4, 8, 1))
    pygame.draw.rect(surface, color, (3, 5, 4, 1))
    pygame.draw.rect(surface, color, (4, 6, 2, 2))
    
    # Highlight
    if full or is_bottle:
        pygame.draw.rect(surface, WHITE, (4, 3, 1, 1))
    
    return scale_surface(surface)


def create_food_sprite(food_type='food'):
    """Create food item sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if food_type == 'feast':
        # Roasted chicken leg
        pygame.draw.rect(surface, TAN, (2, 2, 6, 5))
        pygame.draw.rect(surface, BEIGE, (3, 3, 4, 3))
        pygame.draw.rect(surface, BROWN, (1, 6, 2, 3))  # Bone
        pygame.draw.rect(surface, CREAM, (1, 8, 2, 1))
    else:
        # Apple
        pygame.draw.rect(surface, RED, (2, 3, 6, 5))
        pygame.draw.rect(surface, RED, (3, 2, 4, 1))
        pygame.draw.rect(surface, DARK_RED, (2, 6, 6, 2))
        pygame.draw.rect(surface, BROWN, (4, 0, 2, 3))  # Stem
        pygame.draw.rect(surface, GREEN, (5, 1, 2, 2))  # Leaf
        pygame.draw.rect(surface, WHITE, (3, 3, 1, 1))  # Highlight
    
    return scale_surface(surface)


def create_magic_vial_sprite(vial_type='magic_vial'):
    """Create magic vial sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if vial_type == 'magic_potion':
        color = TEAL
        liquid = CYAN
    else:
        color = PURPLE
        liquid = MAGENTA
    
    # Bottle
    pygame.draw.rect(surface, LIGHT_GRAY, (3, 0, 4, 2))  # Cork
    pygame.draw.rect(surface, LIGHT_SLATE, (2, 2, 6, 2))  # Neck
    pygame.draw.rect(surface, LIGHT_SLATE, (1, 4, 8, 5))  # Body outline
    
    # Liquid
    pygame.draw.rect(surface, color, (2, 5, 6, 3))
    pygame.draw.rect(surface, liquid, (3, 6, 4, 2))
    
    # Highlight
    pygame.draw.rect(surface, WHITE, (2, 4, 1, 2))
    
    # Sparkle
    pygame.draw.rect(surface, WHITE, (5, 5, 1, 1))
    
    return scale_surface(surface)


def create_fireball_sprite(frame=0):
    """Create fireball projectile sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    # Core
    pygame.draw.rect(surface, YELLOW, (3, 3, 4, 4))
    pygame.draw.rect(surface, WHITE, (4, 4, 2, 2))
    
    # Flames (animated)
    if frame % 4 < 2:
        pygame.draw.rect(surface, ORANGE, (2, 2, 2, 2))
        pygame.draw.rect(surface, ORANGE, (6, 2, 2, 2))
        pygame.draw.rect(surface, ORANGE, (2, 6, 2, 2))
        pygame.draw.rect(surface, ORANGE, (6, 6, 2, 2))
        pygame.draw.rect(surface, RED, (1, 4, 2, 2))
    else:
        pygame.draw.rect(surface, ORANGE, (1, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (7, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (1, 5, 2, 2))
        pygame.draw.rect(surface, ORANGE, (7, 5, 2, 2))
        pygame.draw.rect(surface, RED, (0, 4, 2, 2))
    
    return scale_surface(surface)


def create_thunder_sprite(frame=0):
    """Create thunder effect sprite"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    # Lightning bolt shape
    color = YELLOW if frame % 4 < 2 else WHITE
    
    pygame.draw.rect(surface, color, (8, 0, 3, 4))
    pygame.draw.rect(surface, color, (6, 3, 4, 3))
    pygame.draw.rect(surface, color, (4, 5, 6, 3))
    pygame.draw.rect(surface, color, (6, 7, 4, 3))
    pygame.draw.rect(surface, color, (8, 9, 3, 4))
    pygame.draw.rect(surface, color, (10, 12, 2, 4))
    
    return scale_surface(surface)


def create_shield_effect_sprite(frame=0):
    """Create shield buff visual effect"""
    size = 20
    surface = create_pixel_surface(size, size)
    
    # Shimmering shield
    alpha = 128 + int(64 * ((frame % 30) / 30))
    color = (*CYAN[:3], alpha)
    
    # Circular shield
    for i in range(8):
        angle_offset = (frame * 3 + i * 45) % 360
        x = int(10 + 7 * (1 if i % 2 == 0 else -1) * ((frame + i * 5) % 10) / 10)
        y = int(10 + 7 * (1 if i < 4 else -1) * ((frame + i * 5) % 10) / 10)
        pygame.draw.rect(surface, CYAN, (x, y, 2, 2))
    
    # Border
    pygame.draw.rect(surface, TEAL, (0, 8, 2, 4))
    pygame.draw.rect(surface, TEAL, (18, 8, 2, 4))
    pygame.draw.rect(surface, TEAL, (8, 0, 4, 2))
    pygame.draw.rect(surface, TEAL, (8, 18, 4, 2))
    
    return scale_surface(surface)


def create_tile_sprite(tile_type, variant=0):
    """Create tile sprites for levels"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    if tile_type == 'grass':
        pygame.draw.rect(surface, GREEN, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIME, (0, 0, 16, 4))
        # Grass detail
        for i in range(4):
            x = (i * 4 + variant) % 16
            pygame.draw.rect(surface, DARK_GREEN, (x, 4, 1, 2))
    
    elif tile_type == 'dirt':
        pygame.draw.rect(surface, BROWN, (0, 0, 16, 16))
        pygame.draw.rect(surface, TAN, (2, 2, 3, 2))
        pygame.draw.rect(surface, TAN, (10, 8, 4, 3))
        pygame.draw.rect(surface, DARK_BROWN, (6, 12, 2, 2))
    
    elif tile_type == 'stone':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIGHT_GRAY, (1, 1, 6, 5))
        pygame.draw.rect(surface, LIGHT_GRAY, (9, 8, 5, 6))
        pygame.draw.rect(surface, DARK_BROWN, (0, 7, 16, 1))
        pygame.draw.rect(surface, DARK_BROWN, (7, 0, 1, 16))
    
    elif tile_type == 'brick':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        # Brick pattern
        pygame.draw.rect(surface, RED, (1, 1, 6, 6))
        pygame.draw.rect(surface, RED, (9, 1, 6, 6))
        pygame.draw.rect(surface, RED, (1, 9, 14, 6))
        pygame.draw.rect(surface, BROWN, (0, 7, 16, 2))
        pygame.draw.rect(surface, BROWN, (7, 0, 2, 8))
    
    elif tile_type == 'wood':
        pygame.draw.rect(surface, BROWN, (0, 0, 16, 16))
        # Wood grain
        for i in range(4):
            y = i * 4 + 1
            pygame.draw.rect(surface, TAN, (0, y, 16, 2))
        pygame.draw.rect(surface, DARK_BROWN, (4, 0, 1, 16))
        pygame.draw.rect(surface, DARK_BROWN, (11, 0, 1, 16))
    
    elif tile_type == 'water':
        base = TEAL if variant % 2 == 0 else SKY_BLUE
        pygame.draw.rect(surface, base, (0, 0, 16, 16))
        # Waves
        wave_color = CYAN
        for i in range(3):
            x = (i * 6 + variant * 2) % 16
            pygame.draw.rect(surface, wave_color, (x, 4, 4, 1))
            pygame.draw.rect(surface, wave_color, ((x + 3) % 16, 10, 4, 1))
    
    elif tile_type == 'lava':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        pygame.draw.rect(surface, RED, (2, 2, 5, 4))
        pygame.draw.rect(surface, RED, (9, 7, 5, 5))
        pygame.draw.rect(surface, ORANGE, (3, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (10, 9, 3, 2))
        pygame.draw.rect(surface, YELLOW, (4, 3, 1, 1))
    
    elif tile_type == 'sky':
        pygame.draw.rect(surface, SKY_BLUE, (0, 0, 16, 16))
        if variant % 3 == 0:
            # Cloud
            pygame.draw.rect(surface, WHITE, (2, 4, 8, 4))
            pygame.draw.rect(surface, WHITE, (4, 2, 4, 2))
    
    return scale_surface(surface)


def create_world_map_tile(tile_type):
    """Create tiles for the world map"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    if tile_type == 'grass':
        pygame.draw.rect(surface, GREEN, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIME, (3, 3, 2, 2))
        pygame.draw.rect(surface, LIME, (10, 8, 2, 2))
        pygame.draw.rect(surface, DARK_GREEN, (7, 12, 2, 2))
    
    elif tile_type == 'forest':
        pygame.draw.rect(surface, DARK_GREEN, (0, 0, 16, 16))
        # Trees
        pygame.draw.rect(surface, GREEN, (2, 4, 4, 6))
        pygame.draw.rect(surface, GREEN, (10, 2, 4, 8))
        pygame.draw.rect(surface, BROWN, (3, 10, 2, 4))
        pygame.draw.rect(surface, BROWN, (11, 10, 2, 4))
    
    elif tile_type == 'mountain':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        # Mountain peak
        pygame.draw.rect(surface, SLATE, (6, 0, 4, 6))
        pygame.draw.rect(surface, SLATE, (4, 6, 8, 4))
        pygame.draw.rect(surface, SLATE, (2, 10, 12, 6))
        pygame.draw.rect(surface, WHITE, (7, 1, 2, 3))  # Snow cap
    
    elif tile_type == 'water':
        pygame.draw.rect(surface, NAVY, (0, 0, 16, 16))
        pygame.draw.rect(surface, TEAL, (2, 4, 6, 2))
        pygame.draw.rect(surface, TEAL, (8, 10, 6, 2))
    
    elif tile_type == 'path':
        # Full path tile that connects in all directions
        pygame.draw.rect(surface, TAN, (0, 0, 16, 16))
        # Add some texture/detail
        pygame.draw.rect(surface, BEIGE, (2, 2, 4, 4))
        pygame.draw.rect(surface, BEIGE, (10, 10, 4, 4))
        pygame.draw.rect(surface, BROWN, (7, 6, 2, 2))
        pygame.draw.rect(surface, BROWN, (1, 12, 2, 2))
        pygame.draw.rect(surface, BROWN, (12, 2, 2, 2))
    
    elif tile_type == 'castle':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        # Castle structure
        pygame.draw.rect(surface, SLATE, (2, 4, 12, 12))
        pygame.draw.rect(surface, SLATE, (0, 2, 4, 4))
        pygame.draw.rect(surface, SLATE, (12, 2, 4, 4))
        pygame.draw.rect(surface, DARK_BLUE, (6, 10, 4, 6))  # Door
        pygame.draw.rect(surface, RED, (2, 0, 2, 3))  # Flag
    
    elif tile_type == 'cave':
        pygame.draw.rect(surface, DARK_BROWN, (0, 0, 16, 16))
        pygame.draw.rect(surface, BLACK, (4, 6, 8, 10))
        pygame.draw.rect(surface, DARK_BROWN, (2, 4, 12, 4))
    
    elif tile_type == 'boss':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        # Evil castle
        pygame.draw.rect(surface, DARK_BLUE, (2, 4, 12, 12))
        pygame.draw.rect(surface, DARK_BLUE, (0, 2, 4, 4))
        pygame.draw.rect(surface, DARK_BLUE, (12, 2, 4, 4))
        pygame.draw.rect(surface, BLACK, (6, 10, 4, 6))
        pygame.draw.rect(surface, YELLOW, (4, 6, 2, 2))  # Evil eye
        pygame.draw.rect(surface, YELLOW, (10, 6, 2, 2))  # Evil eye
    
    elif tile_type == 'level_marker':
        pygame.draw.rect(surface, YELLOW, (4, 4, 8, 8))
        pygame.draw.rect(surface, ORANGE, (6, 6, 4, 4))
    
    return scale_surface(surface)


def create_chain_world_sprite(facing='down', frame=0):
    """Create Chain sprite for world map (top-down view)"""
    size = 12
    surface = create_pixel_surface(size, size)
    
    # Body
    pygame.draw.rect(surface, TEAL, (3, 3, 6, 6))
    
    # Head direction
    skin = BEIGE
    hair = NAVY
    
    if facing == 'down':
        pygame.draw.rect(surface, hair, (4, 2, 4, 2))
        pygame.draw.rect(surface, skin, (4, 4, 4, 3))
        pygame.draw.rect(surface, DARK_BLUE, (5, 5, 1, 1))
        pygame.draw.rect(surface, DARK_BLUE, (7, 5, 1, 1))
    elif facing == 'up':
        pygame.draw.rect(surface, hair, (4, 2, 4, 4))
        pygame.draw.rect(surface, skin, (5, 5, 2, 2))
    elif facing == 'left':
        pygame.draw.rect(surface, hair, (3, 2, 4, 3))
        pygame.draw.rect(surface, skin, (3, 4, 3, 3))
        pygame.draw.rect(surface, DARK_BLUE, (3, 5, 1, 1))
    elif facing == 'right':
        pygame.draw.rect(surface, hair, (5, 2, 4, 3))
        pygame.draw.rect(surface, skin, (6, 4, 3, 3))
        pygame.draw.rect(surface, DARK_BLUE, (8, 5, 1, 1))
    
    # Feet (animated)
    if frame % 20 < 10:
        pygame.draw.rect(surface, BROWN, (3, 9, 2, 2))
        pygame.draw.rect(surface, BROWN, (7, 9, 2, 2))
    else:
        pygame.draw.rect(surface, BROWN, (4, 9, 2, 2))
        pygame.draw.rect(surface, BROWN, (6, 9, 2, 2))
    
    return scale_surface(surface)

```

Done! The path tiles now fill the entire tile with the tan/beige road color, so they'll connect seamlessly in all directions - horizontally and vertically.

---

**User**

Let's add more dungeons now. The cave and Cannon's domain should beoth also have side-scroll levels. Cannon's domain should be more difficult.

---

**Cursor**

I'll add more side-scroll levels and make Cannon's domain a challenging dungeon. Let me expand the world map and create new level content.

```python
"""
World Map for traversing between adventures
"""

import pygame
from settings import *
from sprites import create_world_map_tile


class WorldMapTile:
    """A tile on the world map"""
    
    def __init__(self, x, y, tile_type, walkable=True, level_id=None):
        self.tile_type = tile_type
        self.walkable = walkable
        self.level_id = level_id  # If this tile leads to a level
        
        self.image = create_world_map_tile(tile_type)
        # Use actual image size for positioning (16 * PIXEL_SCALE = 32)
        tile_size = self.image.get_width()
        self.rect = pygame.Rect(
            x * tile_size,
            y * tile_size,
            tile_size,
            tile_size
        )
        self.grid_x = x
        self.grid_y = y
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


class LevelMarker:
    """Marker for a level entrance on the world map"""
    
    def __init__(self, grid_x, grid_y, level_id, level_name, level_type):
        self.grid_x = grid_x
        self.grid_y = grid_y
        self.level_id = level_id
        self.level_name = level_name
        self.level_type = level_type
        self.completed = False
        self.unlocked = False
        
        self.image = create_world_map_tile('level_marker')
        # Use actual image size for positioning (16 * PIXEL_SCALE = 32)
        tile_size = self.image.get_width()
        self.rect = pygame.Rect(
            grid_x * tile_size,
            grid_y * tile_size,
            tile_size,
            tile_size
        )
        
        # Animation
        self.frame = 0
    
    def update(self):
        self.frame += 1
    
    def draw(self, surface, camera_offset=(0, 0)):
        if not self.unlocked:
            return
        
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Pulsing effect
        import math
        pulse = int(math.sin(self.frame * 0.1) * 3)
        
        # Draw marker
        if self.completed:
            # Completed levels show as green
            completed_img = pygame.Surface(self.image.get_size(), pygame.SRCALPHA)
            completed_img.blit(self.image, (0, 0))
            completed_img.fill((*LIME[:3], 100), special_flags=pygame.BLEND_RGBA_ADD)
            surface.blit(completed_img, (draw_x, draw_y + pulse))
        else:
            surface.blit(self.image, (draw_x, draw_y + pulse))


class WorldMap:
    """The overworld map for traversing between levels"""
    
    def __init__(self):
        self.tiles = []
        self.level_markers = []
        self.map_width = WORLD_MAP_WIDTH
        self.map_height = WORLD_MAP_HEIGHT
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Current level selection
        self.current_marker_index = 0
        
        self.generate_map()
    
    def generate_map(self):
        """Generate the world map"""
        # Define the map layout
        # Legend: G=grass, F=forest, M=mountain, W=water, P=path, C=castle, V=cave, B=boss
        map_data = [
            "MMMMMMMMMWWWWWWWWWWWMMMMMM",
            "MMMMMMMMWWWWWWWWWWWWMMMMMM",
            "MMMMFFFFFGGGGGGGFFFMMMMMM",
            "MMMFFFFFFGGGGGGGGFFMMMMMM",
            "MMFFFFFFFGGCGGGGGFFFMMMMM",
            "MFFFFFFFGGPPGGGGFFFFMMMMM",
            "FFFFFFFFGGPPGGGGFFFFFMMMM",
            "FFFFFFFGGGPPGGGGFFFFFFMMM",
            "FFFFFFGGGGPPPPGGGFFFFFMMM",
            "FFFFFGGGGGGGPPGGGFFFFFFMM",
            "FFFFGGGGGVGGPPGGGFFFFFFMM",
            "FFFGGGGGGGGPPPPPPPFFFFMMM",
            "FFFGGGGGGGPPGGGGGPPFFFMMM",
            "FFGGGGGGGGPPGGGGGGPPPFMMM",
            "FGGGGGGGGGPPGGGGGGGGBFMMM",
            "GGGGGGGGGPPPPGGGGGGGGFMMM",
            "GGGGGGGGGGGPPGGGGGGGFFMMM",
            "WWWWWWWWWWWWWWWWWWWWWWWWW",
            "WWWWWWWWWWWWWWWWWWWWWWWWW",
        ]
        
        tile_map = {
            'G': ('grass', True),
            'F': ('forest', False),
            'M': ('mountain', False),
            'W': ('water', False),
            'P': ('path', True),
            'C': ('castle', True),
            'V': ('cave', True),
            'B': ('boss', True),
        }
        
        # Create tiles
        for y, row in enumerate(map_data):
            for x, char in enumerate(row):
                if char in tile_map:
                    tile_type, walkable = tile_map[char]
                    tile = WorldMapTile(x, y, tile_type, walkable)
                    self.tiles.append(tile)
        
        # Create level markers - progression through the world
        self.level_markers = [
            LevelMarker(10, 4, 'castle', "Castle Entrance", LEVEL_CASTLE),
            LevelMarker(9, 10, 'cave', "Dark Cave", LEVEL_CAVE),
            LevelMarker(17, 11, 'fortress', "Cannon's Domain", LEVEL_CASTLE),
            LevelMarker(19, 14, 'boss', "Cannon's Throne", LEVEL_BOSS),
        ]
        
        # Start with first level unlocked
        self.level_markers[0].unlocked = True
    
    def get_walkable_tiles(self):
        """Get list of walkable tiles for collision"""
        return [tile for tile in self.tiles if not tile.walkable]
    
    def get_current_level_marker(self, player_rect):
        """Check if player is on a level marker"""
        for marker in self.level_markers:
            if marker.unlocked and player_rect.colliderect(marker.rect):
                return marker
        return None
    
    def complete_level(self, level_id):
        """Mark a level as completed and unlock next"""
        for i, marker in enumerate(self.level_markers):
            if marker.level_id == level_id:
                marker.completed = True
                # Unlock next level
                if i + 1 < len(self.level_markers):
                    self.level_markers[i + 1].unlocked = True
                break
    
    def get_start_position(self):
        """Get the starting position for the player"""
        # Start near the first level marker
        first_marker = self.level_markers[0]
        return (
            first_marker.rect.x,
            first_marker.rect.y + TILE_SIZE * PIXEL_SCALE
        )
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center camera on player
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth camera movement
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.1
        
        # Clamp to map bounds (tile size is 16 * PIXEL_SCALE = 32)
        actual_tile_size = 16 * PIXEL_SCALE
        max_x = self.map_width * actual_tile_size - SCREEN_WIDTH
        max_y = self.map_height * actual_tile_size - SCREEN_HEIGHT
        
        self.camera_x = max(0, min(self.camera_x, max_x))
        self.camera_y = max(0, min(self.camera_y, max_y))
    
    def update(self, player):
        """Update world map state"""
        self.update_camera(player)
        
        for marker in self.level_markers:
            marker.update()
    
    def draw(self, surface):
        """Draw the world map"""
        camera_offset = (int(self.camera_x), int(self.camera_y))
        
        # Draw tiles
        for tile in self.tiles:
            # Only draw visible tiles
            if (tile.rect.x - camera_offset[0] > -TILE_SIZE * PIXEL_SCALE and
                tile.rect.x - camera_offset[0] < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                tile.rect.y - camera_offset[1] > -TILE_SIZE * PIXEL_SCALE and
                tile.rect.y - camera_offset[1] < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                tile.draw(surface, camera_offset)
        
        # Draw level markers
        for marker in self.level_markers:
            marker.draw(surface, camera_offset)
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def get_location_name(self, player_rect):
        """Get the name of current location"""
        marker = self.get_current_level_marker(player_rect)
        if marker:
            status = " (Completed)" if marker.completed else " (Press ENTER)"
            return marker.level_name + status
        
        # Check tile type
        for tile in self.tiles:
            if player_rect.colliderect(tile.rect):
                names = {
                    'grass': 'Grasslands',
                    'forest': 'Dense Forest',
                    'mountain': 'Mountains',
                    'water': 'Ocean',
                    'path': 'The Road',
                    'castle': 'Castle',
                    'cave': 'Cave Entrance',
                    'boss': "Cannon's Domain"
                }
                return names.get(tile.tile_type, '')
        
        return ''

```

```python
"""
Side-scroller level system for Chain
"""

import pygame
import random
from settings import *
from sprites import create_tile_sprite
from enemies import create_enemy
from items import create_item, ItemManager


class Tile(pygame.sprite.Sprite):
    """A platform/ground tile"""
    
    # Actual tile size in pixels (16 base * 2 scale)
    SIZE = 16 * PIXEL_SCALE
    
    def __init__(self, x, y, tile_type='grass', variant=0):
        super().__init__()
        self.tile_type = tile_type
        self.image = create_tile_sprite(tile_type, variant)
        self.rect = self.image.get_rect(topleft=(x, y))


class Level:
    """A side-scrolling level"""
    
    def __init__(self, level_id, level_type=LEVEL_FOREST):
        self.level_id = level_id
        self.level_type = level_type
        
        self.tiles = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()
        self.item_manager = ItemManager()
        
        # Level dimensions
        self.width = 0
        self.height = 0
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Level state
        self.completed = False
        self.exit_rect = None
        
        # Player start position
        self.start_x = 100
        self.start_y = 400
        
        # Level name
        self.name = self.get_level_name()
        
        # Generate level
        self.generate()
    
    def get_level_name(self):
        """Get display name for level"""
        names = {
            'castle': 'Castle Entrance',
            'cave': 'Dark Cave',
            'fortress': "Cannon's Domain",
            'boss': "Cannon's Throne"
        }
        return names.get(self.level_id, 'Unknown Area')
    
    def generate(self):
        """Generate level based on type"""
        if self.level_id == 'castle':
            self.generate_castle_level()
        elif self.level_id == 'cave':
            self.generate_cave_level()
        elif self.level_id == 'boss':
            self.generate_boss_level()
        else:
            self.generate_forest_level()
    
    def generate_forest_level(self):
        """Generate a forest-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        # Level size
        self.width = 3000
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'grass', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'dirt', x // ts))
        
        # Platforms
        platforms = [
            (200, ground_y - ts * 3, 3),
            (500, ground_y - ts * 2, 4),
            (800, ground_y - ts * 4, 2),
            (1000, ground_y - ts * 3, 5),
            (1400, ground_y - ts * 2, 3),
            (1700, ground_y - ts * 4, 4),
            (2000, ground_y - ts * 3, 3),
            (2300, ground_y - ts * 2, 5),
        ]
        
        for px, py, length in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, 'grass'))
        
        # Enemies
        self.enemies.add(create_enemy('slime', 400, ground_y - ts))
        self.enemies.add(create_enemy('slime', 900, ground_y - ts))
        self.enemies.add(create_enemy('bat', 600, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 1200, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1500, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2000, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(550, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(850, ground_y - ts * 5)
        self.item_manager.spawn_coin(1050, ground_y - ts * 4)
        self.item_manager.spawn_coin(1100, ground_y - ts * 4)
        self.item_manager.spawn_food(1750, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_heart_container(2350, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2, 
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_castle_level(self):
        """Generate castle-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 2500
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Castle platforms and structure
        platforms = [
            (150, ground_y - ts * 2, 4, 'brick'),
            (450, ground_y - ts * 4, 3, 'brick'),
            (700, ground_y - ts * 3, 5, 'brick'),
            (1000, ground_y - ts * 5, 3, 'stone'),
            (1250, ground_y - ts * 3, 4, 'brick'),
            (1550, ground_y - ts * 4, 3, 'brick'),
            (1800, ground_y - ts * 2, 6, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # Enemies - more knights in castle
        self.enemies.add(create_enemy('knight', 300, ground_y - ts))
        self.enemies.add(create_enemy('bat', 550, ground_y - ts * 5))
        self.enemies.add(create_enemy('knight', 800, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1100, ground_y - ts * 6))
        self.enemies.add(create_enemy('knight', 1350, ground_y - ts))
        self.enemies.add(create_enemy('knight', 1900, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(200, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(500, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(750, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_coin(1050, ground_y - ts * 6)
        self.item_manager.spawn_food(1600, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_magic_bottle(2000, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_cave_level(self):
        """Generate cave-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 2800
        self.height = 700
        
        # Cave floor and ceiling
        ground_y = self.height - ts * 2
        
        for x in range(0, self.width, ts):
            # Floor
            self.tiles.add(Tile(x, ground_y, 'stone', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
            # Ceiling
            self.tiles.add(Tile(x, 0, 'stone', x // ts))
            self.tiles.add(Tile(x, ts, 'stone', x // ts))
        
        # Cave platforms (more varied heights)
        platforms = [
            (200, ground_y - ts * 2, 3, 'stone'),
            (400, ground_y - ts * 4, 2, 'stone'),
            (550, ground_y - ts * 3, 4, 'stone'),
            (800, ground_y - ts * 5, 2, 'stone'),
            (950, ground_y - ts * 2, 3, 'stone'),
            (1150, ground_y - ts * 4, 3, 'stone'),
            (1400, ground_y - ts * 3, 2, 'stone'),
            (1550, ground_y - ts * 5, 4, 'stone'),
            (1850, ground_y - ts * 2, 3, 'stone'),
            (2050, ground_y - ts * 4, 2, 'stone'),
            (2250, ground_y - ts * 3, 5, 'stone'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # Lots of bats in cave
        self.enemies.add(create_enemy('bat', 300, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 500, ground_y - ts))
        self.enemies.add(create_enemy('bat', 700, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 900, ground_y - ts * 3))
        self.enemies.add(create_enemy('slime', 1100, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1300, ground_y - ts * 4))
        self.enemies.add(create_enemy('knight', 1600, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1800, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 2000, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2300, ground_y - ts))
        
        # Items - magic vials common in cave (magical place)
        self.item_manager.spawn_magic_vial(250, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(600, ground_y - ts * 4)
        self.item_manager.spawn_food(850, ground_y - ts * 6)
        self.item_manager.spawn_magic_vial(1000, ground_y - ts * 3, potion=True)
        self.item_manager.spawn_food(1200, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(1450, ground_y - ts * 4)
        self.item_manager.spawn_magic_bottle(1650, ground_y - ts * 6)
        self.item_manager.spawn_food(1900, ground_y - ts * 3, feast=True)
        self.item_manager.spawn_heart_container(2100, ground_y - ts * 5)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_boss_level(self):
        """Generate boss arena"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 1000
        self.height = 600
        
        # Arena floor
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Arena walls
        for y in range(0, ground_y, ts):
            self.tiles.add(Tile(0, y, 'stone'))
            self.tiles.add(Tile(self.width - ts, y, 'stone'))
        
        # Some platforms for dodging
        platforms = [
            (200, ground_y - ts * 3, 2, 'brick'),
            (450, ground_y - ts * 4, 3, 'brick'),
            (750, ground_y - ts * 3, 2, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # THE BOSS - Cannon!
        self.enemies.add(create_enemy('cannon', 700, ground_y - ts * 2))
        
        # Items for the fight
        self.item_manager.spawn_food(100, ground_y - ts * 4, feast=True)
        self.item_manager.spawn_magic_vial(250, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_food(500, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(800, ground_y - ts * 4, potion=True)
        
        # No exit - must defeat boss
        self.exit_rect = None
        
        self.start_x = 150
        self.start_y = ground_y - ts
    
    def get_tiles(self):
        """Get all tiles for collision"""
        return self.tiles.sprites()
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center on player horizontally
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth follow
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.05
        
        # Clamp to level bounds
        self.camera_x = max(0, min(self.camera_x, self.width - SCREEN_WIDTH))
        self.camera_y = max(0, min(self.camera_y, self.height - SCREEN_HEIGHT))
    
    def update(self, player):
        """Update level state"""
        self.update_camera(player)
        
        # Update enemies
        tiles = self.get_tiles()
        for enemy in self.enemies:
            enemy.update(player, tiles)
        
        # Update items
        self.item_manager.update()
        
        # Check if boss is defeated
        if self.level_id == 'boss' and len(self.enemies) == 0:
            self.completed = True
        
        # Check if player reached exit
        if self.exit_rect and player.rect.colliderect(self.exit_rect):
            self.completed = True
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def draw(self, surface):
        """Draw the level"""
        camera_offset = self.get_camera_offset()
        
        # Draw background
        self.draw_background(surface)
        
        # Draw tiles
        for tile in self.tiles:
            draw_x = tile.rect.x - camera_offset[0]
            draw_y = tile.rect.y - camera_offset[1]
            
            # Only draw visible tiles
            if (-TILE_SIZE * PIXEL_SCALE < draw_x < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                -TILE_SIZE * PIXEL_SCALE < draw_y < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                surface.blit(tile.image, (draw_x, draw_y))
        
        # Draw exit
        if self.exit_rect:
            exit_x = self.exit_rect.x - camera_offset[0]
            exit_y = self.exit_rect.y - camera_offset[1]
            pygame.draw.rect(surface, YELLOW, (exit_x, exit_y, 
                           self.exit_rect.width, self.exit_rect.height), 2)
            # Draw arrow
            pygame.draw.polygon(surface, YELLOW, [
                (exit_x + 16, exit_y + 10),
                (exit_x + 26, exit_y + 25),
                (exit_x + 6, exit_y + 25)
            ])
        
        # Draw items
        self.item_manager.draw(surface, camera_offset)
        
        # Draw enemies
        for enemy in self.enemies:
            enemy.draw(surface, camera_offset)
    
    def draw_background(self, surface):
        """Draw level background"""
        if self.level_type == LEVEL_CAVE:
            surface.fill(DARK_BROWN)
            # Cave atmosphere
            for i in range(20):
                x = (i * 157 - int(self.camera_x * 0.2)) % SCREEN_WIDTH
                y = (i * 89) % SCREEN_HEIGHT
                pygame.draw.circle(surface, BROWN, (x, y), 30)
        elif self.level_type == LEVEL_CASTLE:
            surface.fill(NAVY)
            # Castle interior
            for i in range(10):
                x = (i * 200 - int(self.camera_x * 0.1)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_BLUE, (x, 0, 80, SCREEN_HEIGHT))
        elif self.level_type == LEVEL_BOSS:
            surface.fill(DARK_RED)
            # Ominous atmosphere
            for i in range(5):
                x = SCREEN_WIDTH // 2 + (i - 2) * 150
                pygame.draw.rect(surface, RED, (x, 0, 20, SCREEN_HEIGHT), 1)
        else:
            # Forest background
            surface.fill(SKY_BLUE)
            # Clouds
            for i in range(8):
                x = (i * 200 - int(self.camera_x * 0.3)) % (SCREEN_WIDTH + 200)
                pygame.draw.ellipse(surface, WHITE, (x, 50 + i * 20, 100, 40))
            # Distant trees
            for i in range(15):
                x = (i * 150 - int(self.camera_x * 0.5)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_GREEN, (x, 300, 40, 200))
                pygame.draw.polygon(surface, GREEN, [
                    (x - 20, 300), (x + 20, 200), (x + 60, 300)
                ])

```

```python
"""
Side-scroller level system for Chain
"""

import pygame
import random
from settings import *
from sprites import create_tile_sprite
from enemies import create_enemy
from items import create_item, ItemManager


class Tile(pygame.sprite.Sprite):
    """A platform/ground tile"""
    
    # Actual tile size in pixels (16 base * 2 scale)
    SIZE = 16 * PIXEL_SCALE
    
    def __init__(self, x, y, tile_type='grass', variant=0):
        super().__init__()
        self.tile_type = tile_type
        self.image = create_tile_sprite(tile_type, variant)
        self.rect = self.image.get_rect(topleft=(x, y))


class Level:
    """A side-scrolling level"""
    
    def __init__(self, level_id, level_type=LEVEL_FOREST):
        self.level_id = level_id
        self.level_type = level_type
        
        self.tiles = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()
        self.item_manager = ItemManager()
        
        # Level dimensions
        self.width = 0
        self.height = 0
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Level state
        self.completed = False
        self.exit_rect = None
        
        # Player start position
        self.start_x = 100
        self.start_y = 400
        
        # Level name
        self.name = self.get_level_name()
        
        # Generate level
        self.generate()
    
    def get_level_name(self):
        """Get display name for level"""
        names = {
            'castle': 'Castle Entrance',
            'cave': 'Dark Cave',
            'fortress': "Cannon's Domain",
            'boss': "Cannon's Throne"
        }
        return names.get(self.level_id, 'Unknown Area')
    
    def generate(self):
        """Generate level based on type"""
        if self.level_id == 'castle':
            self.generate_castle_level()
        elif self.level_id == 'cave':
            self.generate_cave_level()
        elif self.level_id == 'fortress':
            self.generate_fortress_level()
        elif self.level_id == 'boss':
            self.generate_boss_level()
        else:
            self.generate_forest_level()
    
    def generate_forest_level(self):
        """Generate a forest-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        # Level size
        self.width = 3000
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'grass', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'dirt', x // ts))
        
        # Platforms
        platforms = [
            (200, ground_y - ts * 3, 3),
            (500, ground_y - ts * 2, 4),
            (800, ground_y - ts * 4, 2),
            (1000, ground_y - ts * 3, 5),
            (1400, ground_y - ts * 2, 3),
            (1700, ground_y - ts * 4, 4),
            (2000, ground_y - ts * 3, 3),
            (2300, ground_y - ts * 2, 5),
        ]
        
        for px, py, length in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, 'grass'))
        
        # Enemies
        self.enemies.add(create_enemy('slime', 400, ground_y - ts))
        self.enemies.add(create_enemy('slime', 900, ground_y - ts))
        self.enemies.add(create_enemy('bat', 600, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 1200, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1500, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2000, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(550, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(850, ground_y - ts * 5)
        self.item_manager.spawn_coin(1050, ground_y - ts * 4)
        self.item_manager.spawn_coin(1100, ground_y - ts * 4)
        self.item_manager.spawn_food(1750, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_heart_container(2350, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2, 
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_castle_level(self):
        """Generate castle-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 2500
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Castle platforms and structure
        platforms = [
            (150, ground_y - ts * 2, 4, 'brick'),
            (450, ground_y - ts * 4, 3, 'brick'),
            (700, ground_y - ts * 3, 5, 'brick'),
            (1000, ground_y - ts * 5, 3, 'stone'),
            (1250, ground_y - ts * 3, 4, 'brick'),
            (1550, ground_y - ts * 4, 3, 'brick'),
            (1800, ground_y - ts * 2, 6, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # Enemies - more knights in castle
        self.enemies.add(create_enemy('knight', 300, ground_y - ts))
        self.enemies.add(create_enemy('bat', 550, ground_y - ts * 5))
        self.enemies.add(create_enemy('knight', 800, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1100, ground_y - ts * 6))
        self.enemies.add(create_enemy('knight', 1350, ground_y - ts))
        self.enemies.add(create_enemy('knight', 1900, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(200, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(500, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(750, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_coin(1050, ground_y - ts * 6)
        self.item_manager.spawn_food(1600, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_magic_bottle(2000, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_cave_level(self):
        """Generate cave-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 2800
        self.height = 700
        
        # Cave floor and ceiling
        ground_y = self.height - ts * 2
        
        for x in range(0, self.width, ts):
            # Floor
            self.tiles.add(Tile(x, ground_y, 'stone', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
            # Ceiling
            self.tiles.add(Tile(x, 0, 'stone', x // ts))
            self.tiles.add(Tile(x, ts, 'stone', x // ts))
        
        # Cave platforms (more varied heights)
        platforms = [
            (200, ground_y - ts * 2, 3, 'stone'),
            (400, ground_y - ts * 4, 2, 'stone'),
            (550, ground_y - ts * 3, 4, 'stone'),
            (800, ground_y - ts * 5, 2, 'stone'),
            (950, ground_y - ts * 2, 3, 'stone'),
            (1150, ground_y - ts * 4, 3, 'stone'),
            (1400, ground_y - ts * 3, 2, 'stone'),
            (1550, ground_y - ts * 5, 4, 'stone'),
            (1850, ground_y - ts * 2, 3, 'stone'),
            (2050, ground_y - ts * 4, 2, 'stone'),
            (2250, ground_y - ts * 3, 5, 'stone'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # Lots of bats in cave
        self.enemies.add(create_enemy('bat', 300, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 500, ground_y - ts))
        self.enemies.add(create_enemy('bat', 700, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 900, ground_y - ts * 3))
        self.enemies.add(create_enemy('slime', 1100, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1300, ground_y - ts * 4))
        self.enemies.add(create_enemy('knight', 1600, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1800, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 2000, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2300, ground_y - ts))
        
        # Items - magic vials common in cave (magical place)
        self.item_manager.spawn_magic_vial(250, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(600, ground_y - ts * 4)
        self.item_manager.spawn_food(850, ground_y - ts * 6)
        self.item_manager.spawn_magic_vial(1000, ground_y - ts * 3, potion=True)
        self.item_manager.spawn_food(1200, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(1450, ground_y - ts * 4)
        self.item_manager.spawn_magic_bottle(1650, ground_y - ts * 6)
        self.item_manager.spawn_food(1900, ground_y - ts * 3, feast=True)
        self.item_manager.spawn_heart_container(2100, ground_y - ts * 5)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_boss_level(self):
        """Generate boss arena"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 1000
        self.height = 600
        
        # Arena floor
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Arena walls
        for y in range(0, ground_y, ts):
            self.tiles.add(Tile(0, y, 'stone'))
            self.tiles.add(Tile(self.width - ts, y, 'stone'))
        
        # Some platforms for dodging
        platforms = [
            (200, ground_y - ts * 3, 2, 'brick'),
            (450, ground_y - ts * 4, 3, 'brick'),
            (750, ground_y - ts * 3, 2, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # THE BOSS - Cannon!
        self.enemies.add(create_enemy('cannon', 700, ground_y - ts * 2))
        
        # Items for the fight
        self.item_manager.spawn_food(100, ground_y - ts * 4, feast=True)
        self.item_manager.spawn_magic_vial(250, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_food(500, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(800, ground_y - ts * 4, potion=True)
        
        # No exit - must defeat boss
        self.exit_rect = None
        
        self.start_x = 150
        self.start_y = ground_y - ts
    
    def get_tiles(self):
        """Get all tiles for collision"""
        return self.tiles.sprites()
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center on player horizontally
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth follow
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.05
        
        # Clamp to level bounds
        self.camera_x = max(0, min(self.camera_x, self.width - SCREEN_WIDTH))
        self.camera_y = max(0, min(self.camera_y, self.height - SCREEN_HEIGHT))
    
    def update(self, player):
        """Update level state"""
        self.update_camera(player)
        
        # Update enemies
        tiles = self.get_tiles()
        for enemy in self.enemies:
            enemy.update(player, tiles)
        
        # Update items
        self.item_manager.update()
        
        # Check if boss is defeated
        if self.level_id == 'boss' and len(self.enemies) == 0:
            self.completed = True
        
        # Check if player reached exit
        if self.exit_rect and player.rect.colliderect(self.exit_rect):
            self.completed = True
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def draw(self, surface):
        """Draw the level"""
        camera_offset = self.get_camera_offset()
        
        # Draw background
        self.draw_background(surface)
        
        # Draw tiles
        for tile in self.tiles:
            draw_x = tile.rect.x - camera_offset[0]
            draw_y = tile.rect.y - camera_offset[1]
            
            # Only draw visible tiles
            if (-TILE_SIZE * PIXEL_SCALE < draw_x < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                -TILE_SIZE * PIXEL_SCALE < draw_y < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                surface.blit(tile.image, (draw_x, draw_y))
        
        # Draw exit
        if self.exit_rect:
            exit_x = self.exit_rect.x - camera_offset[0]
            exit_y = self.exit_rect.y - camera_offset[1]
            pygame.draw.rect(surface, YELLOW, (exit_x, exit_y, 
                           self.exit_rect.width, self.exit_rect.height), 2)
            # Draw arrow
            pygame.draw.polygon(surface, YELLOW, [
                (exit_x + 16, exit_y + 10),
                (exit_x + 26, exit_y + 25),
                (exit_x + 6, exit_y + 25)
            ])
        
        # Draw items
        self.item_manager.draw(surface, camera_offset)
        
        # Draw enemies
        for enemy in self.enemies:
            enemy.draw(surface, camera_offset)
    
    def draw_background(self, surface):
        """Draw level background"""
        if self.level_type == LEVEL_CAVE:
            surface.fill(DARK_BROWN)
            # Cave atmosphere
            for i in range(20):
                x = (i * 157 - int(self.camera_x * 0.2)) % SCREEN_WIDTH
                y = (i * 89) % SCREEN_HEIGHT
                pygame.draw.circle(surface, BROWN, (x, y), 30)
        elif self.level_type == LEVEL_CASTLE:
            surface.fill(NAVY)
            # Castle interior
            for i in range(10):
                x = (i * 200 - int(self.camera_x * 0.1)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_BLUE, (x, 0, 80, SCREEN_HEIGHT))
        elif self.level_type == LEVEL_BOSS:
            surface.fill(DARK_RED)
            # Ominous atmosphere
            for i in range(5):
                x = SCREEN_WIDTH // 2 + (i - 2) * 150
                pygame.draw.rect(surface, RED, (x, 0, 20, SCREEN_HEIGHT), 1)
        else:
            # Forest background
            surface.fill(SKY_BLUE)
            # Clouds
            for i in range(8):
                x = (i * 200 - int(self.camera_x * 0.3)) % (SCREEN_WIDTH + 200)
                pygame.draw.ellipse(surface, WHITE, (x, 50 + i * 20, 100, 40))
            # Distant trees
            for i in range(15):
                x = (i * 150 - int(self.camera_x * 0.5)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_GREEN, (x, 300, 40, 200))
                pygame.draw.polygon(surface, GREEN, [
                    (x - 20, 300), (x + 20, 200), (x + 60, 300)
                ])

```

```python
"""
Side-scroller level system for Chain
"""

import pygame
import random
from settings import *
from sprites import create_tile_sprite
from enemies import create_enemy
from items import create_item, ItemManager


class Tile(pygame.sprite.Sprite):
    """A platform/ground tile"""
    
    # Actual tile size in pixels (16 base * 2 scale)
    SIZE = 16 * PIXEL_SCALE
    
    def __init__(self, x, y, tile_type='grass', variant=0):
        super().__init__()
        self.tile_type = tile_type
        self.image = create_tile_sprite(tile_type, variant)
        self.rect = self.image.get_rect(topleft=(x, y))


class Level:
    """A side-scrolling level"""
    
    def __init__(self, level_id, level_type=LEVEL_FOREST):
        self.level_id = level_id
        self.level_type = level_type
        
        self.tiles = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()
        self.item_manager = ItemManager()
        
        # Level dimensions
        self.width = 0
        self.height = 0
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Level state
        self.completed = False
        self.exit_rect = None
        
        # Player start position
        self.start_x = 100
        self.start_y = 400
        
        # Level name
        self.name = self.get_level_name()
        
        # Generate level
        self.generate()
    
    def get_level_name(self):
        """Get display name for level"""
        names = {
            'castle': 'Castle Entrance',
            'cave': 'Dark Cave',
            'fortress': "Cannon's Domain",
            'boss': "Cannon's Throne"
        }
        return names.get(self.level_id, 'Unknown Area')
    
    def generate(self):
        """Generate level based on type"""
        if self.level_id == 'castle':
            self.generate_castle_level()
        elif self.level_id == 'cave':
            self.generate_cave_level()
        elif self.level_id == 'fortress':
            self.generate_fortress_level()
        elif self.level_id == 'boss':
            self.generate_boss_level()
        else:
            self.generate_forest_level()
    
    def generate_forest_level(self):
        """Generate a forest-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        # Level size
        self.width = 3000
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'grass', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'dirt', x // ts))
        
        # Platforms
        platforms = [
            (200, ground_y - ts * 3, 3),
            (500, ground_y - ts * 2, 4),
            (800, ground_y - ts * 4, 2),
            (1000, ground_y - ts * 3, 5),
            (1400, ground_y - ts * 2, 3),
            (1700, ground_y - ts * 4, 4),
            (2000, ground_y - ts * 3, 3),
            (2300, ground_y - ts * 2, 5),
        ]
        
        for px, py, length in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, 'grass'))
        
        # Enemies
        self.enemies.add(create_enemy('slime', 400, ground_y - ts))
        self.enemies.add(create_enemy('slime', 900, ground_y - ts))
        self.enemies.add(create_enemy('bat', 600, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 1200, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1500, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2000, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(550, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(850, ground_y - ts * 5)
        self.item_manager.spawn_coin(1050, ground_y - ts * 4)
        self.item_manager.spawn_coin(1100, ground_y - ts * 4)
        self.item_manager.spawn_food(1750, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_heart_container(2350, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2, 
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_castle_level(self):
        """Generate castle-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 2500
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Castle platforms and structure
        platforms = [
            (150, ground_y - ts * 2, 4, 'brick'),
            (450, ground_y - ts * 4, 3, 'brick'),
            (700, ground_y - ts * 3, 5, 'brick'),
            (1000, ground_y - ts * 5, 3, 'stone'),
            (1250, ground_y - ts * 3, 4, 'brick'),
            (1550, ground_y - ts * 4, 3, 'brick'),
            (1800, ground_y - ts * 2, 6, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # Enemies - more knights in castle
        self.enemies.add(create_enemy('knight', 300, ground_y - ts))
        self.enemies.add(create_enemy('bat', 550, ground_y - ts * 5))
        self.enemies.add(create_enemy('knight', 800, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1100, ground_y - ts * 6))
        self.enemies.add(create_enemy('knight', 1350, ground_y - ts))
        self.enemies.add(create_enemy('knight', 1900, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(200, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(500, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(750, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_coin(1050, ground_y - ts * 6)
        self.item_manager.spawn_food(1600, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_magic_bottle(2000, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_cave_level(self):
        """Generate cave-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 2800
        self.height = 700
        
        # Cave floor and ceiling
        ground_y = self.height - ts * 2
        
        for x in range(0, self.width, ts):
            # Floor
            self.tiles.add(Tile(x, ground_y, 'stone', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
            # Ceiling
            self.tiles.add(Tile(x, 0, 'stone', x // ts))
            self.tiles.add(Tile(x, ts, 'stone', x // ts))
        
        # Cave platforms (more varied heights)
        platforms = [
            (200, ground_y - ts * 2, 3, 'stone'),
            (400, ground_y - ts * 4, 2, 'stone'),
            (550, ground_y - ts * 3, 4, 'stone'),
            (800, ground_y - ts * 5, 2, 'stone'),
            (950, ground_y - ts * 2, 3, 'stone'),
            (1150, ground_y - ts * 4, 3, 'stone'),
            (1400, ground_y - ts * 3, 2, 'stone'),
            (1550, ground_y - ts * 5, 4, 'stone'),
            (1850, ground_y - ts * 2, 3, 'stone'),
            (2050, ground_y - ts * 4, 2, 'stone'),
            (2250, ground_y - ts * 3, 5, 'stone'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # Lots of bats in cave
        self.enemies.add(create_enemy('bat', 300, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 500, ground_y - ts))
        self.enemies.add(create_enemy('bat', 700, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 900, ground_y - ts * 3))
        self.enemies.add(create_enemy('slime', 1100, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1300, ground_y - ts * 4))
        self.enemies.add(create_enemy('knight', 1600, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1800, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 2000, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2300, ground_y - ts))
        
        # Items - magic vials common in cave (magical place)
        self.item_manager.spawn_magic_vial(250, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(600, ground_y - ts * 4)
        self.item_manager.spawn_food(850, ground_y - ts * 6)
        self.item_manager.spawn_magic_vial(1000, ground_y - ts * 3, potion=True)
        self.item_manager.spawn_food(1200, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(1450, ground_y - ts * 4)
        self.item_manager.spawn_magic_bottle(1650, ground_y - ts * 6)
        self.item_manager.spawn_food(1900, ground_y - ts * 3, feast=True)
        self.item_manager.spawn_heart_container(2100, ground_y - ts * 5)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_fortress_level(self):
        """Generate Cannon's Domain - a difficult dungeon"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        # Longer, more challenging level
        self.width = 4000
        self.height = 700
        
        # Fortress floor and walls
        ground_y = self.height - ts * 2
        
        # Ground with gaps (hazards!)
        gap_positions = [600, 1200, 1800, 2400, 3000, 3400]
        for x in range(0, self.width, ts):
            # Check if this is a gap
            is_gap = any(gap <= x < gap + ts * 3 for gap in gap_positions)
            if not is_gap:
                self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
                self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Ceiling
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, 0, 'stone', x // ts))
            self.tiles.add(Tile(x, ts, 'stone', x // ts))
        
        # Complex platform layout - requires precise jumping
        platforms = [
            # Section 1: Introduction
            (150, ground_y - ts * 2, 3, 'brick'),
            (350, ground_y - ts * 4, 2, 'brick'),
            # Over first gap
            (550, ground_y - ts * 3, 2, 'brick'),
            (700, ground_y - ts * 2, 2, 'brick'),
            # Section 2: Vertical challenge
            (850, ground_y - ts * 3, 3, 'brick'),
            (950, ground_y - ts * 5, 2, 'stone'),
            (1050, ground_y - ts * 7, 2, 'stone'),
            # Over second gap
            (1150, ground_y - ts * 4, 2, 'brick'),
            (1300, ground_y - ts * 2, 2, 'brick'),
            # Section 3: Narrow platforms
            (1450, ground_y - ts * 3, 1, 'brick'),
            (1550, ground_y - ts * 4, 1, 'brick'),
            (1650, ground_y - ts * 5, 1, 'brick'),
            (1750, ground_y - ts * 4, 1, 'brick'),
            # Over third gap
            (1850, ground_y - ts * 3, 2, 'brick'),
            (2000, ground_y - ts * 2, 3, 'brick'),
            # Section 4: Knight gauntlet
            (2200, ground_y - ts * 3, 4, 'brick'),
            (2450, ground_y - ts * 2, 3, 'brick'),
            # Over fourth gap
            (2350, ground_y - ts * 5, 2, 'stone'),
            (2550, ground_y - ts * 3, 2, 'brick'),
            # Section 5: Final stretch
            (2700, ground_y - ts * 4, 3, 'brick'),
            (2900, ground_y - ts * 2, 2, 'brick'),
            # Over fifth gap
            (2950, ground_y - ts * 4, 2, 'brick'),
            (3100, ground_y - ts * 3, 3, 'brick'),
            # Section 6: Before exit
            (3300, ground_y - ts * 2, 2, 'brick'),
            # Over sixth gap
            (3350, ground_y - ts * 4, 2, 'brick'),
            (3500, ground_y - ts * 3, 3, 'brick'),
            (3700, ground_y - ts * 2, 5, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # MANY enemies - this is the hard level!
        # Section 1
        self.enemies.add(create_enemy('knight', 200, ground_y - ts))
        self.enemies.add(create_enemy('bat', 400, ground_y - ts * 5))
        self.enemies.add(create_enemy('slime', 500, ground_y - ts))
        
        # Section 2 - vertical challenge with bats
        self.enemies.add(create_enemy('bat', 900, ground_y - ts * 4))
        self.enemies.add(create_enemy('bat', 1000, ground_y - ts * 6))
        self.enemies.add(create_enemy('knight', 1100, ground_y - ts))
        
        # Section 3 - narrow platforms with bats harassing
        self.enemies.add(create_enemy('bat', 1500, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 1600, ground_y - ts * 6))
        self.enemies.add(create_enemy('bat', 1700, ground_y - ts * 5))
        self.enemies.add(create_enemy('knight', 1900, ground_y - ts))
        
        # Section 4 - knight gauntlet!
        self.enemies.add(create_enemy('knight', 2250, ground_y - ts))
        self.enemies.add(create_enemy('knight', 2400, ground_y - ts))
        self.enemies.add(create_enemy('bat', 2300, ground_y - ts * 4))
        self.enemies.add(create_enemy('knight', 2600, ground_y - ts))
        
        # Section 5 - mixed assault
        self.enemies.add(create_enemy('bat', 2800, ground_y - ts * 5))
        self.enemies.add(create_enemy('knight', 2950, ground_y - ts))
        self.enemies.add(create_enemy('bat', 3050, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 3150, ground_y - ts))
        
        # Section 6 - final defense
        self.enemies.add(create_enemy('knight', 3400, ground_y - ts))
        self.enemies.add(create_enemy('bat', 3500, ground_y - ts * 4))
        self.enemies.add(create_enemy('knight', 3600, ground_y - ts))
        self.enemies.add(create_enemy('knight', 3750, ground_y - ts))
        
        # Items - strategically placed to help but require skill to get
        self.item_manager.spawn_food(180, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(380, ground_y - ts * 5)
        self.item_manager.spawn_food(720, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(1000, ground_y - ts * 6, potion=True)
        self.item_manager.spawn_food(1350, ground_y - ts * 3, feast=True)
        self.item_manager.spawn_magic_vial(1600, ground_y - ts * 5)
        self.item_manager.spawn_food(2050, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(2280, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_heart_container(2400, ground_y - ts * 6)
        self.item_manager.spawn_food(2750, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_magic_vial(3050, ground_y - ts * 4)
        self.item_manager.spawn_magic_bottle(3150, ground_y - ts * 4)
        self.item_manager.spawn_food(3550, ground_y - ts * 4, feast=True)
        self.item_manager.spawn_magic_vial(3720, ground_y - ts * 3, potion=True)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_boss_level(self):
        """Generate boss arena"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 1000
        self.height = 600
        
        # Arena floor
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Arena walls
        for y in range(0, ground_y, ts):
            self.tiles.add(Tile(0, y, 'stone'))
            self.tiles.add(Tile(self.width - ts, y, 'stone'))
        
        # Some platforms for dodging
        platforms = [
            (200, ground_y - ts * 3, 2, 'brick'),
            (450, ground_y - ts * 4, 3, 'brick'),
            (750, ground_y - ts * 3, 2, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # THE BOSS - Cannon!
        self.enemies.add(create_enemy('cannon', 700, ground_y - ts * 2))
        
        # Items for the fight
        self.item_manager.spawn_food(100, ground_y - ts * 4, feast=True)
        self.item_manager.spawn_magic_vial(250, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_food(500, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(800, ground_y - ts * 4, potion=True)
        
        # No exit - must defeat boss
        self.exit_rect = None
        
        self.start_x = 150
        self.start_y = ground_y - ts
    
    def get_tiles(self):
        """Get all tiles for collision"""
        return self.tiles.sprites()
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center on player horizontally
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth follow
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.05
        
        # Clamp to level bounds
        self.camera_x = max(0, min(self.camera_x, self.width - SCREEN_WIDTH))
        self.camera_y = max(0, min(self.camera_y, self.height - SCREEN_HEIGHT))
    
    def update(self, player):
        """Update level state"""
        self.update_camera(player)
        
        # Update enemies
        tiles = self.get_tiles()
        for enemy in self.enemies:
            enemy.update(player, tiles)
        
        # Update items
        self.item_manager.update()
        
        # Check if boss is defeated
        if self.level_id == 'boss' and len(self.enemies) == 0:
            self.completed = True
        
        # Check if player reached exit
        if self.exit_rect and player.rect.colliderect(self.exit_rect):
            self.completed = True
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def draw(self, surface):
        """Draw the level"""
        camera_offset = self.get_camera_offset()
        
        # Draw background
        self.draw_background(surface)
        
        # Draw tiles
        for tile in self.tiles:
            draw_x = tile.rect.x - camera_offset[0]
            draw_y = tile.rect.y - camera_offset[1]
            
            # Only draw visible tiles
            if (-TILE_SIZE * PIXEL_SCALE < draw_x < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                -TILE_SIZE * PIXEL_SCALE < draw_y < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                surface.blit(tile.image, (draw_x, draw_y))
        
        # Draw exit
        if self.exit_rect:
            exit_x = self.exit_rect.x - camera_offset[0]
            exit_y = self.exit_rect.y - camera_offset[1]
            pygame.draw.rect(surface, YELLOW, (exit_x, exit_y, 
                           self.exit_rect.width, self.exit_rect.height), 2)
            # Draw arrow
            pygame.draw.polygon(surface, YELLOW, [
                (exit_x + 16, exit_y + 10),
                (exit_x + 26, exit_y + 25),
                (exit_x + 6, exit_y + 25)
            ])
        
        # Draw items
        self.item_manager.draw(surface, camera_offset)
        
        # Draw enemies
        for enemy in self.enemies:
            enemy.draw(surface, camera_offset)
    
    def draw_background(self, surface):
        """Draw level background"""
        if self.level_type == LEVEL_CAVE:
            surface.fill(DARK_BROWN)
            # Cave atmosphere
            for i in range(20):
                x = (i * 157 - int(self.camera_x * 0.2)) % SCREEN_WIDTH
                y = (i * 89) % SCREEN_HEIGHT
                pygame.draw.circle(surface, BROWN, (x, y), 30)
        elif self.level_type == LEVEL_CASTLE:
            surface.fill(NAVY)
            # Castle interior
            for i in range(10):
                x = (i * 200 - int(self.camera_x * 0.1)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_BLUE, (x, 0, 80, SCREEN_HEIGHT))
        elif self.level_type == LEVEL_BOSS:
            surface.fill(DARK_RED)
            # Ominous atmosphere
            for i in range(5):
                x = SCREEN_WIDTH // 2 + (i - 2) * 150
                pygame.draw.rect(surface, RED, (x, 0, 20, SCREEN_HEIGHT), 1)
        else:
            # Forest background
            surface.fill(SKY_BLUE)
            # Clouds
            for i in range(8):
                x = (i * 200 - int(self.camera_x * 0.3)) % (SCREEN_WIDTH + 200)
                pygame.draw.ellipse(surface, WHITE, (x, 50 + i * 20, 100, 40))
            # Distant trees
            for i in range(15):
                x = (i * 150 - int(self.camera_x * 0.5)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_GREEN, (x, 300, 40, 200))
                pygame.draw.polygon(surface, GREEN, [
                    (x - 20, 300), (x + 20, 200), (x + 60, 300)
                ])

```

Now let me update the background drawing to support the fortress level:

```python
"""
Side-scroller level system for Chain
"""

import pygame
import random
from settings import *
from sprites import create_tile_sprite
from enemies import create_enemy
from items import create_item, ItemManager


class Tile(pygame.sprite.Sprite):
    """A platform/ground tile"""
    
    # Actual tile size in pixels (16 base * 2 scale)
    SIZE = 16 * PIXEL_SCALE
    
    def __init__(self, x, y, tile_type='grass', variant=0):
        super().__init__()
        self.tile_type = tile_type
        self.image = create_tile_sprite(tile_type, variant)
        self.rect = self.image.get_rect(topleft=(x, y))


class Level:
    """A side-scrolling level"""
    
    def __init__(self, level_id, level_type=LEVEL_FOREST):
        self.level_id = level_id
        self.level_type = level_type
        
        self.tiles = pygame.sprite.Group()
        self.enemies = pygame.sprite.Group()
        self.item_manager = ItemManager()
        
        # Level dimensions
        self.width = 0
        self.height = 0
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Level state
        self.completed = False
        self.exit_rect = None
        
        # Player start position
        self.start_x = 100
        self.start_y = 400
        
        # Level name
        self.name = self.get_level_name()
        
        # Generate level
        self.generate()
    
    def get_level_name(self):
        """Get display name for level"""
        names = {
            'castle': 'Castle Entrance',
            'cave': 'Dark Cave',
            'fortress': "Cannon's Domain",
            'boss': "Cannon's Throne"
        }
        return names.get(self.level_id, 'Unknown Area')
    
    def generate(self):
        """Generate level based on type"""
        if self.level_id == 'castle':
            self.generate_castle_level()
        elif self.level_id == 'cave':
            self.generate_cave_level()
        elif self.level_id == 'fortress':
            self.generate_fortress_level()
        elif self.level_id == 'boss':
            self.generate_boss_level()
        else:
            self.generate_forest_level()
    
    def generate_forest_level(self):
        """Generate a forest-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        # Level size
        self.width = 3000
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'grass', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'dirt', x // ts))
        
        # Platforms
        platforms = [
            (200, ground_y - ts * 3, 3),
            (500, ground_y - ts * 2, 4),
            (800, ground_y - ts * 4, 2),
            (1000, ground_y - ts * 3, 5),
            (1400, ground_y - ts * 2, 3),
            (1700, ground_y - ts * 4, 4),
            (2000, ground_y - ts * 3, 3),
            (2300, ground_y - ts * 2, 5),
        ]
        
        for px, py, length in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, 'grass'))
        
        # Enemies
        self.enemies.add(create_enemy('slime', 400, ground_y - ts))
        self.enemies.add(create_enemy('slime', 900, ground_y - ts))
        self.enemies.add(create_enemy('bat', 600, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 1200, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1500, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2000, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(550, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(850, ground_y - ts * 5)
        self.item_manager.spawn_coin(1050, ground_y - ts * 4)
        self.item_manager.spawn_coin(1100, ground_y - ts * 4)
        self.item_manager.spawn_food(1750, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_heart_container(2350, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2, 
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_castle_level(self):
        """Generate castle-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 2500
        self.height = 600
        
        # Ground
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Castle platforms and structure
        platforms = [
            (150, ground_y - ts * 2, 4, 'brick'),
            (450, ground_y - ts * 4, 3, 'brick'),
            (700, ground_y - ts * 3, 5, 'brick'),
            (1000, ground_y - ts * 5, 3, 'stone'),
            (1250, ground_y - ts * 3, 4, 'brick'),
            (1550, ground_y - ts * 4, 3, 'brick'),
            (1800, ground_y - ts * 2, 6, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # Enemies - more knights in castle
        self.enemies.add(create_enemy('knight', 300, ground_y - ts))
        self.enemies.add(create_enemy('bat', 550, ground_y - ts * 5))
        self.enemies.add(create_enemy('knight', 800, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1100, ground_y - ts * 6))
        self.enemies.add(create_enemy('knight', 1350, ground_y - ts))
        self.enemies.add(create_enemy('knight', 1900, ground_y - ts))
        
        # Items
        self.item_manager.spawn_food(200, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(500, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(750, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_coin(1050, ground_y - ts * 6)
        self.item_manager.spawn_food(1600, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_magic_bottle(2000, ground_y - ts * 3)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_cave_level(self):
        """Generate cave-themed level"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 2800
        self.height = 700
        
        # Cave floor and ceiling
        ground_y = self.height - ts * 2
        
        for x in range(0, self.width, ts):
            # Floor
            self.tiles.add(Tile(x, ground_y, 'stone', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
            # Ceiling
            self.tiles.add(Tile(x, 0, 'stone', x // ts))
            self.tiles.add(Tile(x, ts, 'stone', x // ts))
        
        # Cave platforms (more varied heights)
        platforms = [
            (200, ground_y - ts * 2, 3, 'stone'),
            (400, ground_y - ts * 4, 2, 'stone'),
            (550, ground_y - ts * 3, 4, 'stone'),
            (800, ground_y - ts * 5, 2, 'stone'),
            (950, ground_y - ts * 2, 3, 'stone'),
            (1150, ground_y - ts * 4, 3, 'stone'),
            (1400, ground_y - ts * 3, 2, 'stone'),
            (1550, ground_y - ts * 5, 4, 'stone'),
            (1850, ground_y - ts * 2, 3, 'stone'),
            (2050, ground_y - ts * 4, 2, 'stone'),
            (2250, ground_y - ts * 3, 5, 'stone'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # Lots of bats in cave
        self.enemies.add(create_enemy('bat', 300, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 500, ground_y - ts))
        self.enemies.add(create_enemy('bat', 700, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 900, ground_y - ts * 3))
        self.enemies.add(create_enemy('slime', 1100, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1300, ground_y - ts * 4))
        self.enemies.add(create_enemy('knight', 1600, ground_y - ts))
        self.enemies.add(create_enemy('bat', 1800, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 2000, ground_y - ts * 3))
        self.enemies.add(create_enemy('knight', 2300, ground_y - ts))
        
        # Items - magic vials common in cave (magical place)
        self.item_manager.spawn_magic_vial(250, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(600, ground_y - ts * 4)
        self.item_manager.spawn_food(850, ground_y - ts * 6)
        self.item_manager.spawn_magic_vial(1000, ground_y - ts * 3, potion=True)
        self.item_manager.spawn_food(1200, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(1450, ground_y - ts * 4)
        self.item_manager.spawn_magic_bottle(1650, ground_y - ts * 6)
        self.item_manager.spawn_food(1900, ground_y - ts * 3, feast=True)
        self.item_manager.spawn_heart_container(2100, ground_y - ts * 5)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_fortress_level(self):
        """Generate Cannon's Domain - a difficult dungeon"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        # Longer, more challenging level
        self.width = 4000
        self.height = 700
        
        # Fortress floor and walls
        ground_y = self.height - ts * 2
        
        # Ground with gaps (hazards!)
        gap_positions = [600, 1200, 1800, 2400, 3000, 3400]
        for x in range(0, self.width, ts):
            # Check if this is a gap
            is_gap = any(gap <= x < gap + ts * 3 for gap in gap_positions)
            if not is_gap:
                self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
                self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Ceiling
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, 0, 'stone', x // ts))
            self.tiles.add(Tile(x, ts, 'stone', x // ts))
        
        # Complex platform layout - requires precise jumping
        platforms = [
            # Section 1: Introduction
            (150, ground_y - ts * 2, 3, 'brick'),
            (350, ground_y - ts * 4, 2, 'brick'),
            # Over first gap
            (550, ground_y - ts * 3, 2, 'brick'),
            (700, ground_y - ts * 2, 2, 'brick'),
            # Section 2: Vertical challenge
            (850, ground_y - ts * 3, 3, 'brick'),
            (950, ground_y - ts * 5, 2, 'stone'),
            (1050, ground_y - ts * 7, 2, 'stone'),
            # Over second gap
            (1150, ground_y - ts * 4, 2, 'brick'),
            (1300, ground_y - ts * 2, 2, 'brick'),
            # Section 3: Narrow platforms
            (1450, ground_y - ts * 3, 1, 'brick'),
            (1550, ground_y - ts * 4, 1, 'brick'),
            (1650, ground_y - ts * 5, 1, 'brick'),
            (1750, ground_y - ts * 4, 1, 'brick'),
            # Over third gap
            (1850, ground_y - ts * 3, 2, 'brick'),
            (2000, ground_y - ts * 2, 3, 'brick'),
            # Section 4: Knight gauntlet
            (2200, ground_y - ts * 3, 4, 'brick'),
            (2450, ground_y - ts * 2, 3, 'brick'),
            # Over fourth gap
            (2350, ground_y - ts * 5, 2, 'stone'),
            (2550, ground_y - ts * 3, 2, 'brick'),
            # Section 5: Final stretch
            (2700, ground_y - ts * 4, 3, 'brick'),
            (2900, ground_y - ts * 2, 2, 'brick'),
            # Over fifth gap
            (2950, ground_y - ts * 4, 2, 'brick'),
            (3100, ground_y - ts * 3, 3, 'brick'),
            # Section 6: Before exit
            (3300, ground_y - ts * 2, 2, 'brick'),
            # Over sixth gap
            (3350, ground_y - ts * 4, 2, 'brick'),
            (3500, ground_y - ts * 3, 3, 'brick'),
            (3700, ground_y - ts * 2, 5, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # MANY enemies - this is the hard level!
        # Section 1
        self.enemies.add(create_enemy('knight', 200, ground_y - ts))
        self.enemies.add(create_enemy('bat', 400, ground_y - ts * 5))
        self.enemies.add(create_enemy('slime', 500, ground_y - ts))
        
        # Section 2 - vertical challenge with bats
        self.enemies.add(create_enemy('bat', 900, ground_y - ts * 4))
        self.enemies.add(create_enemy('bat', 1000, ground_y - ts * 6))
        self.enemies.add(create_enemy('knight', 1100, ground_y - ts))
        
        # Section 3 - narrow platforms with bats harassing
        self.enemies.add(create_enemy('bat', 1500, ground_y - ts * 5))
        self.enemies.add(create_enemy('bat', 1600, ground_y - ts * 6))
        self.enemies.add(create_enemy('bat', 1700, ground_y - ts * 5))
        self.enemies.add(create_enemy('knight', 1900, ground_y - ts))
        
        # Section 4 - knight gauntlet!
        self.enemies.add(create_enemy('knight', 2250, ground_y - ts))
        self.enemies.add(create_enemy('knight', 2400, ground_y - ts))
        self.enemies.add(create_enemy('bat', 2300, ground_y - ts * 4))
        self.enemies.add(create_enemy('knight', 2600, ground_y - ts))
        
        # Section 5 - mixed assault
        self.enemies.add(create_enemy('bat', 2800, ground_y - ts * 5))
        self.enemies.add(create_enemy('knight', 2950, ground_y - ts))
        self.enemies.add(create_enemy('bat', 3050, ground_y - ts * 4))
        self.enemies.add(create_enemy('slime', 3150, ground_y - ts))
        
        # Section 6 - final defense
        self.enemies.add(create_enemy('knight', 3400, ground_y - ts))
        self.enemies.add(create_enemy('bat', 3500, ground_y - ts * 4))
        self.enemies.add(create_enemy('knight', 3600, ground_y - ts))
        self.enemies.add(create_enemy('knight', 3750, ground_y - ts))
        
        # Items - strategically placed to help but require skill to get
        self.item_manager.spawn_food(180, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(380, ground_y - ts * 5)
        self.item_manager.spawn_food(720, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(1000, ground_y - ts * 6, potion=True)
        self.item_manager.spawn_food(1350, ground_y - ts * 3, feast=True)
        self.item_manager.spawn_magic_vial(1600, ground_y - ts * 5)
        self.item_manager.spawn_food(2050, ground_y - ts * 3)
        self.item_manager.spawn_magic_vial(2280, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_heart_container(2400, ground_y - ts * 6)
        self.item_manager.spawn_food(2750, ground_y - ts * 5, feast=True)
        self.item_manager.spawn_magic_vial(3050, ground_y - ts * 4)
        self.item_manager.spawn_magic_bottle(3150, ground_y - ts * 4)
        self.item_manager.spawn_food(3550, ground_y - ts * 4, feast=True)
        self.item_manager.spawn_magic_vial(3720, ground_y - ts * 3, potion=True)
        
        # Exit
        self.exit_rect = pygame.Rect(self.width - 100, ground_y - ts * 2,
                                     ts, ts * 2)
        
        self.start_y = ground_y - ts
    
    def generate_boss_level(self):
        """Generate boss arena"""
        ts = Tile.SIZE  # Actual tile size (32 pixels)
        
        self.width = 1000
        self.height = 600
        
        # Arena floor
        ground_y = self.height - ts * 2
        for x in range(0, self.width, ts):
            self.tiles.add(Tile(x, ground_y, 'brick', x // ts))
            self.tiles.add(Tile(x, ground_y + ts, 'stone', x // ts))
        
        # Arena walls
        for y in range(0, ground_y, ts):
            self.tiles.add(Tile(0, y, 'stone'))
            self.tiles.add(Tile(self.width - ts, y, 'stone'))
        
        # Some platforms for dodging
        platforms = [
            (200, ground_y - ts * 3, 2, 'brick'),
            (450, ground_y - ts * 4, 3, 'brick'),
            (750, ground_y - ts * 3, 2, 'brick'),
        ]
        
        for px, py, length, tile_type in platforms:
            for i in range(length):
                self.tiles.add(Tile(px + i * ts, py, tile_type))
        
        # THE BOSS - Cannon!
        self.enemies.add(create_enemy('cannon', 700, ground_y - ts * 2))
        
        # Items for the fight
        self.item_manager.spawn_food(100, ground_y - ts * 4, feast=True)
        self.item_manager.spawn_magic_vial(250, ground_y - ts * 4, potion=True)
        self.item_manager.spawn_food(500, ground_y - ts * 5)
        self.item_manager.spawn_magic_vial(800, ground_y - ts * 4, potion=True)
        
        # No exit - must defeat boss
        self.exit_rect = None
        
        self.start_x = 150
        self.start_y = ground_y - ts
    
    def get_tiles(self):
        """Get all tiles for collision"""
        return self.tiles.sprites()
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center on player horizontally
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth follow
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.05
        
        # Clamp to level bounds
        self.camera_x = max(0, min(self.camera_x, self.width - SCREEN_WIDTH))
        self.camera_y = max(0, min(self.camera_y, self.height - SCREEN_HEIGHT))
    
    def update(self, player):
        """Update level state"""
        self.update_camera(player)
        
        # Update enemies
        tiles = self.get_tiles()
        for enemy in self.enemies:
            enemy.update(player, tiles)
        
        # Update items
        self.item_manager.update()
        
        # Check if boss is defeated
        if self.level_id == 'boss' and len(self.enemies) == 0:
            self.completed = True
        
        # Check if player reached exit
        if self.exit_rect and player.rect.colliderect(self.exit_rect):
            self.completed = True
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def draw(self, surface):
        """Draw the level"""
        camera_offset = self.get_camera_offset()
        
        # Draw background
        self.draw_background(surface)
        
        # Draw tiles
        for tile in self.tiles:
            draw_x = tile.rect.x - camera_offset[0]
            draw_y = tile.rect.y - camera_offset[1]
            
            # Only draw visible tiles
            if (-TILE_SIZE * PIXEL_SCALE < draw_x < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                -TILE_SIZE * PIXEL_SCALE < draw_y < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                surface.blit(tile.image, (draw_x, draw_y))
        
        # Draw exit
        if self.exit_rect:
            exit_x = self.exit_rect.x - camera_offset[0]
            exit_y = self.exit_rect.y - camera_offset[1]
            pygame.draw.rect(surface, YELLOW, (exit_x, exit_y, 
                           self.exit_rect.width, self.exit_rect.height), 2)
            # Draw arrow
            pygame.draw.polygon(surface, YELLOW, [
                (exit_x + 16, exit_y + 10),
                (exit_x + 26, exit_y + 25),
                (exit_x + 6, exit_y + 25)
            ])
        
        # Draw items
        self.item_manager.draw(surface, camera_offset)
        
        # Draw enemies
        for enemy in self.enemies:
            enemy.draw(surface, camera_offset)
    
    def draw_background(self, surface):
        """Draw level background"""
        if self.level_type == LEVEL_CAVE:
            surface.fill(DARK_BROWN)
            # Cave atmosphere
            for i in range(20):
                x = (i * 157 - int(self.camera_x * 0.2)) % SCREEN_WIDTH
                y = (i * 89) % SCREEN_HEIGHT
                pygame.draw.circle(surface, BROWN, (x, y), 30)
        elif self.level_id == 'fortress':
            # Cannon's Domain - dark and foreboding
            surface.fill(DARK_BLUE)
            # Ominous red glow from below
            for i in range(SCREEN_WIDTH // 40):
                x = i * 40 - int(self.camera_x * 0.1) % 40
                glow_height = 100 + (i % 3) * 30
                pygame.draw.rect(surface, (*DARK_RED[:3], 50), 
                               (x, SCREEN_HEIGHT - glow_height, 35, glow_height))
            # Dark pillars
            for i in range(12):
                x = (i * 180 - int(self.camera_x * 0.15)) % (SCREEN_WIDTH + 150)
                pygame.draw.rect(surface, NAVY, (x, 0, 60, SCREEN_HEIGHT))
                pygame.draw.rect(surface, DARK_BROWN, (x + 10, 0, 40, SCREEN_HEIGHT))
            # Chains hanging from ceiling
            for i in range(8):
                x = (i * 250 - int(self.camera_x * 0.2)) % (SCREEN_WIDTH + 200)
                for j in range(6):
                    pygame.draw.rect(surface, GRAY, (x + 5, j * 25, 10, 20))
        elif self.level_type == LEVEL_CASTLE:
            surface.fill(NAVY)
            # Castle interior
            for i in range(10):
                x = (i * 200 - int(self.camera_x * 0.1)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_BLUE, (x, 0, 80, SCREEN_HEIGHT))
        elif self.level_type == LEVEL_BOSS:
            surface.fill(DARK_RED)
            # Ominous atmosphere
            for i in range(5):
                x = SCREEN_WIDTH // 2 + (i - 2) * 150
                pygame.draw.rect(surface, RED, (x, 0, 20, SCREEN_HEIGHT), 1)
            # Pulsing glow effect
            import math
            pulse = int(abs(math.sin(pygame.time.get_ticks() * 0.002)) * 30)
            pygame.draw.rect(surface, (*RED[:3], pulse), (0, 0, SCREEN_WIDTH, SCREEN_HEIGHT))
        else:
            # Forest background
            surface.fill(SKY_BLUE)
            # Clouds
            for i in range(8):
                x = (i * 200 - int(self.camera_x * 0.3)) % (SCREEN_WIDTH + 200)
                pygame.draw.ellipse(surface, WHITE, (x, 50 + i * 20, 100, 40))
            # Distant trees
            for i in range(15):
                x = (i * 150 - int(self.camera_x * 0.5)) % (SCREEN_WIDTH + 100)
                pygame.draw.rect(surface, DARK_GREEN, (x, 300, 40, 200))
                pygame.draw.polygon(surface, GREEN, [
                    (x - 20, 300), (x + 20, 200), (x + 60, 300)
                ])

```

Let me also add a fortress tile type for the world map so it displays correctly:

```python
"""
Sprite rendering utilities for 16-bit pixel art style
"""

import pygame
from settings import *


def create_pixel_surface(width, height, scale=PIXEL_SCALE):
    """Create a surface for pixel art that will be scaled up"""
    return pygame.Surface((width, height), pygame.SRCALPHA)


def scale_surface(surface, scale=PIXEL_SCALE):
    """Scale a surface up for that chunky 16-bit look"""
    w, h = surface.get_size()
    return pygame.transform.scale(surface, (w * scale, h * scale))


def draw_pixel_rect(surface, color, rect, scale=1):
    """Draw a rectangle with pixel-perfect edges"""
    pygame.draw.rect(surface, color, rect)


def create_chain_sprite(facing_right=True, frame=0):
    """Create Chain's sprite - the hero"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    # Body (tunic)
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (4, 6, 8, 7))
    
    # Head
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (5, 2, 6, 5))
    
    # Hair (blue-ish)
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (5, 1, 6, 2))
    pygame.draw.rect(surface, hair_color, (4, 2, 1, 2))
    if facing_right:
        pygame.draw.rect(surface, hair_color, (11, 2, 1, 3))
    else:
        pygame.draw.rect(surface, hair_color, (4, 2, 1, 3))
    
    # Eyes
    eye_color = DARK_BLUE
    if facing_right:
        pygame.draw.rect(surface, eye_color, (9, 4, 1, 1))
    else:
        pygame.draw.rect(surface, eye_color, (6, 4, 1, 1))
    
    # Legs (animated)
    leg_color = BROWN
    if frame % 2 == 0:
        pygame.draw.rect(surface, leg_color, (5, 13, 2, 3))
        pygame.draw.rect(surface, leg_color, (9, 13, 2, 3))
    else:
        pygame.draw.rect(surface, leg_color, (4, 13, 2, 3))
        pygame.draw.rect(surface, leg_color, (10, 13, 2, 3))
    
    # Boots
    boot_color = DARK_BROWN
    if frame % 2 == 0:
        pygame.draw.rect(surface, boot_color, (5, 15, 2, 1))
        pygame.draw.rect(surface, boot_color, (9, 15, 2, 1))
    else:
        pygame.draw.rect(surface, boot_color, (4, 15, 2, 1))
        pygame.draw.rect(surface, boot_color, (10, 15, 2, 1))
    
    # Belt
    belt_color = BROWN
    pygame.draw.rect(surface, belt_color, (4, 10, 8, 1))
    
    # Belt buckle (chain link symbol)
    pygame.draw.rect(surface, YELLOW, (7, 10, 2, 1))
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_chain_attack_sprite(facing_right=True):
    """Create Chain's attack sprite with sword"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    # Base character (offset to make room for sword)
    offset_x = 4 if facing_right else 4
    
    # Body
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (offset_x + 4, 6, 8, 7))
    
    # Head
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (offset_x + 5, 2, 6, 5))
    
    # Hair
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (offset_x + 5, 1, 6, 2))
    
    # Eyes
    eye_color = DARK_BLUE
    if facing_right:
        pygame.draw.rect(surface, eye_color, (offset_x + 9, 4, 1, 1))
    else:
        pygame.draw.rect(surface, eye_color, (offset_x + 6, 4, 1, 1))
    
    # Legs
    leg_color = BROWN
    pygame.draw.rect(surface, leg_color, (offset_x + 5, 13, 2, 3))
    pygame.draw.rect(surface, leg_color, (offset_x + 9, 13, 2, 3))
    
    # Sword
    sword_color = LIGHT_SLATE
    sword_handle = BROWN
    if facing_right:
        pygame.draw.rect(surface, sword_handle, (offset_x + 12, 6, 2, 3))
        pygame.draw.rect(surface, sword_color, (offset_x + 14, 4, 6, 2))
        pygame.draw.rect(surface, YELLOW, (offset_x + 12, 5, 3, 1))  # Guard
    else:
        pygame.draw.rect(surface, sword_handle, (offset_x - 2, 6, 2, 3))
        pygame.draw.rect(surface, sword_color, (offset_x - 8, 4, 6, 2))
        pygame.draw.rect(surface, YELLOW, (offset_x - 3, 5, 3, 1))  # Guard
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_slime_sprite(frame=0):
    """Create slime enemy sprite"""
    size = 12
    surface = create_pixel_surface(size, size)
    
    color = LIME
    dark = DARK_GREEN
    
    # Body (bouncy animation)
    if frame % 20 < 10:
        pygame.draw.rect(surface, dark, (1, 6, 10, 6))
        pygame.draw.rect(surface, color, (2, 4, 8, 6))
        pygame.draw.rect(surface, color, (3, 3, 6, 2))
    else:
        pygame.draw.rect(surface, dark, (0, 8, 12, 4))
        pygame.draw.rect(surface, color, (1, 6, 10, 4))
        pygame.draw.rect(surface, color, (2, 5, 8, 2))
    
    # Eyes
    pygame.draw.rect(surface, WHITE, (3, 5, 2, 2))
    pygame.draw.rect(surface, WHITE, (7, 5, 2, 2))
    pygame.draw.rect(surface, BLACK, (4, 6, 1, 1))
    pygame.draw.rect(surface, BLACK, (8, 6, 1, 1))
    
    return scale_surface(surface)


def create_bat_sprite(frame=0):
    """Create bat enemy sprite"""
    size = 14
    surface = create_pixel_surface(size, size)
    
    color = PURPLE
    dark = DARK_BLUE
    
    # Body
    pygame.draw.rect(surface, color, (5, 5, 4, 5))
    pygame.draw.rect(surface, dark, (6, 4, 2, 2))
    
    # Wings (animated)
    if frame % 10 < 5:
        # Wings up
        pygame.draw.rect(surface, color, (0, 3, 5, 3))
        pygame.draw.rect(surface, color, (9, 3, 5, 3))
        pygame.draw.rect(surface, color, (1, 2, 3, 2))
        pygame.draw.rect(surface, color, (10, 2, 3, 2))
    else:
        # Wings down
        pygame.draw.rect(surface, color, (0, 6, 5, 3))
        pygame.draw.rect(surface, color, (9, 6, 5, 3))
        pygame.draw.rect(surface, color, (1, 8, 3, 2))
        pygame.draw.rect(surface, color, (10, 8, 3, 2))
    
    # Eyes (red, menacing)
    pygame.draw.rect(surface, RED, (5, 5, 1, 1))
    pygame.draw.rect(surface, RED, (8, 5, 1, 1))
    
    # Ears
    pygame.draw.rect(surface, color, (5, 3, 1, 2))
    pygame.draw.rect(surface, color, (8, 3, 1, 2))
    
    return scale_surface(surface)


def create_knight_sprite(facing_right=True, frame=0):
    """Create knight enemy sprite - armored and tough"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    armor_color = SLATE
    armor_dark = GRAY
    visor_color = DARK_BLUE
    
    # Body (armor)
    pygame.draw.rect(surface, armor_dark, (4, 6, 8, 7))
    pygame.draw.rect(surface, armor_color, (5, 5, 6, 6))
    
    # Helmet
    pygame.draw.rect(surface, armor_dark, (4, 1, 8, 5))
    pygame.draw.rect(surface, armor_color, (5, 2, 6, 3))
    
    # Visor
    pygame.draw.rect(surface, visor_color, (6, 3, 4, 2))
    pygame.draw.rect(surface, RED, (7, 3, 1, 1))  # Glowing eye
    pygame.draw.rect(surface, RED, (9, 3, 1, 1))  # Glowing eye
    
    # Shield
    if facing_right:
        pygame.draw.rect(surface, armor_dark, (2, 6, 3, 5))
        pygame.draw.rect(surface, armor_color, (2, 7, 2, 3))
    else:
        pygame.draw.rect(surface, armor_dark, (11, 6, 3, 5))
        pygame.draw.rect(surface, armor_color, (12, 7, 2, 3))
    
    # Sword
    sword_color = LIGHT_SLATE
    if facing_right:
        pygame.draw.rect(surface, sword_color, (12, 4, 2, 6))
        pygame.draw.rect(surface, sword_color, (13, 2, 1, 3))
    else:
        pygame.draw.rect(surface, sword_color, (2, 4, 2, 6))
        pygame.draw.rect(surface, sword_color, (2, 2, 1, 3))
    
    # Legs (armored)
    if frame % 2 == 0:
        pygame.draw.rect(surface, armor_dark, (5, 13, 2, 3))
        pygame.draw.rect(surface, armor_dark, (9, 13, 2, 3))
    else:
        pygame.draw.rect(surface, armor_dark, (4, 13, 2, 3))
        pygame.draw.rect(surface, armor_dark, (10, 13, 2, 3))
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_cannon_sprite(frame=0):
    """Create Cannon (boss) sprite - the archenemy"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    # Cape
    cape_color = DARK_RED
    pygame.draw.rect(surface, cape_color, (2, 6, 20, 14))
    pygame.draw.rect(surface, RED, (4, 8, 16, 10))
    
    # Body (dark armor)
    armor_color = DARK_BLUE
    armor_accent = NAVY
    pygame.draw.rect(surface, armor_color, (7, 6, 10, 10))
    pygame.draw.rect(surface, armor_accent, (8, 7, 8, 8))
    
    # Head (helmet with crown)
    pygame.draw.rect(surface, armor_color, (8, 1, 8, 6))
    pygame.draw.rect(surface, DARK_RED, (9, 3, 6, 3))  # Visor
    
    # Crown spikes
    pygame.draw.rect(surface, YELLOW, (8, 0, 2, 2))
    pygame.draw.rect(surface, YELLOW, (11, 0, 2, 1))
    pygame.draw.rect(surface, YELLOW, (14, 0, 2, 2))
    
    # Evil eyes
    pygame.draw.rect(surface, YELLOW, (10, 3, 1, 1))
    pygame.draw.rect(surface, YELLOW, (13, 3, 1, 1))
    
    # Cannon arm (signature weapon)
    cannon_color = GRAY
    if frame % 30 < 15:
        pygame.draw.rect(surface, cannon_color, (17, 8, 6, 4))
        pygame.draw.rect(surface, DARK_BROWN, (16, 9, 2, 2))
        pygame.draw.rect(surface, ORANGE, (22, 9, 2, 2))  # Charging
    else:
        pygame.draw.rect(surface, cannon_color, (17, 8, 6, 4))
        pygame.draw.rect(surface, DARK_BROWN, (16, 9, 2, 2))
    
    # Legs
    pygame.draw.rect(surface, armor_color, (8, 16, 3, 6))
    pygame.draw.rect(surface, armor_color, (13, 16, 3, 6))
    pygame.draw.rect(surface, DARK_BROWN, (8, 21, 3, 2))
    pygame.draw.rect(surface, DARK_BROWN, (13, 21, 3, 2))
    
    return scale_surface(surface)


def create_heart_sprite(full=True, is_container=False):
    """Create heart sprite for health display"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if is_container:
        color = YELLOW
        outline = ORANGE
    elif full:
        color = RED
        outline = DARK_RED
    else:
        color = GRAY
        outline = DARK_BROWN
    
    # Heart shape
    pygame.draw.rect(surface, outline, (1, 2, 3, 3))
    pygame.draw.rect(surface, outline, (6, 2, 3, 3))
    pygame.draw.rect(surface, outline, (0, 3, 2, 3))
    pygame.draw.rect(surface, outline, (8, 3, 2, 3))
    pygame.draw.rect(surface, outline, (2, 5, 6, 3))
    pygame.draw.rect(surface, outline, (3, 8, 4, 1))
    pygame.draw.rect(surface, outline, (4, 9, 2, 1))
    
    # Fill
    pygame.draw.rect(surface, color, (2, 3, 2, 2))
    pygame.draw.rect(surface, color, (6, 3, 2, 2))
    pygame.draw.rect(surface, color, (1, 4, 2, 2))
    pygame.draw.rect(surface, color, (7, 4, 2, 2))
    pygame.draw.rect(surface, color, (3, 5, 4, 2))
    pygame.draw.rect(surface, color, (4, 7, 2, 1))
    
    # Highlight
    if full or is_container:
        pygame.draw.rect(surface, WHITE, (2, 3, 1, 1))
    
    return scale_surface(surface)


def create_magic_sprite(full=True, is_bottle=False):
    """Create magic point sprite (star/crystal)"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if is_bottle:
        color = MAGENTA
        outline = PURPLE
    elif full:
        color = CYAN
        outline = TEAL
    else:
        color = GRAY
        outline = DARK_BROWN
    
    # Crystal/star shape
    pygame.draw.rect(surface, outline, (4, 0, 2, 2))
    pygame.draw.rect(surface, outline, (3, 2, 4, 2))
    pygame.draw.rect(surface, outline, (0, 3, 10, 2))
    pygame.draw.rect(surface, outline, (2, 5, 6, 2))
    pygame.draw.rect(surface, outline, (3, 7, 4, 2))
    pygame.draw.rect(surface, outline, (4, 9, 2, 1))
    
    # Fill
    pygame.draw.rect(surface, color, (4, 1, 2, 1))
    pygame.draw.rect(surface, color, (3, 3, 4, 1))
    pygame.draw.rect(surface, color, (1, 4, 8, 1))
    pygame.draw.rect(surface, color, (3, 5, 4, 1))
    pygame.draw.rect(surface, color, (4, 6, 2, 2))
    
    # Highlight
    if full or is_bottle:
        pygame.draw.rect(surface, WHITE, (4, 3, 1, 1))
    
    return scale_surface(surface)


def create_food_sprite(food_type='food'):
    """Create food item sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if food_type == 'feast':
        # Roasted chicken leg
        pygame.draw.rect(surface, TAN, (2, 2, 6, 5))
        pygame.draw.rect(surface, BEIGE, (3, 3, 4, 3))
        pygame.draw.rect(surface, BROWN, (1, 6, 2, 3))  # Bone
        pygame.draw.rect(surface, CREAM, (1, 8, 2, 1))
    else:
        # Apple
        pygame.draw.rect(surface, RED, (2, 3, 6, 5))
        pygame.draw.rect(surface, RED, (3, 2, 4, 1))
        pygame.draw.rect(surface, DARK_RED, (2, 6, 6, 2))
        pygame.draw.rect(surface, BROWN, (4, 0, 2, 3))  # Stem
        pygame.draw.rect(surface, GREEN, (5, 1, 2, 2))  # Leaf
        pygame.draw.rect(surface, WHITE, (3, 3, 1, 1))  # Highlight
    
    return scale_surface(surface)


def create_magic_vial_sprite(vial_type='magic_vial'):
    """Create magic vial sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if vial_type == 'magic_potion':
        color = TEAL
        liquid = CYAN
    else:
        color = PURPLE
        liquid = MAGENTA
    
    # Bottle
    pygame.draw.rect(surface, LIGHT_GRAY, (3, 0, 4, 2))  # Cork
    pygame.draw.rect(surface, LIGHT_SLATE, (2, 2, 6, 2))  # Neck
    pygame.draw.rect(surface, LIGHT_SLATE, (1, 4, 8, 5))  # Body outline
    
    # Liquid
    pygame.draw.rect(surface, color, (2, 5, 6, 3))
    pygame.draw.rect(surface, liquid, (3, 6, 4, 2))
    
    # Highlight
    pygame.draw.rect(surface, WHITE, (2, 4, 1, 2))
    
    # Sparkle
    pygame.draw.rect(surface, WHITE, (5, 5, 1, 1))
    
    return scale_surface(surface)


def create_fireball_sprite(frame=0):
    """Create fireball projectile sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    # Core
    pygame.draw.rect(surface, YELLOW, (3, 3, 4, 4))
    pygame.draw.rect(surface, WHITE, (4, 4, 2, 2))
    
    # Flames (animated)
    if frame % 4 < 2:
        pygame.draw.rect(surface, ORANGE, (2, 2, 2, 2))
        pygame.draw.rect(surface, ORANGE, (6, 2, 2, 2))
        pygame.draw.rect(surface, ORANGE, (2, 6, 2, 2))
        pygame.draw.rect(surface, ORANGE, (6, 6, 2, 2))
        pygame.draw.rect(surface, RED, (1, 4, 2, 2))
    else:
        pygame.draw.rect(surface, ORANGE, (1, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (7, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (1, 5, 2, 2))
        pygame.draw.rect(surface, ORANGE, (7, 5, 2, 2))
        pygame.draw.rect(surface, RED, (0, 4, 2, 2))
    
    return scale_surface(surface)


def create_thunder_sprite(frame=0):
    """Create thunder effect sprite"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    # Lightning bolt shape
    color = YELLOW if frame % 4 < 2 else WHITE
    
    pygame.draw.rect(surface, color, (8, 0, 3, 4))
    pygame.draw.rect(surface, color, (6, 3, 4, 3))
    pygame.draw.rect(surface, color, (4, 5, 6, 3))
    pygame.draw.rect(surface, color, (6, 7, 4, 3))
    pygame.draw.rect(surface, color, (8, 9, 3, 4))
    pygame.draw.rect(surface, color, (10, 12, 2, 4))
    
    return scale_surface(surface)


def create_shield_effect_sprite(frame=0):
    """Create shield buff visual effect"""
    size = 20
    surface = create_pixel_surface(size, size)
    
    # Shimmering shield
    alpha = 128 + int(64 * ((frame % 30) / 30))
    color = (*CYAN[:3], alpha)
    
    # Circular shield
    for i in range(8):
        angle_offset = (frame * 3 + i * 45) % 360
        x = int(10 + 7 * (1 if i % 2 == 0 else -1) * ((frame + i * 5) % 10) / 10)
        y = int(10 + 7 * (1 if i < 4 else -1) * ((frame + i * 5) % 10) / 10)
        pygame.draw.rect(surface, CYAN, (x, y, 2, 2))
    
    # Border
    pygame.draw.rect(surface, TEAL, (0, 8, 2, 4))
    pygame.draw.rect(surface, TEAL, (18, 8, 2, 4))
    pygame.draw.rect(surface, TEAL, (8, 0, 4, 2))
    pygame.draw.rect(surface, TEAL, (8, 18, 4, 2))
    
    return scale_surface(surface)


def create_tile_sprite(tile_type, variant=0):
    """Create tile sprites for levels"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    if tile_type == 'grass':
        pygame.draw.rect(surface, GREEN, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIME, (0, 0, 16, 4))
        # Grass detail
        for i in range(4):
            x = (i * 4 + variant) % 16
            pygame.draw.rect(surface, DARK_GREEN, (x, 4, 1, 2))
    
    elif tile_type == 'dirt':
        pygame.draw.rect(surface, BROWN, (0, 0, 16, 16))
        pygame.draw.rect(surface, TAN, (2, 2, 3, 2))
        pygame.draw.rect(surface, TAN, (10, 8, 4, 3))
        pygame.draw.rect(surface, DARK_BROWN, (6, 12, 2, 2))
    
    elif tile_type == 'stone':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIGHT_GRAY, (1, 1, 6, 5))
        pygame.draw.rect(surface, LIGHT_GRAY, (9, 8, 5, 6))
        pygame.draw.rect(surface, DARK_BROWN, (0, 7, 16, 1))
        pygame.draw.rect(surface, DARK_BROWN, (7, 0, 1, 16))
    
    elif tile_type == 'brick':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        # Brick pattern
        pygame.draw.rect(surface, RED, (1, 1, 6, 6))
        pygame.draw.rect(surface, RED, (9, 1, 6, 6))
        pygame.draw.rect(surface, RED, (1, 9, 14, 6))
        pygame.draw.rect(surface, BROWN, (0, 7, 16, 2))
        pygame.draw.rect(surface, BROWN, (7, 0, 2, 8))
    
    elif tile_type == 'wood':
        pygame.draw.rect(surface, BROWN, (0, 0, 16, 16))
        # Wood grain
        for i in range(4):
            y = i * 4 + 1
            pygame.draw.rect(surface, TAN, (0, y, 16, 2))
        pygame.draw.rect(surface, DARK_BROWN, (4, 0, 1, 16))
        pygame.draw.rect(surface, DARK_BROWN, (11, 0, 1, 16))
    
    elif tile_type == 'water':
        base = TEAL if variant % 2 == 0 else SKY_BLUE
        pygame.draw.rect(surface, base, (0, 0, 16, 16))
        # Waves
        wave_color = CYAN
        for i in range(3):
            x = (i * 6 + variant * 2) % 16
            pygame.draw.rect(surface, wave_color, (x, 4, 4, 1))
            pygame.draw.rect(surface, wave_color, ((x + 3) % 16, 10, 4, 1))
    
    elif tile_type == 'lava':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        pygame.draw.rect(surface, RED, (2, 2, 5, 4))
        pygame.draw.rect(surface, RED, (9, 7, 5, 5))
        pygame.draw.rect(surface, ORANGE, (3, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (10, 9, 3, 2))
        pygame.draw.rect(surface, YELLOW, (4, 3, 1, 1))
    
    elif tile_type == 'sky':
        pygame.draw.rect(surface, SKY_BLUE, (0, 0, 16, 16))
        if variant % 3 == 0:
            # Cloud
            pygame.draw.rect(surface, WHITE, (2, 4, 8, 4))
            pygame.draw.rect(surface, WHITE, (4, 2, 4, 2))
    
    return scale_surface(surface)


def create_world_map_tile(tile_type):
    """Create tiles for the world map"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    if tile_type == 'grass':
        pygame.draw.rect(surface, GREEN, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIME, (3, 3, 2, 2))
        pygame.draw.rect(surface, LIME, (10, 8, 2, 2))
        pygame.draw.rect(surface, DARK_GREEN, (7, 12, 2, 2))
    
    elif tile_type == 'forest':
        pygame.draw.rect(surface, DARK_GREEN, (0, 0, 16, 16))
        # Trees
        pygame.draw.rect(surface, GREEN, (2, 4, 4, 6))
        pygame.draw.rect(surface, GREEN, (10, 2, 4, 8))
        pygame.draw.rect(surface, BROWN, (3, 10, 2, 4))
        pygame.draw.rect(surface, BROWN, (11, 10, 2, 4))
    
    elif tile_type == 'mountain':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        # Mountain peak
        pygame.draw.rect(surface, SLATE, (6, 0, 4, 6))
        pygame.draw.rect(surface, SLATE, (4, 6, 8, 4))
        pygame.draw.rect(surface, SLATE, (2, 10, 12, 6))
        pygame.draw.rect(surface, WHITE, (7, 1, 2, 3))  # Snow cap
    
    elif tile_type == 'water':
        pygame.draw.rect(surface, NAVY, (0, 0, 16, 16))
        pygame.draw.rect(surface, TEAL, (2, 4, 6, 2))
        pygame.draw.rect(surface, TEAL, (8, 10, 6, 2))
    
    elif tile_type == 'path':
        # Full path tile that connects in all directions
        pygame.draw.rect(surface, TAN, (0, 0, 16, 16))
        # Add some texture/detail
        pygame.draw.rect(surface, BEIGE, (2, 2, 4, 4))
        pygame.draw.rect(surface, BEIGE, (10, 10, 4, 4))
        pygame.draw.rect(surface, BROWN, (7, 6, 2, 2))
        pygame.draw.rect(surface, BROWN, (1, 12, 2, 2))
        pygame.draw.rect(surface, BROWN, (12, 2, 2, 2))
    
    elif tile_type == 'castle':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        # Castle structure
        pygame.draw.rect(surface, SLATE, (2, 4, 12, 12))
        pygame.draw.rect(surface, SLATE, (0, 2, 4, 4))
        pygame.draw.rect(surface, SLATE, (12, 2, 4, 4))
        pygame.draw.rect(surface, DARK_BLUE, (6, 10, 4, 6))  # Door
        pygame.draw.rect(surface, RED, (2, 0, 2, 3))  # Flag
    
    elif tile_type == 'cave':
        pygame.draw.rect(surface, DARK_BROWN, (0, 0, 16, 16))
        pygame.draw.rect(surface, BLACK, (4, 6, 8, 10))
        pygame.draw.rect(surface, DARK_BROWN, (2, 4, 12, 4))
    
    elif tile_type == 'fortress':
        # Cannon's Domain entrance - dark fortress
        pygame.draw.rect(surface, DARK_BLUE, (0, 0, 16, 16))
        # Fortress walls
        pygame.draw.rect(surface, NAVY, (1, 2, 14, 14))
        pygame.draw.rect(surface, DARK_BROWN, (3, 4, 10, 10))
        # Gate
        pygame.draw.rect(surface, BLACK, (5, 8, 6, 8))
        # Spikes on top
        pygame.draw.rect(surface, GRAY, (2, 1, 2, 4))
        pygame.draw.rect(surface, GRAY, (7, 1, 2, 4))
        pygame.draw.rect(surface, GRAY, (12, 1, 2, 4))
        # Red glow
        pygame.draw.rect(surface, RED, (6, 9, 4, 2))
    
    elif tile_type == 'boss':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        # Evil castle
        pygame.draw.rect(surface, DARK_BLUE, (2, 4, 12, 12))
        pygame.draw.rect(surface, DARK_BLUE, (0, 2, 4, 4))
        pygame.draw.rect(surface, DARK_BLUE, (12, 2, 4, 4))
        pygame.draw.rect(surface, BLACK, (6, 10, 4, 6))
        pygame.draw.rect(surface, YELLOW, (4, 6, 2, 2))  # Evil eye
        pygame.draw.rect(surface, YELLOW, (10, 6, 2, 2))  # Evil eye
    
    elif tile_type == 'level_marker':
        pygame.draw.rect(surface, YELLOW, (4, 4, 8, 8))
        pygame.draw.rect(surface, ORANGE, (6, 6, 4, 4))
    
    return scale_surface(surface)


def create_chain_world_sprite(facing='down', frame=0):
    """Create Chain sprite for world map (top-down view)"""
    size = 12
    surface = create_pixel_surface(size, size)
    
    # Body
    pygame.draw.rect(surface, TEAL, (3, 3, 6, 6))
    
    # Head direction
    skin = BEIGE
    hair = NAVY
    
    if facing == 'down':
        pygame.draw.rect(surface, hair, (4, 2, 4, 2))
        pygame.draw.rect(surface, skin, (4, 4, 4, 3))
        pygame.draw.rect(surface, DARK_BLUE, (5, 5, 1, 1))
        pygame.draw.rect(surface, DARK_BLUE, (7, 5, 1, 1))
    elif facing == 'up':
        pygame.draw.rect(surface, hair, (4, 2, 4, 4))
        pygame.draw.rect(surface, skin, (5, 5, 2, 2))
    elif facing == 'left':
        pygame.draw.rect(surface, hair, (3, 2, 4, 3))
        pygame.draw.rect(surface, skin, (3, 4, 3, 3))
        pygame.draw.rect(surface, DARK_BLUE, (3, 5, 1, 1))
    elif facing == 'right':
        pygame.draw.rect(surface, hair, (5, 2, 4, 3))
        pygame.draw.rect(surface, skin, (6, 4, 3, 3))
        pygame.draw.rect(surface, DARK_BLUE, (8, 5, 1, 1))
    
    # Feet (animated)
    if frame % 20 < 10:
        pygame.draw.rect(surface, BROWN, (3, 9, 2, 2))
        pygame.draw.rect(surface, BROWN, (7, 9, 2, 2))
    else:
        pygame.draw.rect(surface, BROWN, (4, 9, 2, 2))
        pygame.draw.rect(surface, BROWN, (6, 9, 2, 2))
    
    return scale_surface(surface)

```

Let me update the world map layout to include a path to the fortress:

```python
"""
World Map for traversing between adventures
"""

import pygame
from settings import *
from sprites import create_world_map_tile


class WorldMapTile:
    """A tile on the world map"""
    
    def __init__(self, x, y, tile_type, walkable=True, level_id=None):
        self.tile_type = tile_type
        self.walkable = walkable
        self.level_id = level_id  # If this tile leads to a level
        
        self.image = create_world_map_tile(tile_type)
        # Use actual image size for positioning (16 * PIXEL_SCALE = 32)
        tile_size = self.image.get_width()
        self.rect = pygame.Rect(
            x * tile_size,
            y * tile_size,
            tile_size,
            tile_size
        )
        self.grid_x = x
        self.grid_y = y
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


class LevelMarker:
    """Marker for a level entrance on the world map"""
    
    def __init__(self, grid_x, grid_y, level_id, level_name, level_type):
        self.grid_x = grid_x
        self.grid_y = grid_y
        self.level_id = level_id
        self.level_name = level_name
        self.level_type = level_type
        self.completed = False
        self.unlocked = False
        
        self.image = create_world_map_tile('level_marker')
        # Use actual image size for positioning (16 * PIXEL_SCALE = 32)
        tile_size = self.image.get_width()
        self.rect = pygame.Rect(
            grid_x * tile_size,
            grid_y * tile_size,
            tile_size,
            tile_size
        )
        
        # Animation
        self.frame = 0
    
    def update(self):
        self.frame += 1
    
    def draw(self, surface, camera_offset=(0, 0)):
        if not self.unlocked:
            return
        
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Pulsing effect
        import math
        pulse = int(math.sin(self.frame * 0.1) * 3)
        
        # Draw marker
        if self.completed:
            # Completed levels show as green
            completed_img = pygame.Surface(self.image.get_size(), pygame.SRCALPHA)
            completed_img.blit(self.image, (0, 0))
            completed_img.fill((*LIME[:3], 100), special_flags=pygame.BLEND_RGBA_ADD)
            surface.blit(completed_img, (draw_x, draw_y + pulse))
        else:
            surface.blit(self.image, (draw_x, draw_y + pulse))


class WorldMap:
    """The overworld map for traversing between levels"""
    
    def __init__(self):
        self.tiles = []
        self.level_markers = []
        self.map_width = WORLD_MAP_WIDTH
        self.map_height = WORLD_MAP_HEIGHT
        
        # Camera
        self.camera_x = 0
        self.camera_y = 0
        
        # Current level selection
        self.current_marker_index = 0
        
        self.generate_map()
    
    def generate_map(self):
        """Generate the world map"""
        # Define the map layout
        # Legend: G=grass, F=forest, M=mountain, W=water, P=path, C=castle, V=cave, B=boss, R=fortress
        map_data = [
            "MMMMMMMMMWWWWWWWWWWWMMMMMM",
            "MMMMMMMMWWWWWWWWWWWWMMMMMM",
            "MMMMFFFFFGGGGGGGFFFMMMMMM",
            "MMMFFFFFFGGGGGGGGFFMMMMMM",
            "MMFFFFFFFGGCGGGGGFFFMMMMM",
            "MFFFFFFFGGPPGGGGFFFFMMMMM",
            "FFFFFFFFGGPPGGGGFFFFFMMMM",
            "FFFFFFFGGGPPGGGGFFFFFFMMM",
            "FFFFFFGGGGPPPPGGGFFFFFMMM",
            "FFFFFGGGGGGGPPGGGFFFFFFMM",
            "FFFFGGGGGVGGPPGGGFFFFFFMM",
            "FFFGGGGGGGGPPPPPPPRFFFMMM",
            "FFFGGGGGGGPPGGGGGPPFFFMMM",
            "FFGGGGGGGGPPGGGGGGPPPFMMM",
            "FGGGGGGGGGPPGGGGGGGPBFMMM",
            "GGGGGGGGGPPPPGGGGGGGGFMMM",
            "GGGGGGGGGGGPPGGGGGGGFFMMM",
            "WWWWWWWWWWWWWWWWWWWWWWWWW",
            "WWWWWWWWWWWWWWWWWWWWWWWWW",
        ]
        
        tile_map = {
            'G': ('grass', True),
            'F': ('forest', False),
            'M': ('mountain', False),
            'W': ('water', False),
            'P': ('path', True),
            'C': ('castle', True),
            'V': ('cave', True),
            'R': ('fortress', True),
            'B': ('boss', True),
        }
        
        # Create tiles
        for y, row in enumerate(map_data):
            for x, char in enumerate(row):
                if char in tile_map:
                    tile_type, walkable = tile_map[char]
                    tile = WorldMapTile(x, y, tile_type, walkable)
                    self.tiles.append(tile)
        
        # Create level markers - progression through the world
        self.level_markers = [
            LevelMarker(10, 4, 'castle', "Castle Entrance", LEVEL_CASTLE),
            LevelMarker(9, 10, 'cave', "Dark Cave", LEVEL_CAVE),
            LevelMarker(17, 11, 'fortress', "Cannon's Domain", LEVEL_CASTLE),
            LevelMarker(19, 14, 'boss', "Cannon's Throne", LEVEL_BOSS),
        ]
        
        # Start with first level unlocked
        self.level_markers[0].unlocked = True
    
    def get_walkable_tiles(self):
        """Get list of walkable tiles for collision"""
        return [tile for tile in self.tiles if not tile.walkable]
    
    def get_current_level_marker(self, player_rect):
        """Check if player is on a level marker"""
        for marker in self.level_markers:
            if marker.unlocked and player_rect.colliderect(marker.rect):
                return marker
        return None
    
    def complete_level(self, level_id):
        """Mark a level as completed and unlock next"""
        for i, marker in enumerate(self.level_markers):
            if marker.level_id == level_id:
                marker.completed = True
                # Unlock next level
                if i + 1 < len(self.level_markers):
                    self.level_markers[i + 1].unlocked = True
                break
    
    def get_start_position(self):
        """Get the starting position for the player"""
        # Start near the first level marker
        first_marker = self.level_markers[0]
        return (
            first_marker.rect.x,
            first_marker.rect.y + TILE_SIZE * PIXEL_SCALE
        )
    
    def update_camera(self, player):
        """Update camera to follow player"""
        # Center camera on player
        target_x = player.rect.centerx - SCREEN_WIDTH // 2
        target_y = player.rect.centery - SCREEN_HEIGHT // 2
        
        # Smooth camera movement
        self.camera_x += (target_x - self.camera_x) * 0.1
        self.camera_y += (target_y - self.camera_y) * 0.1
        
        # Clamp to map bounds (tile size is 16 * PIXEL_SCALE = 32)
        actual_tile_size = 16 * PIXEL_SCALE
        max_x = self.map_width * actual_tile_size - SCREEN_WIDTH
        max_y = self.map_height * actual_tile_size - SCREEN_HEIGHT
        
        self.camera_x = max(0, min(self.camera_x, max_x))
        self.camera_y = max(0, min(self.camera_y, max_y))
    
    def update(self, player):
        """Update world map state"""
        self.update_camera(player)
        
        for marker in self.level_markers:
            marker.update()
    
    def draw(self, surface):
        """Draw the world map"""
        camera_offset = (int(self.camera_x), int(self.camera_y))
        
        # Draw tiles
        for tile in self.tiles:
            # Only draw visible tiles
            if (tile.rect.x - camera_offset[0] > -TILE_SIZE * PIXEL_SCALE and
                tile.rect.x - camera_offset[0] < SCREEN_WIDTH + TILE_SIZE * PIXEL_SCALE and
                tile.rect.y - camera_offset[1] > -TILE_SIZE * PIXEL_SCALE and
                tile.rect.y - camera_offset[1] < SCREEN_HEIGHT + TILE_SIZE * PIXEL_SCALE):
                tile.draw(surface, camera_offset)
        
        # Draw level markers
        for marker in self.level_markers:
            marker.draw(surface, camera_offset)
    
    def get_camera_offset(self):
        """Get current camera offset"""
        return (int(self.camera_x), int(self.camera_y))
    
    def get_location_name(self, player_rect):
        """Get the name of current location"""
        marker = self.get_current_level_marker(player_rect)
        if marker:
            status = " (Completed)" if marker.completed else " (Press ENTER)"
            return marker.level_name + status
        
        # Check tile type
        for tile in self.tiles:
            if player_rect.colliderect(tile.rect):
                names = {
                    'grass': 'Grasslands',
                    'forest': 'Dense Forest',
                    'mountain': 'Mountains',
                    'water': 'Ocean',
                    'path': 'The Road',
                    'castle': 'Castle',
                    'cave': 'Cave Entrance',
                    'boss': "Cannon's Domain"
                }
                return names.get(tile.tile_type, '')
        
        return ''

```

Done! I've added **Cannon's Domain** as a challenging dungeon before the boss fight. Here's what's new:

**New Level: Cannon's Domain**
- Much longer level (4000 pixels vs 2500)
- **6 pit gaps** that require precise jumping (falling = death)
- **Complex platforming** with narrow single-tile platforms
- **18 enemies** including:
  - Multiple knights in a "knight gauntlet" section
  - Bats harassing you during tricky jumps
  - Slimes on the ground
- Strategic item placement requiring skill to collect
- Dark, foreboding atmosphere with red glow, dark pillars, and hanging chains

**Level Progression:**
1. **Castle Entrance** - Learn the basics
2. **Dark Cave** - Bats and vertical challenges
3. **Cannon's Domain** - The gauntlet (hard!)
4. **Cannon's Throne** - Final boss fight

The fortress also appears on the world map with its own tile showing a dark fortress with spikes and a red glowing gate.

---

**User**

pressing the i key should toggle invincible mode. The main character should shimmer like a rainbow and not take any damage while invincible mode is enabled. Any enemy that touches inbincible chain will immediately be eliminated.

---

**Cursor**

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import create_chain_sprite, create_chain_attack_sprite, create_chain_world_sprite
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-4)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import create_chain_sprite, create_chain_attack_sprite, create_chain_world_sprite
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-4)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import create_chain_sprite, create_chain_attack_sprite, create_chain_world_sprite
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-4)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import create_chain_sprite, create_chain_attack_sprite, create_chain_world_sprite
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-4)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

Now let me update the combat system to instantly eliminate enemies on contact:

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
        elif event.key == pygame.K_RETURN:
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                else:
                    self.player.take_damage(enemy.damage)
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

Done! **Press 'I'** to toggle invincible mode. When active:

- **Rainbow shimmer effect** - Chain glows with cycling rainbow colors and a colored aura
- **Immune to all damage** - Enemies, projectiles, and hazards can't hurt you
- **Instant elimination** - Any enemy that touches Chain is immediately destroyed (and you get points!)
- **Destroys projectiles** - Boss cannon balls are also destroyed on contact

---

**User**

When you use the Swift spell, Make the particles go behind you no matter what direction you're going. Add an up slash attack where you can slash upwards. Add a thunder spell. 2.0 where you can strike down enemies and it uses two Magic points. And give Ganon A health bar on the top.

---

**Cursor**

I'll implement all these changes:

```python
"""
Spell system for Chain
"""

import pygame
import math
from settings import *
from sprites import create_fireball_sprite, create_thunder_sprite, create_shield_effect_sprite


class Spell:
    """Base spell class"""
    
    def __init__(self, name, cost, spell_type):
        self.name = name
        self.cost = cost
        self.spell_type = spell_type  # 'buff' or 'offensive'
        self.active = False
        self.duration = 0
        self.frame = 0
    
    def can_cast(self, magic_points):
        return magic_points >= self.cost
    
    def cast(self, caster, target_pos=None, facing_right=True):
        """Override in subclasses"""
        pass
    
    def update(self):
        self.frame += 1
    
    def draw(self, surface, pos):
        pass


class ShieldSpell(Spell):
    """Shield buff - reduces incoming damage"""
    
    def __init__(self):
        super().__init__('Shield', SPELL_COSTS['shield'], 'buff')
        self.duration = SPELL_DURATIONS['shield']
        self.remaining_duration = 0
    
    def cast(self, caster, target_pos=None, facing_right=True):
        self.active = True
        self.remaining_duration = self.duration
        return True
    
    def update(self):
        super().update()
        if self.active:
            self.remaining_duration -= 1
            if self.remaining_duration <= 0:
                self.active = False
    
    def get_damage_multiplier(self):
        if self.active:
            return SHIELD_DAMAGE_REDUCTION
        return 1.0
    
    def draw(self, surface, pos):
        if self.active:
            sprite = create_shield_effect_sprite(self.frame)
            # Center on player
            x = pos[0] - sprite.get_width() // 2
            y = pos[1] - sprite.get_height() // 2
            surface.blit(sprite, (x, y))


class SwiftSpell(Spell):
    """Swift buff - increases movement and jump speed"""
    
    def __init__(self):
        super().__init__('Swift', SPELL_COSTS['swift'], 'buff')
        self.duration = SPELL_DURATIONS['swift']
        self.remaining_duration = 0
        self.trail_particles = []  # Store particle positions
        self.last_pos = None
    
    def cast(self, caster, target_pos=None, facing_right=True):
        self.active = True
        self.remaining_duration = self.duration
        self.trail_particles = []
        return True
    
    def update(self):
        super().update()
        if self.active:
            self.remaining_duration -= 1
            if self.remaining_duration <= 0:
                self.active = False
                self.trail_particles = []
    
    def get_speed_multiplier(self):
        if self.active:
            return SWIFT_SPEED_MULTIPLIER
        return 1.0
    
    def get_jump_multiplier(self):
        if self.active:
            return SWIFT_JUMP_MULTIPLIER
        return 1.0
    
    def update_trail(self, current_pos):
        """Update trail particles based on player position"""
        if self.active:
            # Add new particle at current position
            self.trail_particles.append({
                'x': current_pos[0],
                'y': current_pos[1],
                'life': 15,
                'size': 8
            })
            # Update existing particles
            for particle in self.trail_particles:
                particle['life'] -= 1
                particle['size'] = max(2, particle['size'] - 0.3)
            # Remove dead particles
            self.trail_particles = [p for p in self.trail_particles if p['life'] > 0]
            # Limit particle count
            if len(self.trail_particles) > 20:
                self.trail_particles = self.trail_particles[-20:]
    
    def draw(self, surface, pos):
        if self.active:
            # Update trail with current position
            self.update_trail(pos)
            
            # Draw trail particles behind player (oldest first)
            colors = [CYAN, TEAL, MINT, WHITE]
            for i, particle in enumerate(self.trail_particles):
                alpha = int((particle['life'] / 15) * 200)
                color_idx = i % len(colors)
                color = colors[color_idx]
                size = int(particle['size'])
                pygame.draw.rect(surface, color, 
                               (int(particle['x']) - size//2, 
                                int(particle['y']) - size//2, 
                                size, size))


class Fireball(pygame.sprite.Sprite):
    """Fireball projectile"""
    
    def __init__(self, x, y, facing_right):
        super().__init__()
        self.frame = 0
        self.image = create_fireball_sprite(self.frame)
        self.rect = self.image.get_rect(center=(x, y))
        self.direction = 1 if facing_right else -1
        self.speed = FIREBALL_SPEED
        self.damage = FIREBALL_DAMAGE
        self.lifetime = 120  # frames
    
    def update(self):
        self.frame += 1
        self.rect.x += self.speed * self.direction
        self.image = create_fireball_sprite(self.frame)
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()


class FireballSpell(Spell):
    """Fireball offensive spell"""
    
    def __init__(self):
        super().__init__('Fireball', SPELL_COSTS['fireball'], 'offensive')
        self.projectiles = pygame.sprite.Group()
    
    def cast(self, caster, target_pos=None, facing_right=True):
        # Create fireball projectile
        fireball = Fireball(caster.rect.centerx, caster.rect.centery, facing_right)
        self.projectiles.add(fireball)
        return fireball
    
    def update(self):
        super().update()
        self.projectiles.update()
    
    def draw(self, surface, pos):
        self.projectiles.draw(surface)
    
    def get_projectiles(self):
        return self.projectiles


class ThunderEffect(pygame.sprite.Sprite):
    """Thunder area effect"""
    
    def __init__(self, x, y):
        super().__init__()
        self.frame = 0
        self.image = create_thunder_sprite(self.frame)
        self.rect = self.image.get_rect(center=(x, y))
        self.damage = THUNDER_DAMAGE
        self.radius = THUNDER_RADIUS
        self.lifetime = 30  # frames
        self.hit_enemies = set()  # Track which enemies have been hit
    
    def update(self):
        self.frame += 1
        self.image = create_thunder_sprite(self.frame)
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def can_hit(self, enemy):
        """Check if enemy is in range and hasn't been hit yet"""
        if enemy in self.hit_enemies:
            return False
        
        # Calculate distance
        dx = enemy.rect.centerx - self.rect.centerx
        dy = enemy.rect.centery - self.rect.centery
        distance = math.sqrt(dx * dx + dy * dy)
        
        if distance <= self.radius:
            self.hit_enemies.add(enemy)
            return True
        return False


class ThunderSpell(Spell):
    """Thunder area-of-effect offensive spell"""
    
    def __init__(self):
        super().__init__('Thunder', SPELL_COSTS['thunder'], 'offensive')
        self.effects = pygame.sprite.Group()
    
    def cast(self, caster, target_pos=None, facing_right=True):
        # Create thunder effect at player position
        offset = 50 if facing_right else -50
        thunder = ThunderEffect(caster.rect.centerx + offset, caster.rect.centery)
        self.effects.add(thunder)
        return thunder
    
    def update(self):
        super().update()
        self.effects.update()
    
    def draw(self, surface, pos):
        self.effects.draw(surface)
    
    def get_effects(self):
        return self.effects


class SpellManager:
    """Manages all spells for the player"""
    
    def __init__(self):
        self.spells = {
            'shield': ShieldSpell(),
            'swift': SwiftSpell(),
            'fireball': FireballSpell(),
            'thunder': ThunderSpell()
        }
        self.spell_order = ['shield', 'swift', 'fireball', 'thunder']
        self.selected_spell = 0
    
    def get_current_spell(self):
        spell_name = self.spell_order[self.selected_spell]
        return self.spells[spell_name]
    
    def select_spell(self, index):
        if 0 <= index < len(self.spell_order):
            self.selected_spell = index
    
    def next_spell(self):
        self.selected_spell = (self.selected_spell + 1) % len(self.spell_order)
    
    def prev_spell(self):
        self.selected_spell = (self.selected_spell - 1) % len(self.spell_order)
    
    def cast_current_spell(self, caster, magic_points, facing_right=True):
        spell = self.get_current_spell()
        if spell.can_cast(magic_points):
            result = spell.cast(caster, facing_right=facing_right)
            if result:
                return spell.cost
        return 0
    
    def update(self):
        for spell in self.spells.values():
            spell.update()
    
    def draw(self, surface, player_pos):
        for spell in self.spells.values():
            spell.draw(surface, player_pos)
    
    def get_speed_multiplier(self):
        return self.spells['swift'].get_speed_multiplier()
    
    def get_jump_multiplier(self):
        return self.spells['swift'].get_jump_multiplier()
    
    def get_damage_multiplier(self):
        return self.spells['shield'].get_damage_multiplier()
    
    def get_active_buffs(self):
        """Return list of active buff names"""
        active = []
        if self.spells['shield'].active:
            active.append('shield')
        if self.spells['swift'].active:
            active.append('swift')
        return active
    
    def get_projectiles(self):
        """Return all active projectiles"""
        return self.spells['fireball'].get_projectiles()
    
    def get_effects(self):
        """Return all active effects (thunder)"""
        return self.spells['thunder'].get_effects()

```

```python
"""
Game settings and constants for Chain
"""

# Display settings
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60
TILE_SIZE = 32
PIXEL_SCALE = 2  # For that chunky 16-bit look

# Game title
TITLE = "Chain - Quest for the Lost Princess"

# Colors - 16-bit palette inspired
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
DARK_BLUE = (24, 20, 37)
NAVY = (38, 43, 68)
PURPLE = (58, 68, 102)
SLATE = (90, 105, 136)
LIGHT_SLATE = (139, 155, 180)
SKY_BLUE = (87, 114, 119)
TEAL = (62, 137, 137)
CYAN = (116, 196, 182)
MINT = (177, 220, 176)

RED = (172, 50, 50)
DARK_RED = (102, 46, 46)
ORANGE = (223, 113, 38)
YELLOW = (251, 191, 69)
CREAM = (247, 228, 182)

GREEN = (75, 105, 47)
DARK_GREEN = (55, 75, 37)
LIME = (106, 190, 48)

PINK = (215, 123, 186)
MAGENTA = (143, 77, 137)

BROWN = (102, 57, 49)
DARK_BROWN = (63, 40, 50)
TAN = (143, 86, 59)
BEIGE = (217, 160, 102)

GRAY = (89, 86, 82)
LIGHT_GRAY = (155, 156, 130)

# Player settings
PLAYER_SPEED = 4
PLAYER_JUMP_SPEED = -12
PLAYER_GRAVITY = 0.5
PLAYER_MAX_HEALTH = 4
PLAYER_MAX_MAGIC = 4
PLAYER_ATTACK_COOLDOWN = 30  # frames
PLAYER_INVINCIBILITY_FRAMES = 120  # 2 seconds at 60 FPS

# Spell costs
SPELL_COSTS = {
    'shield': 1,
    'swift': 1,
    'fireball': 2,
    'thunder': 3,
    'thunder2': 2
}

# Spell durations (in frames, for buffs)
SPELL_DURATIONS = {
    'shield': 300,  # 5 seconds
    'swift': 240,   # 4 seconds
}

# Buff effects
SHIELD_DAMAGE_REDUCTION = 0.5
SWIFT_SPEED_MULTIPLIER = 1.5
SWIFT_JUMP_MULTIPLIER = 1.3

# Projectile settings
FIREBALL_SPEED = 8
FIREBALL_DAMAGE = 2
THUNDER_RADIUS = 80
THUNDER_DAMAGE = 3

# Enemy settings
ENEMY_TYPES = {
    'slime': {
        'health': 2,
        'damage': 1,
        'speed': 1,
        'score': 10,
        'color': LIME
    },
    'bat': {
        'health': 1,
        'damage': 1,
        'speed': 2.5,
        'score': 20,
        'color': PURPLE
    },
    'knight': {
        'health': 4,
        'damage': 2,
        'speed': 1.5,
        'score': 50,
        'color': SLATE
    },
    'cannon': {
        'health': 20,
        'damage': 3,
        'speed': 2,
        'score': 500,
        'color': DARK_RED
    }
}

# Item settings
ITEM_TYPES = {
    'food': {
        'heal': 1,
        'color': ORANGE
    },
    'feast': {
        'heal': 2,
        'color': YELLOW
    },
    'magic_vial': {
        'restore': 1,
        'color': CYAN
    },
    'magic_potion': {
        'restore': 2,
        'color': TEAL
    },
    'heart_container': {
        'max_health_increase': 1,
        'color': RED
    },
    'magic_bottle': {
        'max_magic_increase': 1,
        'color': MAGENTA
    }
}

# World map settings
WORLD_MAP_WIDTH = 25
WORLD_MAP_HEIGHT = 19
WORLD_PLAYER_SPEED = 3

# Level types
LEVEL_FOREST = 'forest'
LEVEL_CAVE = 'cave'
LEVEL_CASTLE = 'castle'
LEVEL_BOSS = 'boss'

# Game states
STATE_MENU = 'menu'
STATE_WORLD_MAP = 'world_map'
STATE_LEVEL = 'level'
STATE_PAUSE = 'pause'
STATE_GAME_OVER = 'game_over'
STATE_VICTORY = 'victory'

```

```python
"""
Game settings and constants for Chain
"""

# Display settings
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
FPS = 60
TILE_SIZE = 32
PIXEL_SCALE = 2  # For that chunky 16-bit look

# Game title
TITLE = "Chain - Quest for the Lost Princess"

# Colors - 16-bit palette inspired
BLACK = (0, 0, 0)
WHITE = (255, 255, 255)
DARK_BLUE = (24, 20, 37)
NAVY = (38, 43, 68)
PURPLE = (58, 68, 102)
SLATE = (90, 105, 136)
LIGHT_SLATE = (139, 155, 180)
SKY_BLUE = (87, 114, 119)
TEAL = (62, 137, 137)
CYAN = (116, 196, 182)
MINT = (177, 220, 176)

RED = (172, 50, 50)
DARK_RED = (102, 46, 46)
ORANGE = (223, 113, 38)
YELLOW = (251, 191, 69)
CREAM = (247, 228, 182)

GREEN = (75, 105, 47)
DARK_GREEN = (55, 75, 37)
LIME = (106, 190, 48)

PINK = (215, 123, 186)
MAGENTA = (143, 77, 137)

BROWN = (102, 57, 49)
DARK_BROWN = (63, 40, 50)
TAN = (143, 86, 59)
BEIGE = (217, 160, 102)

GRAY = (89, 86, 82)
LIGHT_GRAY = (155, 156, 130)

# Player settings
PLAYER_SPEED = 4
PLAYER_JUMP_SPEED = -12
PLAYER_GRAVITY = 0.5
PLAYER_MAX_HEALTH = 4
PLAYER_MAX_MAGIC = 4
PLAYER_ATTACK_COOLDOWN = 30  # frames
PLAYER_INVINCIBILITY_FRAMES = 120  # 2 seconds at 60 FPS

# Spell costs
SPELL_COSTS = {
    'shield': 1,
    'swift': 1,
    'fireball': 2,
    'thunder': 3,
    'thunder2': 2
}

# Spell durations (in frames, for buffs)
SPELL_DURATIONS = {
    'shield': 300,  # 5 seconds
    'swift': 240,   # 4 seconds
}

# Buff effects
SHIELD_DAMAGE_REDUCTION = 0.5
SWIFT_SPEED_MULTIPLIER = 1.5
SWIFT_JUMP_MULTIPLIER = 1.3

# Projectile settings
FIREBALL_SPEED = 8
FIREBALL_DAMAGE = 2
THUNDER_RADIUS = 80
THUNDER_DAMAGE = 3
THUNDER2_DAMAGE = 4

# Enemy settings
ENEMY_TYPES = {
    'slime': {
        'health': 2,
        'damage': 1,
        'speed': 1,
        'score': 10,
        'color': LIME
    },
    'bat': {
        'health': 1,
        'damage': 1,
        'speed': 2.5,
        'score': 20,
        'color': PURPLE
    },
    'knight': {
        'health': 4,
        'damage': 2,
        'speed': 1.5,
        'score': 50,
        'color': SLATE
    },
    'cannon': {
        'health': 20,
        'damage': 3,
        'speed': 2,
        'score': 500,
        'color': DARK_RED
    }
}

# Item settings
ITEM_TYPES = {
    'food': {
        'heal': 1,
        'color': ORANGE
    },
    'feast': {
        'heal': 2,
        'color': YELLOW
    },
    'magic_vial': {
        'restore': 1,
        'color': CYAN
    },
    'magic_potion': {
        'restore': 2,
        'color': TEAL
    },
    'heart_container': {
        'max_health_increase': 1,
        'color': RED
    },
    'magic_bottle': {
        'max_magic_increase': 1,
        'color': MAGENTA
    }
}

# World map settings
WORLD_MAP_WIDTH = 25
WORLD_MAP_HEIGHT = 19
WORLD_PLAYER_SPEED = 3

# Level types
LEVEL_FOREST = 'forest'
LEVEL_CAVE = 'cave'
LEVEL_CASTLE = 'castle'
LEVEL_BOSS = 'boss'

# Game states
STATE_MENU = 'menu'
STATE_WORLD_MAP = 'world_map'
STATE_LEVEL = 'level'
STATE_PAUSE = 'pause'
STATE_GAME_OVER = 'game_over'
STATE_VICTORY = 'victory'

```

```python
"""
Spell system for Chain
"""

import pygame
import math
from settings import *
from sprites import create_fireball_sprite, create_thunder_sprite, create_shield_effect_sprite


class Spell:
    """Base spell class"""
    
    def __init__(self, name, cost, spell_type):
        self.name = name
        self.cost = cost
        self.spell_type = spell_type  # 'buff' or 'offensive'
        self.active = False
        self.duration = 0
        self.frame = 0
    
    def can_cast(self, magic_points):
        return magic_points >= self.cost
    
    def cast(self, caster, target_pos=None, facing_right=True):
        """Override in subclasses"""
        pass
    
    def update(self):
        self.frame += 1
    
    def draw(self, surface, pos):
        pass


class ShieldSpell(Spell):
    """Shield buff - reduces incoming damage"""
    
    def __init__(self):
        super().__init__('Shield', SPELL_COSTS['shield'], 'buff')
        self.duration = SPELL_DURATIONS['shield']
        self.remaining_duration = 0
    
    def cast(self, caster, target_pos=None, facing_right=True):
        self.active = True
        self.remaining_duration = self.duration
        return True
    
    def update(self):
        super().update()
        if self.active:
            self.remaining_duration -= 1
            if self.remaining_duration <= 0:
                self.active = False
    
    def get_damage_multiplier(self):
        if self.active:
            return SHIELD_DAMAGE_REDUCTION
        return 1.0
    
    def draw(self, surface, pos):
        if self.active:
            sprite = create_shield_effect_sprite(self.frame)
            # Center on player
            x = pos[0] - sprite.get_width() // 2
            y = pos[1] - sprite.get_height() // 2
            surface.blit(sprite, (x, y))


class SwiftSpell(Spell):
    """Swift buff - increases movement and jump speed"""
    
    def __init__(self):
        super().__init__('Swift', SPELL_COSTS['swift'], 'buff')
        self.duration = SPELL_DURATIONS['swift']
        self.remaining_duration = 0
        self.trail_particles = []  # Store particle positions
        self.last_pos = None
    
    def cast(self, caster, target_pos=None, facing_right=True):
        self.active = True
        self.remaining_duration = self.duration
        self.trail_particles = []
        return True
    
    def update(self):
        super().update()
        if self.active:
            self.remaining_duration -= 1
            if self.remaining_duration <= 0:
                self.active = False
                self.trail_particles = []
    
    def get_speed_multiplier(self):
        if self.active:
            return SWIFT_SPEED_MULTIPLIER
        return 1.0
    
    def get_jump_multiplier(self):
        if self.active:
            return SWIFT_JUMP_MULTIPLIER
        return 1.0
    
    def update_trail(self, current_pos):
        """Update trail particles based on player position"""
        if self.active:
            # Add new particle at current position
            self.trail_particles.append({
                'x': current_pos[0],
                'y': current_pos[1],
                'life': 15,
                'size': 8
            })
            # Update existing particles
            for particle in self.trail_particles:
                particle['life'] -= 1
                particle['size'] = max(2, particle['size'] - 0.3)
            # Remove dead particles
            self.trail_particles = [p for p in self.trail_particles if p['life'] > 0]
            # Limit particle count
            if len(self.trail_particles) > 20:
                self.trail_particles = self.trail_particles[-20:]
    
    def draw(self, surface, pos):
        if self.active:
            # Update trail with current position
            self.update_trail(pos)
            
            # Draw trail particles behind player (oldest first)
            colors = [CYAN, TEAL, MINT, WHITE]
            for i, particle in enumerate(self.trail_particles):
                alpha = int((particle['life'] / 15) * 200)
                color_idx = i % len(colors)
                color = colors[color_idx]
                size = int(particle['size'])
                pygame.draw.rect(surface, color, 
                               (int(particle['x']) - size//2, 
                                int(particle['y']) - size//2, 
                                size, size))


class Fireball(pygame.sprite.Sprite):
    """Fireball projectile"""
    
    def __init__(self, x, y, facing_right):
        super().__init__()
        self.frame = 0
        self.image = create_fireball_sprite(self.frame)
        self.rect = self.image.get_rect(center=(x, y))
        self.direction = 1 if facing_right else -1
        self.speed = FIREBALL_SPEED
        self.damage = FIREBALL_DAMAGE
        self.lifetime = 120  # frames
    
    def update(self):
        self.frame += 1
        self.rect.x += self.speed * self.direction
        self.image = create_fireball_sprite(self.frame)
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()


class FireballSpell(Spell):
    """Fireball offensive spell"""
    
    def __init__(self):
        super().__init__('Fireball', SPELL_COSTS['fireball'], 'offensive')
        self.projectiles = pygame.sprite.Group()
    
    def cast(self, caster, target_pos=None, facing_right=True):
        # Create fireball projectile
        fireball = Fireball(caster.rect.centerx, caster.rect.centery, facing_right)
        self.projectiles.add(fireball)
        return fireball
    
    def update(self):
        super().update()
        self.projectiles.update()
    
    def draw(self, surface, pos):
        self.projectiles.draw(surface)
    
    def get_projectiles(self):
        return self.projectiles


class ThunderEffect(pygame.sprite.Sprite):
    """Thunder area effect"""
    
    def __init__(self, x, y):
        super().__init__()
        self.frame = 0
        self.image = create_thunder_sprite(self.frame)
        self.rect = self.image.get_rect(center=(x, y))
        self.damage = THUNDER_DAMAGE
        self.radius = THUNDER_RADIUS
        self.lifetime = 30  # frames
        self.hit_enemies = set()  # Track which enemies have been hit
    
    def update(self):
        self.frame += 1
        self.image = create_thunder_sprite(self.frame)
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def can_hit(self, enemy):
        """Check if enemy is in range and hasn't been hit yet"""
        if enemy in self.hit_enemies:
            return False
        
        # Calculate distance
        dx = enemy.rect.centerx - self.rect.centerx
        dy = enemy.rect.centery - self.rect.centery
        distance = math.sqrt(dx * dx + dy * dy)
        
        if distance <= self.radius:
            self.hit_enemies.add(enemy)
            return True
        return False


class ThunderSpell(Spell):
    """Thunder area-of-effect offensive spell"""
    
    def __init__(self):
        super().__init__('Thunder', SPELL_COSTS['thunder'], 'offensive')
        self.effects = pygame.sprite.Group()
    
    def cast(self, caster, target_pos=None, facing_right=True):
        # Create thunder effect at player position
        offset = 50 if facing_right else -50
        thunder = ThunderEffect(caster.rect.centerx + offset, caster.rect.centery)
        self.effects.add(thunder)
        return thunder
    
    def update(self):
        super().update()
        self.effects.update()
    
    def draw(self, surface, pos):
        self.effects.draw(surface)
    
    def get_effects(self):
        return self.effects


class Thunder2Effect(pygame.sprite.Sprite):
    """Thunder 2.0 - strikes down from above"""
    
    def __init__(self, x, target_y):
        super().__init__()
        self.frame = 0
        self.x = x
        self.target_y = target_y
        self.current_y = target_y - 300  # Start from above
        self.damage = THUNDER2_DAMAGE
        self.width = 40
        self.height = 0
        self.lifetime = 45  # frames
        self.hit_enemies = set()
        self.striking = True
        
        # Create initial image
        self.update_image()
        self.rect = self.image.get_rect(midtop=(x, self.current_y))
    
    def update_image(self):
        """Create the lightning bolt image"""
        if self.striking:
            # Growing lightning bolt
            self.height = min(300, self.height + 25)
        
        self.image = pygame.Surface((self.width, max(10, self.height)), pygame.SRCALPHA)
        
        # Draw lightning bolt with zigzag pattern
        color = YELLOW if self.frame % 4 < 2 else WHITE
        core_color = WHITE if self.frame % 4 < 2 else YELLOW
        
        # Main bolt
        bolt_x = self.width // 2
        segments = max(1, self.height // 30)
        points = [(bolt_x, 0)]
        
        for i in range(segments):
            y = (i + 1) * (self.height // segments)
            x_offset = ((i % 2) * 2 - 1) * 8  # Zigzag
            points.append((bolt_x + x_offset, y))
        
        if len(points) >= 2:
            # Draw glow
            for offset in [-4, -2, 0, 2, 4]:
                glow_points = [(p[0] + offset, p[1]) for p in points]
                if len(glow_points) >= 2:
                    pygame.draw.lines(self.image, (*color[:3], 100), False, glow_points, 6)
            
            # Draw core
            pygame.draw.lines(self.image, core_color, False, points, 4)
            pygame.draw.lines(self.image, WHITE, False, points, 2)
    
    def update(self):
        self.frame += 1
        self.lifetime -= 1
        
        if self.striking and self.height >= 300:
            self.striking = False
        
        self.update_image()
        self.rect = self.image.get_rect(midtop=(self.x, self.target_y - self.height))
        
        if self.lifetime <= 0:
            self.kill()
    
    def can_hit(self, enemy):
        """Check if enemy is hit by the lightning"""
        if enemy in self.hit_enemies:
            return False
        
        # Check if enemy is within the bolt's path
        if (abs(enemy.rect.centerx - self.x) < 30 and
            enemy.rect.top < self.target_y and
            enemy.rect.bottom > self.target_y - self.height):
            self.hit_enemies.add(enemy)
            return True
        return False


class Thunder2Spell(Spell):
    """Thunder 2.0 - powerful downward strike"""
    
    def __init__(self):
        super().__init__('Thunder2', SPELL_COSTS['thunder2'], 'offensive')
        self.effects = pygame.sprite.Group()
    
    def cast(self, caster, target_pos=None, facing_right=True):
        # Create thunder strike in front of player
        offset = 60 if facing_right else -60
        thunder = Thunder2Effect(caster.rect.centerx + offset, caster.rect.bottom)
        self.effects.add(thunder)
        return thunder
    
    def update(self):
        super().update()
        self.effects.update()
    
    def draw(self, surface, pos):
        self.effects.draw(surface)
    
    def get_effects(self):
        return self.effects


class SpellManager:
    """Manages all spells for the player"""
    
    def __init__(self):
        self.spells = {
            'shield': ShieldSpell(),
            'swift': SwiftSpell(),
            'fireball': FireballSpell(),
            'thunder': ThunderSpell()
        }
        self.spell_order = ['shield', 'swift', 'fireball', 'thunder']
        self.selected_spell = 0
    
    def get_current_spell(self):
        spell_name = self.spell_order[self.selected_spell]
        return self.spells[spell_name]
    
    def select_spell(self, index):
        if 0 <= index < len(self.spell_order):
            self.selected_spell = index
    
    def next_spell(self):
        self.selected_spell = (self.selected_spell + 1) % len(self.spell_order)
    
    def prev_spell(self):
        self.selected_spell = (self.selected_spell - 1) % len(self.spell_order)
    
    def cast_current_spell(self, caster, magic_points, facing_right=True):
        spell = self.get_current_spell()
        if spell.can_cast(magic_points):
            result = spell.cast(caster, facing_right=facing_right)
            if result:
                return spell.cost
        return 0
    
    def update(self):
        for spell in self.spells.values():
            spell.update()
    
    def draw(self, surface, player_pos):
        for spell in self.spells.values():
            spell.draw(surface, player_pos)
    
    def get_speed_multiplier(self):
        return self.spells['swift'].get_speed_multiplier()
    
    def get_jump_multiplier(self):
        return self.spells['swift'].get_jump_multiplier()
    
    def get_damage_multiplier(self):
        return self.spells['shield'].get_damage_multiplier()
    
    def get_active_buffs(self):
        """Return list of active buff names"""
        active = []
        if self.spells['shield'].active:
            active.append('shield')
        if self.spells['swift'].active:
            active.append('swift')
        return active
    
    def get_projectiles(self):
        """Return all active projectiles"""
        return self.spells['fireball'].get_projectiles()
    
    def get_effects(self):
        """Return all active effects (thunder)"""
        return self.spells['thunder'].get_effects()

```

```python
"""
Spell system for Chain
"""

import pygame
import math
from settings import *
from sprites import create_fireball_sprite, create_thunder_sprite, create_shield_effect_sprite


class Spell:
    """Base spell class"""
    
    def __init__(self, name, cost, spell_type):
        self.name = name
        self.cost = cost
        self.spell_type = spell_type  # 'buff' or 'offensive'
        self.active = False
        self.duration = 0
        self.frame = 0
    
    def can_cast(self, magic_points):
        return magic_points >= self.cost
    
    def cast(self, caster, target_pos=None, facing_right=True):
        """Override in subclasses"""
        pass
    
    def update(self):
        self.frame += 1
    
    def draw(self, surface, pos):
        pass


class ShieldSpell(Spell):
    """Shield buff - reduces incoming damage"""
    
    def __init__(self):
        super().__init__('Shield', SPELL_COSTS['shield'], 'buff')
        self.duration = SPELL_DURATIONS['shield']
        self.remaining_duration = 0
    
    def cast(self, caster, target_pos=None, facing_right=True):
        self.active = True
        self.remaining_duration = self.duration
        return True
    
    def update(self):
        super().update()
        if self.active:
            self.remaining_duration -= 1
            if self.remaining_duration <= 0:
                self.active = False
    
    def get_damage_multiplier(self):
        if self.active:
            return SHIELD_DAMAGE_REDUCTION
        return 1.0
    
    def draw(self, surface, pos):
        if self.active:
            sprite = create_shield_effect_sprite(self.frame)
            # Center on player
            x = pos[0] - sprite.get_width() // 2
            y = pos[1] - sprite.get_height() // 2
            surface.blit(sprite, (x, y))


class SwiftSpell(Spell):
    """Swift buff - increases movement and jump speed"""
    
    def __init__(self):
        super().__init__('Swift', SPELL_COSTS['swift'], 'buff')
        self.duration = SPELL_DURATIONS['swift']
        self.remaining_duration = 0
        self.trail_particles = []  # Store particle positions
        self.last_pos = None
    
    def cast(self, caster, target_pos=None, facing_right=True):
        self.active = True
        self.remaining_duration = self.duration
        self.trail_particles = []
        return True
    
    def update(self):
        super().update()
        if self.active:
            self.remaining_duration -= 1
            if self.remaining_duration <= 0:
                self.active = False
                self.trail_particles = []
    
    def get_speed_multiplier(self):
        if self.active:
            return SWIFT_SPEED_MULTIPLIER
        return 1.0
    
    def get_jump_multiplier(self):
        if self.active:
            return SWIFT_JUMP_MULTIPLIER
        return 1.0
    
    def update_trail(self, current_pos):
        """Update trail particles based on player position"""
        if self.active:
            # Add new particle at current position
            self.trail_particles.append({
                'x': current_pos[0],
                'y': current_pos[1],
                'life': 15,
                'size': 8
            })
            # Update existing particles
            for particle in self.trail_particles:
                particle['life'] -= 1
                particle['size'] = max(2, particle['size'] - 0.3)
            # Remove dead particles
            self.trail_particles = [p for p in self.trail_particles if p['life'] > 0]
            # Limit particle count
            if len(self.trail_particles) > 20:
                self.trail_particles = self.trail_particles[-20:]
    
    def draw(self, surface, pos):
        if self.active:
            # Update trail with current position
            self.update_trail(pos)
            
            # Draw trail particles behind player (oldest first)
            colors = [CYAN, TEAL, MINT, WHITE]
            for i, particle in enumerate(self.trail_particles):
                alpha = int((particle['life'] / 15) * 200)
                color_idx = i % len(colors)
                color = colors[color_idx]
                size = int(particle['size'])
                pygame.draw.rect(surface, color, 
                               (int(particle['x']) - size//2, 
                                int(particle['y']) - size//2, 
                                size, size))


class Fireball(pygame.sprite.Sprite):
    """Fireball projectile"""
    
    def __init__(self, x, y, facing_right):
        super().__init__()
        self.frame = 0
        self.image = create_fireball_sprite(self.frame)
        self.rect = self.image.get_rect(center=(x, y))
        self.direction = 1 if facing_right else -1
        self.speed = FIREBALL_SPEED
        self.damage = FIREBALL_DAMAGE
        self.lifetime = 120  # frames
    
    def update(self):
        self.frame += 1
        self.rect.x += self.speed * self.direction
        self.image = create_fireball_sprite(self.frame)
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()


class FireballSpell(Spell):
    """Fireball offensive spell"""
    
    def __init__(self):
        super().__init__('Fireball', SPELL_COSTS['fireball'], 'offensive')
        self.projectiles = pygame.sprite.Group()
    
    def cast(self, caster, target_pos=None, facing_right=True):
        # Create fireball projectile
        fireball = Fireball(caster.rect.centerx, caster.rect.centery, facing_right)
        self.projectiles.add(fireball)
        return fireball
    
    def update(self):
        super().update()
        self.projectiles.update()
    
    def draw(self, surface, pos):
        self.projectiles.draw(surface)
    
    def get_projectiles(self):
        return self.projectiles


class ThunderEffect(pygame.sprite.Sprite):
    """Thunder area effect"""
    
    def __init__(self, x, y):
        super().__init__()
        self.frame = 0
        self.image = create_thunder_sprite(self.frame)
        self.rect = self.image.get_rect(center=(x, y))
        self.damage = THUNDER_DAMAGE
        self.radius = THUNDER_RADIUS
        self.lifetime = 30  # frames
        self.hit_enemies = set()  # Track which enemies have been hit
    
    def update(self):
        self.frame += 1
        self.image = create_thunder_sprite(self.frame)
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def can_hit(self, enemy):
        """Check if enemy is in range and hasn't been hit yet"""
        if enemy in self.hit_enemies:
            return False
        
        # Calculate distance
        dx = enemy.rect.centerx - self.rect.centerx
        dy = enemy.rect.centery - self.rect.centery
        distance = math.sqrt(dx * dx + dy * dy)
        
        if distance <= self.radius:
            self.hit_enemies.add(enemy)
            return True
        return False


class ThunderSpell(Spell):
    """Thunder area-of-effect offensive spell"""
    
    def __init__(self):
        super().__init__('Thunder', SPELL_COSTS['thunder'], 'offensive')
        self.effects = pygame.sprite.Group()
    
    def cast(self, caster, target_pos=None, facing_right=True):
        # Create thunder effect at player position
        offset = 50 if facing_right else -50
        thunder = ThunderEffect(caster.rect.centerx + offset, caster.rect.centery)
        self.effects.add(thunder)
        return thunder
    
    def update(self):
        super().update()
        self.effects.update()
    
    def draw(self, surface, pos):
        self.effects.draw(surface)
    
    def get_effects(self):
        return self.effects


class Thunder2Effect(pygame.sprite.Sprite):
    """Thunder 2.0 - strikes down from above"""
    
    def __init__(self, x, target_y):
        super().__init__()
        self.frame = 0
        self.x = x
        self.target_y = target_y
        self.current_y = target_y - 300  # Start from above
        self.damage = THUNDER2_DAMAGE
        self.width = 40
        self.height = 0
        self.lifetime = 45  # frames
        self.hit_enemies = set()
        self.striking = True
        
        # Create initial image
        self.update_image()
        self.rect = self.image.get_rect(midtop=(x, self.current_y))
    
    def update_image(self):
        """Create the lightning bolt image"""
        if self.striking:
            # Growing lightning bolt
            self.height = min(300, self.height + 25)
        
        self.image = pygame.Surface((self.width, max(10, self.height)), pygame.SRCALPHA)
        
        # Draw lightning bolt with zigzag pattern
        color = YELLOW if self.frame % 4 < 2 else WHITE
        core_color = WHITE if self.frame % 4 < 2 else YELLOW
        
        # Main bolt
        bolt_x = self.width // 2
        segments = max(1, self.height // 30)
        points = [(bolt_x, 0)]
        
        for i in range(segments):
            y = (i + 1) * (self.height // segments)
            x_offset = ((i % 2) * 2 - 1) * 8  # Zigzag
            points.append((bolt_x + x_offset, y))
        
        if len(points) >= 2:
            # Draw glow
            for offset in [-4, -2, 0, 2, 4]:
                glow_points = [(p[0] + offset, p[1]) for p in points]
                if len(glow_points) >= 2:
                    pygame.draw.lines(self.image, (*color[:3], 100), False, glow_points, 6)
            
            # Draw core
            pygame.draw.lines(self.image, core_color, False, points, 4)
            pygame.draw.lines(self.image, WHITE, False, points, 2)
    
    def update(self):
        self.frame += 1
        self.lifetime -= 1
        
        if self.striking and self.height >= 300:
            self.striking = False
        
        self.update_image()
        self.rect = self.image.get_rect(midtop=(self.x, self.target_y - self.height))
        
        if self.lifetime <= 0:
            self.kill()
    
    def can_hit(self, enemy):
        """Check if enemy is hit by the lightning"""
        if enemy in self.hit_enemies:
            return False
        
        # Check if enemy is within the bolt's path
        if (abs(enemy.rect.centerx - self.x) < 30 and
            enemy.rect.top < self.target_y and
            enemy.rect.bottom > self.target_y - self.height):
            self.hit_enemies.add(enemy)
            return True
        return False


class Thunder2Spell(Spell):
    """Thunder 2.0 - powerful downward strike"""
    
    def __init__(self):
        super().__init__('Thunder2', SPELL_COSTS['thunder2'], 'offensive')
        self.effects = pygame.sprite.Group()
    
    def cast(self, caster, target_pos=None, facing_right=True):
        # Create thunder strike in front of player
        offset = 60 if facing_right else -60
        thunder = Thunder2Effect(caster.rect.centerx + offset, caster.rect.bottom)
        self.effects.add(thunder)
        return thunder
    
    def update(self):
        super().update()
        self.effects.update()
    
    def draw(self, surface, pos):
        self.effects.draw(surface)
    
    def get_effects(self):
        return self.effects


class SpellManager:
    """Manages all spells for the player"""
    
    def __init__(self):
        self.spells = {
            'shield': ShieldSpell(),
            'swift': SwiftSpell(),
            'fireball': FireballSpell(),
            'thunder': ThunderSpell(),
            'thunder2': Thunder2Spell()
        }
        self.spell_order = ['shield', 'swift', 'fireball', 'thunder', 'thunder2']
        self.selected_spell = 0
    
    def get_current_spell(self):
        spell_name = self.spell_order[self.selected_spell]
        return self.spells[spell_name]
    
    def select_spell(self, index):
        if 0 <= index < len(self.spell_order):
            self.selected_spell = index
    
    def next_spell(self):
        self.selected_spell = (self.selected_spell + 1) % len(self.spell_order)
    
    def prev_spell(self):
        self.selected_spell = (self.selected_spell - 1) % len(self.spell_order)
    
    def cast_current_spell(self, caster, magic_points, facing_right=True):
        spell = self.get_current_spell()
        if spell.can_cast(magic_points):
            result = spell.cast(caster, facing_right=facing_right)
            if result:
                return spell.cost
        return 0
    
    def update(self):
        for spell in self.spells.values():
            spell.update()
    
    def draw(self, surface, player_pos):
        for spell in self.spells.values():
            spell.draw(surface, player_pos)
    
    def get_speed_multiplier(self):
        return self.spells['swift'].get_speed_multiplier()
    
    def get_jump_multiplier(self):
        return self.spells['swift'].get_jump_multiplier()
    
    def get_damage_multiplier(self):
        return self.spells['shield'].get_damage_multiplier()
    
    def get_active_buffs(self):
        """Return list of active buff names"""
        active = []
        if self.spells['shield'].active:
            active.append('shield')
        if self.spells['swift'].active:
            active.append('swift')
        return active
    
    def get_projectiles(self):
        """Return all active projectiles"""
        return self.spells['fireball'].get_projectiles()
    
    def get_effects(self):
        """Return all active effects (thunder)"""
        return self.spells['thunder'].get_effects()

```

```python
"""
Spell system for Chain
"""

import pygame
import math
from settings import *
from sprites import create_fireball_sprite, create_thunder_sprite, create_shield_effect_sprite


class Spell:
    """Base spell class"""
    
    def __init__(self, name, cost, spell_type):
        self.name = name
        self.cost = cost
        self.spell_type = spell_type  # 'buff' or 'offensive'
        self.active = False
        self.duration = 0
        self.frame = 0
    
    def can_cast(self, magic_points):
        return magic_points >= self.cost
    
    def cast(self, caster, target_pos=None, facing_right=True):
        """Override in subclasses"""
        pass
    
    def update(self):
        self.frame += 1
    
    def draw(self, surface, pos):
        pass


class ShieldSpell(Spell):
    """Shield buff - reduces incoming damage"""
    
    def __init__(self):
        super().__init__('Shield', SPELL_COSTS['shield'], 'buff')
        self.duration = SPELL_DURATIONS['shield']
        self.remaining_duration = 0
    
    def cast(self, caster, target_pos=None, facing_right=True):
        self.active = True
        self.remaining_duration = self.duration
        return True
    
    def update(self):
        super().update()
        if self.active:
            self.remaining_duration -= 1
            if self.remaining_duration <= 0:
                self.active = False
    
    def get_damage_multiplier(self):
        if self.active:
            return SHIELD_DAMAGE_REDUCTION
        return 1.0
    
    def draw(self, surface, pos):
        if self.active:
            sprite = create_shield_effect_sprite(self.frame)
            # Center on player
            x = pos[0] - sprite.get_width() // 2
            y = pos[1] - sprite.get_height() // 2
            surface.blit(sprite, (x, y))


class SwiftSpell(Spell):
    """Swift buff - increases movement and jump speed"""
    
    def __init__(self):
        super().__init__('Swift', SPELL_COSTS['swift'], 'buff')
        self.duration = SPELL_DURATIONS['swift']
        self.remaining_duration = 0
        self.trail_particles = []  # Store particle positions
        self.last_pos = None
    
    def cast(self, caster, target_pos=None, facing_right=True):
        self.active = True
        self.remaining_duration = self.duration
        self.trail_particles = []
        return True
    
    def update(self):
        super().update()
        if self.active:
            self.remaining_duration -= 1
            if self.remaining_duration <= 0:
                self.active = False
                self.trail_particles = []
    
    def get_speed_multiplier(self):
        if self.active:
            return SWIFT_SPEED_MULTIPLIER
        return 1.0
    
    def get_jump_multiplier(self):
        if self.active:
            return SWIFT_JUMP_MULTIPLIER
        return 1.0
    
    def update_trail(self, current_pos):
        """Update trail particles based on player position"""
        if self.active:
            # Add new particle at current position
            self.trail_particles.append({
                'x': current_pos[0],
                'y': current_pos[1],
                'life': 15,
                'size': 8
            })
            # Update existing particles
            for particle in self.trail_particles:
                particle['life'] -= 1
                particle['size'] = max(2, particle['size'] - 0.3)
            # Remove dead particles
            self.trail_particles = [p for p in self.trail_particles if p['life'] > 0]
            # Limit particle count
            if len(self.trail_particles) > 20:
                self.trail_particles = self.trail_particles[-20:]
    
    def draw(self, surface, pos):
        if self.active:
            # Update trail with current position
            self.update_trail(pos)
            
            # Draw trail particles behind player (oldest first)
            colors = [CYAN, TEAL, MINT, WHITE]
            for i, particle in enumerate(self.trail_particles):
                alpha = int((particle['life'] / 15) * 200)
                color_idx = i % len(colors)
                color = colors[color_idx]
                size = int(particle['size'])
                pygame.draw.rect(surface, color, 
                               (int(particle['x']) - size//2, 
                                int(particle['y']) - size//2, 
                                size, size))


class Fireball(pygame.sprite.Sprite):
    """Fireball projectile"""
    
    def __init__(self, x, y, facing_right):
        super().__init__()
        self.frame = 0
        self.image = create_fireball_sprite(self.frame)
        self.rect = self.image.get_rect(center=(x, y))
        self.direction = 1 if facing_right else -1
        self.speed = FIREBALL_SPEED
        self.damage = FIREBALL_DAMAGE
        self.lifetime = 120  # frames
    
    def update(self):
        self.frame += 1
        self.rect.x += self.speed * self.direction
        self.image = create_fireball_sprite(self.frame)
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()


class FireballSpell(Spell):
    """Fireball offensive spell"""
    
    def __init__(self):
        super().__init__('Fireball', SPELL_COSTS['fireball'], 'offensive')
        self.projectiles = pygame.sprite.Group()
    
    def cast(self, caster, target_pos=None, facing_right=True):
        # Create fireball projectile
        fireball = Fireball(caster.rect.centerx, caster.rect.centery, facing_right)
        self.projectiles.add(fireball)
        return fireball
    
    def update(self):
        super().update()
        self.projectiles.update()
    
    def draw(self, surface, pos):
        self.projectiles.draw(surface)
    
    def get_projectiles(self):
        return self.projectiles


class ThunderEffect(pygame.sprite.Sprite):
    """Thunder area effect"""
    
    def __init__(self, x, y):
        super().__init__()
        self.frame = 0
        self.image = create_thunder_sprite(self.frame)
        self.rect = self.image.get_rect(center=(x, y))
        self.damage = THUNDER_DAMAGE
        self.radius = THUNDER_RADIUS
        self.lifetime = 30  # frames
        self.hit_enemies = set()  # Track which enemies have been hit
    
    def update(self):
        self.frame += 1
        self.image = create_thunder_sprite(self.frame)
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def can_hit(self, enemy):
        """Check if enemy is in range and hasn't been hit yet"""
        if enemy in self.hit_enemies:
            return False
        
        # Calculate distance
        dx = enemy.rect.centerx - self.rect.centerx
        dy = enemy.rect.centery - self.rect.centery
        distance = math.sqrt(dx * dx + dy * dy)
        
        if distance <= self.radius:
            self.hit_enemies.add(enemy)
            return True
        return False


class ThunderSpell(Spell):
    """Thunder area-of-effect offensive spell"""
    
    def __init__(self):
        super().__init__('Thunder', SPELL_COSTS['thunder'], 'offensive')
        self.effects = pygame.sprite.Group()
    
    def cast(self, caster, target_pos=None, facing_right=True):
        # Create thunder effect at player position
        offset = 50 if facing_right else -50
        thunder = ThunderEffect(caster.rect.centerx + offset, caster.rect.centery)
        self.effects.add(thunder)
        return thunder
    
    def update(self):
        super().update()
        self.effects.update()
    
    def draw(self, surface, pos):
        self.effects.draw(surface)
    
    def get_effects(self):
        return self.effects


class Thunder2Effect(pygame.sprite.Sprite):
    """Thunder 2.0 - strikes down from above"""
    
    def __init__(self, x, target_y):
        super().__init__()
        self.frame = 0
        self.x = x
        self.target_y = target_y
        self.current_y = target_y - 300  # Start from above
        self.damage = THUNDER2_DAMAGE
        self.width = 40
        self.height = 0
        self.lifetime = 45  # frames
        self.hit_enemies = set()
        self.striking = True
        
        # Create initial image
        self.update_image()
        self.rect = self.image.get_rect(midtop=(x, self.current_y))
    
    def update_image(self):
        """Create the lightning bolt image"""
        if self.striking:
            # Growing lightning bolt
            self.height = min(300, self.height + 25)
        
        self.image = pygame.Surface((self.width, max(10, self.height)), pygame.SRCALPHA)
        
        # Draw lightning bolt with zigzag pattern
        color = YELLOW if self.frame % 4 < 2 else WHITE
        core_color = WHITE if self.frame % 4 < 2 else YELLOW
        
        # Main bolt
        bolt_x = self.width // 2
        segments = max(1, self.height // 30)
        points = [(bolt_x, 0)]
        
        for i in range(segments):
            y = (i + 1) * (self.height // segments)
            x_offset = ((i % 2) * 2 - 1) * 8  # Zigzag
            points.append((bolt_x + x_offset, y))
        
        if len(points) >= 2:
            # Draw glow
            for offset in [-4, -2, 0, 2, 4]:
                glow_points = [(p[0] + offset, p[1]) for p in points]
                if len(glow_points) >= 2:
                    pygame.draw.lines(self.image, (*color[:3], 100), False, glow_points, 6)
            
            # Draw core
            pygame.draw.lines(self.image, core_color, False, points, 4)
            pygame.draw.lines(self.image, WHITE, False, points, 2)
    
    def update(self):
        self.frame += 1
        self.lifetime -= 1
        
        if self.striking and self.height >= 300:
            self.striking = False
        
        self.update_image()
        self.rect = self.image.get_rect(midtop=(self.x, self.target_y - self.height))
        
        if self.lifetime <= 0:
            self.kill()
    
    def can_hit(self, enemy):
        """Check if enemy is hit by the lightning"""
        if enemy in self.hit_enemies:
            return False
        
        # Check if enemy is within the bolt's path
        if (abs(enemy.rect.centerx - self.x) < 30 and
            enemy.rect.top < self.target_y and
            enemy.rect.bottom > self.target_y - self.height):
            self.hit_enemies.add(enemy)
            return True
        return False


class Thunder2Spell(Spell):
    """Thunder 2.0 - powerful downward strike"""
    
    def __init__(self):
        super().__init__('Thunder2', SPELL_COSTS['thunder2'], 'offensive')
        self.effects = pygame.sprite.Group()
    
    def cast(self, caster, target_pos=None, facing_right=True):
        # Create thunder strike in front of player
        offset = 60 if facing_right else -60
        thunder = Thunder2Effect(caster.rect.centerx + offset, caster.rect.bottom)
        self.effects.add(thunder)
        return thunder
    
    def update(self):
        super().update()
        self.effects.update()
    
    def draw(self, surface, pos):
        self.effects.draw(surface)
    
    def get_effects(self):
        return self.effects


class SpellManager:
    """Manages all spells for the player"""
    
    def __init__(self):
        self.spells = {
            'shield': ShieldSpell(),
            'swift': SwiftSpell(),
            'fireball': FireballSpell(),
            'thunder': ThunderSpell(),
            'thunder2': Thunder2Spell()
        }
        self.spell_order = ['shield', 'swift', 'fireball', 'thunder', 'thunder2']
        self.selected_spell = 0
    
    def get_current_spell(self):
        spell_name = self.spell_order[self.selected_spell]
        return self.spells[spell_name]
    
    def select_spell(self, index):
        if 0 <= index < len(self.spell_order):
            self.selected_spell = index
    
    def next_spell(self):
        self.selected_spell = (self.selected_spell + 1) % len(self.spell_order)
    
    def prev_spell(self):
        self.selected_spell = (self.selected_spell - 1) % len(self.spell_order)
    
    def cast_current_spell(self, caster, magic_points, facing_right=True):
        spell = self.get_current_spell()
        if spell.can_cast(magic_points):
            result = spell.cast(caster, facing_right=facing_right)
            if result:
                return spell.cost
        return 0
    
    def update(self):
        for spell in self.spells.values():
            spell.update()
    
    def draw(self, surface, player_pos):
        for spell in self.spells.values():
            spell.draw(surface, player_pos)
    
    def get_speed_multiplier(self):
        return self.spells['swift'].get_speed_multiplier()
    
    def get_jump_multiplier(self):
        return self.spells['swift'].get_jump_multiplier()
    
    def get_damage_multiplier(self):
        return self.spells['shield'].get_damage_multiplier()
    
    def get_active_buffs(self):
        """Return list of active buff names"""
        active = []
        if self.spells['shield'].active:
            active.append('shield')
        if self.spells['swift'].active:
            active.append('swift')
        return active
    
    def get_projectiles(self):
        """Return all active projectiles"""
        return self.spells['fireball'].get_projectiles()
    
    def get_effects(self):
        """Return all active effects (thunder and thunder2)"""
        # Combine effects from both thunder spells
        all_effects = pygame.sprite.Group()
        for effect in self.spells['thunder'].get_effects():
            all_effects.add(effect)
        for effect in self.spells['thunder2'].get_effects():
            all_effects.add(effect)
        return all_effects

```

Now let me update the UI to show 5 spells:

```python
"""
User Interface elements for Chain
"""

import pygame
from settings import *
from sprites import create_heart_sprite, create_magic_sprite


class UI:
    """Handles all UI rendering"""
    
    def __init__(self):
        # Initialize font
        pygame.font.init()
        self.font_large = pygame.font.Font(None, 56)
        self.font_medium = pygame.font.Font(None, 36)
        self.font_small = pygame.font.Font(None, 28)
        self.font_tiny = pygame.font.Font(None, 22)
        
        # Cache sprites and scale them up for prominence
        heart_full = create_heart_sprite(full=True)
        heart_empty = create_heart_sprite(full=False)
        magic_full = create_magic_sprite(full=True)
        magic_empty = create_magic_sprite(full=False)
        
        # Scale up HUD sprites by 1.5x for better visibility
        scale = 1.5
        self.heart_full = pygame.transform.scale(heart_full, 
            (int(heart_full.get_width() * scale), int(heart_full.get_height() * scale)))
        self.heart_empty = pygame.transform.scale(heart_empty, 
            (int(heart_empty.get_width() * scale), int(heart_empty.get_height() * scale)))
        self.magic_full = pygame.transform.scale(magic_full, 
            (int(magic_full.get_width() * scale), int(magic_full.get_height() * scale)))
        self.magic_empty = pygame.transform.scale(magic_empty, 
            (int(magic_empty.get_width() * scale), int(magic_empty.get_height() * scale)))
        
        # Spell icons
        self.spell_names = ['Shield', 'Swift', 'Fireball', 'Thunder', 'Thundr2']
        self.spell_colors = [CYAN, LIME, ORANGE, YELLOW, MAGENTA]
    
    def draw_health_bar(self, surface, current, maximum, x=16, y=16):
        """Draw health hearts with background panel"""
        # Calculate panel size
        heart_w = self.heart_full.get_width()
        heart_h = self.heart_full.get_height()
        panel_width = maximum * (heart_w + 6) + 20
        panel_height = heart_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, RED, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("HP", True, RED)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw hearts
        for i in range(maximum):
            if i < current:
                sprite = self.heart_full
            else:
                sprite = self.heart_empty
            
            surface.blit(sprite, (x + 24 + i * (heart_w + 6), y))
    
    def draw_magic_bar(self, surface, current, maximum, x=16, y=60):
        """Draw magic crystals with background panel"""
        # Calculate panel size
        magic_w = self.magic_full.get_width()
        magic_h = self.magic_full.get_height()
        panel_width = maximum * (magic_w + 6) + 20
        panel_height = magic_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, CYAN, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("MP", True, CYAN)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw crystals
        for i in range(maximum):
            if i < current:
                sprite = self.magic_full
            else:
                sprite = self.magic_empty
            
            surface.blit(sprite, (x + 24 + i * (magic_w + 6), y))
    
    def draw_spell_selector(self, surface, selected_spell, spell_manager, x=16, y=110):
        """Draw spell selection UI with background panel"""
        slot_width = 60
        slot_height = 50
        panel_width = 4 * slot_width + 30
        panel_height = slot_height + 40
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, YELLOW, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("SPELLS", True, YELLOW)
        surface.blit(label, (x, y - 6))
        
        for i, (name, color) in enumerate(zip(self.spell_names, self.spell_colors)):
            # Draw slot background
            slot_x = x + i * slot_width + 4
            slot_y = y + 12
            
            # Draw slot base
            pygame.draw.rect(surface, DARK_BROWN, (slot_x, slot_y, slot_width - 8, slot_height - 10))
            
            # Highlight selected with glow effect
            if i == selected_spell:
                pygame.draw.rect(surface, color, (slot_x - 3, slot_y - 3, slot_width - 2, slot_height - 4), 3)
                pygame.draw.rect(surface, WHITE, (slot_x, slot_y, slot_width - 8, slot_height - 10), 1)
            
            # Draw spell icon area
            pygame.draw.rect(surface, color, (slot_x + 4, slot_y + 4, slot_width - 16, 24))
            
            # Draw spell initial
            spell_text = self.font_medium.render(name[0], True, DARK_BLUE)
            surface.blit(spell_text, (slot_x + 14, slot_y + 6))
            
            # Draw spell number
            num_text = self.font_tiny.render(str(i + 1), True, LIGHT_GRAY)
            surface.blit(num_text, (slot_x + 20, slot_y + 30))
        
        # Show active buffs below spell bar
        active_buffs = spell_manager.get_active_buffs()
        if active_buffs:
            buff_y = y + panel_height - 4
            pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, buff_y, panel_width, 24))
            buff_x = x
            for buff in active_buffs:
                buff_color = CYAN if buff == 'shield' else LIME
                pygame.draw.rect(surface, buff_color, (buff_x, buff_y + 4, 12, 12))
                buff_text = self.font_tiny.render(buff.upper(), True, buff_color)
                surface.blit(buff_text, (buff_x + 16, buff_y + 4))
                buff_x += 80
    
    def draw_score(self, surface, score, x=None, y=16):
        """Draw score with background panel"""
        if x is None:
            x = SCREEN_WIDTH - 180
        
        score_str = f"SCORE: {score:,}"
        text_width = self.font_medium.size(score_str)[0]
        panel_width = text_width + 24
        panel_height = 40
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, YELLOW, (x - 8, y - 8, panel_width, panel_height), 2)
        
        score_text = self.font_medium.render(score_str, True, YELLOW)
        surface.blit(score_text, (x + 4, y + 2))
    
    def draw_level_name(self, surface, name, x=None, y=None):
        """Draw level name at top center with prominent styling"""
        if x is None:
            x = SCREEN_WIDTH // 2
        if y is None:
            y = 24
        
        text = self.font_medium.render(name, True, WHITE)
        text_rect = text.get_rect(center=(x, y))
        
        # Background panel
        panel_rect = pygame.Rect(text_rect.x - 16, text_rect.y - 8, 
                                 text_rect.width + 32, text_rect.height + 16)
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 220), panel_rect)
        pygame.draw.rect(surface, WHITE, panel_rect, 2)
        pygame.draw.rect(surface, YELLOW, panel_rect.inflate(-4, -4), 1)
        
        surface.blit(text, text_rect)
    
    def draw_dialog(self, surface, text, speaker=None):
        """Draw dialog box at bottom of screen"""
        box_height = 100
        box_y = SCREEN_HEIGHT - box_height - 20
        
        # Draw box
        pygame.draw.rect(surface, DARK_BLUE, (20, box_y, SCREEN_WIDTH - 40, box_height))
        pygame.draw.rect(surface, WHITE, (20, box_y, SCREEN_WIDTH - 40, box_height), 2)
        
        # Draw speaker name
        if speaker:
            name_text = self.font_medium.render(speaker, True, YELLOW)
            surface.blit(name_text, (40, box_y + 10))
            text_y = box_y + 40
        else:
            text_y = box_y + 20
        
        # Draw text (word wrap)
        words = text.split()
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + word + " "
            if self.font_medium.size(test_line)[0] < SCREEN_WIDTH - 80:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word + " "
        lines.append(current_line)
        
        for i, line in enumerate(lines):
            line_text = self.font_medium.render(line, True, WHITE)
            surface.blit(line_text, (40, text_y + i * 25))
    
    def draw_menu(self, surface, title, options, selected):
        """Draw a menu screen"""
        # Title
        title_text = self.font_large.render(title, True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 150))
        surface.blit(title_text, title_rect)
        
        # Options
        for i, option in enumerate(options):
            if i == selected:
                color = YELLOW
                prefix = "> "
            else:
                color = WHITE
                prefix = "  "
            
            option_text = self.font_medium.render(prefix + option, True, color)
            option_rect = option_text.get_rect(center=(SCREEN_WIDTH // 2, 250 + i * 50))
            surface.blit(option_text, option_rect)
    
    def draw_game_over(self, surface, score):
        """Draw game over screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Game Over text
        text = self.font_large.render("GAME OVER", True, RED)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        surface.blit(text, text_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 80))
        surface.blit(inst_text, inst_rect)
    
    def draw_victory(self, surface, score):
        """Draw victory screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Victory text
        text = self.font_large.render("VICTORY!", True, YELLOW)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 80))
        surface.blit(text, text_rect)
        
        # Story
        story = self.font_medium.render("You saved the Princess!", True, MINT)
        story_rect = story.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20))
        surface.blit(story, story_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 100))
        surface.blit(inst_text, inst_rect)
    
    def draw_pause(self, surface):
        """Draw pause overlay"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 128))
        surface.blit(overlay, (0, 0))
        
        # Pause text
        text = self.font_large.render("PAUSED", True, WHITE)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30))
        surface.blit(text, text_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ESC to resume", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30))
        surface.blit(inst_text, inst_rect)
    
    def draw_hud(self, surface, player):
        """Draw the full HUD"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_spell_selector(surface, player.spell_manager.selected_spell, 
                                player.spell_manager)
        self.draw_score(surface, player.score)
    
    def draw_world_map_hud(self, surface, player, current_location):
        """Draw HUD for world map"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_score(surface, player.score)
        
        # Location name with prominent panel
        if current_location:
            loc_text = self.font_medium.render(current_location, True, WHITE)
            loc_rect = loc_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 35))
            
            panel_rect = pygame.Rect(loc_rect.x - 20, loc_rect.y - 10,
                                    loc_rect.width + 40, loc_rect.height + 20)
            pygame.draw.rect(surface, (*DARK_BLUE[:3], 230), panel_rect)
            pygame.draw.rect(surface, YELLOW, panel_rect, 3)
            pygame.draw.rect(surface, WHITE, panel_rect.inflate(-4, -4), 1)
            
            surface.blit(loc_text, loc_rect)
    
    def draw_controls_help(self, surface):
        """Draw controls help"""
        controls = [
            "Arrow Keys/WASD: Move",
            "Space: Jump",
            "Z: Attack",
            "X: Cast Spell",
            "1-4: Select Spell",
            "Enter: Interact",
            "ESC: Pause"
        ]
        
        y = SCREEN_HEIGHT - len(controls) * 20 - 20
        for control in controls:
            text = self.font_small.render(control, True, LIGHT_GRAY)
            surface.blit(text, (SCREEN_WIDTH - 180, y))
            y += 20

```

```python
"""
User Interface elements for Chain
"""

import pygame
from settings import *
from sprites import create_heart_sprite, create_magic_sprite


class UI:
    """Handles all UI rendering"""
    
    def __init__(self):
        # Initialize font
        pygame.font.init()
        self.font_large = pygame.font.Font(None, 56)
        self.font_medium = pygame.font.Font(None, 36)
        self.font_small = pygame.font.Font(None, 28)
        self.font_tiny = pygame.font.Font(None, 22)
        
        # Cache sprites and scale them up for prominence
        heart_full = create_heart_sprite(full=True)
        heart_empty = create_heart_sprite(full=False)
        magic_full = create_magic_sprite(full=True)
        magic_empty = create_magic_sprite(full=False)
        
        # Scale up HUD sprites by 1.5x for better visibility
        scale = 1.5
        self.heart_full = pygame.transform.scale(heart_full, 
            (int(heart_full.get_width() * scale), int(heart_full.get_height() * scale)))
        self.heart_empty = pygame.transform.scale(heart_empty, 
            (int(heart_empty.get_width() * scale), int(heart_empty.get_height() * scale)))
        self.magic_full = pygame.transform.scale(magic_full, 
            (int(magic_full.get_width() * scale), int(magic_full.get_height() * scale)))
        self.magic_empty = pygame.transform.scale(magic_empty, 
            (int(magic_empty.get_width() * scale), int(magic_empty.get_height() * scale)))
        
        # Spell icons
        self.spell_names = ['Shield', 'Swift', 'Fireball', 'Thunder', 'Thundr2']
        self.spell_colors = [CYAN, LIME, ORANGE, YELLOW, MAGENTA]
    
    def draw_health_bar(self, surface, current, maximum, x=16, y=16):
        """Draw health hearts with background panel"""
        # Calculate panel size
        heart_w = self.heart_full.get_width()
        heart_h = self.heart_full.get_height()
        panel_width = maximum * (heart_w + 6) + 20
        panel_height = heart_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, RED, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("HP", True, RED)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw hearts
        for i in range(maximum):
            if i < current:
                sprite = self.heart_full
            else:
                sprite = self.heart_empty
            
            surface.blit(sprite, (x + 24 + i * (heart_w + 6), y))
    
    def draw_magic_bar(self, surface, current, maximum, x=16, y=60):
        """Draw magic crystals with background panel"""
        # Calculate panel size
        magic_w = self.magic_full.get_width()
        magic_h = self.magic_full.get_height()
        panel_width = maximum * (magic_w + 6) + 20
        panel_height = magic_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, CYAN, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("MP", True, CYAN)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw crystals
        for i in range(maximum):
            if i < current:
                sprite = self.magic_full
            else:
                sprite = self.magic_empty
            
            surface.blit(sprite, (x + 24 + i * (magic_w + 6), y))
    
    def draw_spell_selector(self, surface, selected_spell, spell_manager, x=16, y=110):
        """Draw spell selection UI with background panel"""
        slot_width = 52
        slot_height = 50
        panel_width = 5 * slot_width + 30
        panel_height = slot_height + 40
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, YELLOW, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("SPELLS", True, YELLOW)
        surface.blit(label, (x, y - 6))
        
        for i, (name, color) in enumerate(zip(self.spell_names, self.spell_colors)):
            # Draw slot background
            slot_x = x + i * slot_width + 4
            slot_y = y + 12
            
            # Draw slot base
            pygame.draw.rect(surface, DARK_BROWN, (slot_x, slot_y, slot_width - 8, slot_height - 10))
            
            # Highlight selected with glow effect
            if i == selected_spell:
                pygame.draw.rect(surface, color, (slot_x - 3, slot_y - 3, slot_width - 2, slot_height - 4), 3)
                pygame.draw.rect(surface, WHITE, (slot_x, slot_y, slot_width - 8, slot_height - 10), 1)
            
            # Draw spell icon area
            pygame.draw.rect(surface, color, (slot_x + 4, slot_y + 4, slot_width - 16, 24))
            
            # Draw spell initial
            spell_text = self.font_medium.render(name[0], True, DARK_BLUE)
            surface.blit(spell_text, (slot_x + 14, slot_y + 6))
            
            # Draw spell number
            num_text = self.font_tiny.render(str(i + 1), True, LIGHT_GRAY)
            surface.blit(num_text, (slot_x + 20, slot_y + 30))
        
        # Show active buffs below spell bar
        active_buffs = spell_manager.get_active_buffs()
        if active_buffs:
            buff_y = y + panel_height - 4
            pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, buff_y, panel_width, 24))
            buff_x = x
            for buff in active_buffs:
                buff_color = CYAN if buff == 'shield' else LIME
                pygame.draw.rect(surface, buff_color, (buff_x, buff_y + 4, 12, 12))
                buff_text = self.font_tiny.render(buff.upper(), True, buff_color)
                surface.blit(buff_text, (buff_x + 16, buff_y + 4))
                buff_x += 80
    
    def draw_score(self, surface, score, x=None, y=16):
        """Draw score with background panel"""
        if x is None:
            x = SCREEN_WIDTH - 180
        
        score_str = f"SCORE: {score:,}"
        text_width = self.font_medium.size(score_str)[0]
        panel_width = text_width + 24
        panel_height = 40
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, YELLOW, (x - 8, y - 8, panel_width, panel_height), 2)
        
        score_text = self.font_medium.render(score_str, True, YELLOW)
        surface.blit(score_text, (x + 4, y + 2))
    
    def draw_level_name(self, surface, name, x=None, y=None):
        """Draw level name at top center with prominent styling"""
        if x is None:
            x = SCREEN_WIDTH // 2
        if y is None:
            y = 24
        
        text = self.font_medium.render(name, True, WHITE)
        text_rect = text.get_rect(center=(x, y))
        
        # Background panel
        panel_rect = pygame.Rect(text_rect.x - 16, text_rect.y - 8, 
                                 text_rect.width + 32, text_rect.height + 16)
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 220), panel_rect)
        pygame.draw.rect(surface, WHITE, panel_rect, 2)
        pygame.draw.rect(surface, YELLOW, panel_rect.inflate(-4, -4), 1)
        
        surface.blit(text, text_rect)
    
    def draw_dialog(self, surface, text, speaker=None):
        """Draw dialog box at bottom of screen"""
        box_height = 100
        box_y = SCREEN_HEIGHT - box_height - 20
        
        # Draw box
        pygame.draw.rect(surface, DARK_BLUE, (20, box_y, SCREEN_WIDTH - 40, box_height))
        pygame.draw.rect(surface, WHITE, (20, box_y, SCREEN_WIDTH - 40, box_height), 2)
        
        # Draw speaker name
        if speaker:
            name_text = self.font_medium.render(speaker, True, YELLOW)
            surface.blit(name_text, (40, box_y + 10))
            text_y = box_y + 40
        else:
            text_y = box_y + 20
        
        # Draw text (word wrap)
        words = text.split()
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + word + " "
            if self.font_medium.size(test_line)[0] < SCREEN_WIDTH - 80:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word + " "
        lines.append(current_line)
        
        for i, line in enumerate(lines):
            line_text = self.font_medium.render(line, True, WHITE)
            surface.blit(line_text, (40, text_y + i * 25))
    
    def draw_menu(self, surface, title, options, selected):
        """Draw a menu screen"""
        # Title
        title_text = self.font_large.render(title, True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 150))
        surface.blit(title_text, title_rect)
        
        # Options
        for i, option in enumerate(options):
            if i == selected:
                color = YELLOW
                prefix = "> "
            else:
                color = WHITE
                prefix = "  "
            
            option_text = self.font_medium.render(prefix + option, True, color)
            option_rect = option_text.get_rect(center=(SCREEN_WIDTH // 2, 250 + i * 50))
            surface.blit(option_text, option_rect)
    
    def draw_game_over(self, surface, score):
        """Draw game over screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Game Over text
        text = self.font_large.render("GAME OVER", True, RED)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        surface.blit(text, text_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 80))
        surface.blit(inst_text, inst_rect)
    
    def draw_victory(self, surface, score):
        """Draw victory screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Victory text
        text = self.font_large.render("VICTORY!", True, YELLOW)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 80))
        surface.blit(text, text_rect)
        
        # Story
        story = self.font_medium.render("You saved the Princess!", True, MINT)
        story_rect = story.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20))
        surface.blit(story, story_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 100))
        surface.blit(inst_text, inst_rect)
    
    def draw_pause(self, surface):
        """Draw pause overlay"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 128))
        surface.blit(overlay, (0, 0))
        
        # Pause text
        text = self.font_large.render("PAUSED", True, WHITE)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30))
        surface.blit(text, text_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ESC to resume", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30))
        surface.blit(inst_text, inst_rect)
    
    def draw_hud(self, surface, player):
        """Draw the full HUD"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_spell_selector(surface, player.spell_manager.selected_spell, 
                                player.spell_manager)
        self.draw_score(surface, player.score)
    
    def draw_world_map_hud(self, surface, player, current_location):
        """Draw HUD for world map"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_score(surface, player.score)
        
        # Location name with prominent panel
        if current_location:
            loc_text = self.font_medium.render(current_location, True, WHITE)
            loc_rect = loc_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 35))
            
            panel_rect = pygame.Rect(loc_rect.x - 20, loc_rect.y - 10,
                                    loc_rect.width + 40, loc_rect.height + 20)
            pygame.draw.rect(surface, (*DARK_BLUE[:3], 230), panel_rect)
            pygame.draw.rect(surface, YELLOW, panel_rect, 3)
            pygame.draw.rect(surface, WHITE, panel_rect.inflate(-4, -4), 1)
            
            surface.blit(loc_text, loc_rect)
    
    def draw_controls_help(self, surface):
        """Draw controls help"""
        controls = [
            "Arrow Keys/WASD: Move",
            "Space: Jump",
            "Z: Attack",
            "X: Cast Spell",
            "1-4: Select Spell",
            "Enter: Interact",
            "ESC: Pause"
        ]
        
        y = SCREEN_HEIGHT - len(controls) * 20 - 20
        for control in controls:
            text = self.font_small.render(control, True, LIGHT_GRAY)
            surface.blit(text, (SCREEN_WIDTH - 180, y))
            y += 20

```

```python
"""
User Interface elements for Chain
"""

import pygame
from settings import *
from sprites import create_heart_sprite, create_magic_sprite


class UI:
    """Handles all UI rendering"""
    
    def __init__(self):
        # Initialize font
        pygame.font.init()
        self.font_large = pygame.font.Font(None, 56)
        self.font_medium = pygame.font.Font(None, 36)
        self.font_small = pygame.font.Font(None, 28)
        self.font_tiny = pygame.font.Font(None, 22)
        
        # Cache sprites and scale them up for prominence
        heart_full = create_heart_sprite(full=True)
        heart_empty = create_heart_sprite(full=False)
        magic_full = create_magic_sprite(full=True)
        magic_empty = create_magic_sprite(full=False)
        
        # Scale up HUD sprites by 1.5x for better visibility
        scale = 1.5
        self.heart_full = pygame.transform.scale(heart_full, 
            (int(heart_full.get_width() * scale), int(heart_full.get_height() * scale)))
        self.heart_empty = pygame.transform.scale(heart_empty, 
            (int(heart_empty.get_width() * scale), int(heart_empty.get_height() * scale)))
        self.magic_full = pygame.transform.scale(magic_full, 
            (int(magic_full.get_width() * scale), int(magic_full.get_height() * scale)))
        self.magic_empty = pygame.transform.scale(magic_empty, 
            (int(magic_empty.get_width() * scale), int(magic_empty.get_height() * scale)))
        
        # Spell icons
        self.spell_names = ['Shield', 'Swift', 'Fireball', 'Thunder', 'Thundr2']
        self.spell_colors = [CYAN, LIME, ORANGE, YELLOW, MAGENTA]
    
    def draw_health_bar(self, surface, current, maximum, x=16, y=16):
        """Draw health hearts with background panel"""
        # Calculate panel size
        heart_w = self.heart_full.get_width()
        heart_h = self.heart_full.get_height()
        panel_width = maximum * (heart_w + 6) + 20
        panel_height = heart_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, RED, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("HP", True, RED)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw hearts
        for i in range(maximum):
            if i < current:
                sprite = self.heart_full
            else:
                sprite = self.heart_empty
            
            surface.blit(sprite, (x + 24 + i * (heart_w + 6), y))
    
    def draw_magic_bar(self, surface, current, maximum, x=16, y=60):
        """Draw magic crystals with background panel"""
        # Calculate panel size
        magic_w = self.magic_full.get_width()
        magic_h = self.magic_full.get_height()
        panel_width = maximum * (magic_w + 6) + 20
        panel_height = magic_h + 16
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, CYAN, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("MP", True, CYAN)
        surface.blit(label, (x - 4, y - 6))
        
        # Draw crystals
        for i in range(maximum):
            if i < current:
                sprite = self.magic_full
            else:
                sprite = self.magic_empty
            
            surface.blit(sprite, (x + 24 + i * (magic_w + 6), y))
    
    def draw_spell_selector(self, surface, selected_spell, spell_manager, x=16, y=110):
        """Draw spell selection UI with background panel"""
        slot_width = 52
        slot_height = 50
        panel_width = 5 * slot_width + 30
        panel_height = slot_height + 40
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, YELLOW, (x - 8, y - 8, panel_width, panel_height), 2)
        
        # Draw label
        label = self.font_tiny.render("SPELLS", True, YELLOW)
        surface.blit(label, (x, y - 6))
        
        for i, (name, color) in enumerate(zip(self.spell_names, self.spell_colors)):
            # Draw slot background
            slot_x = x + i * slot_width + 4
            slot_y = y + 12
            
            # Draw slot base
            pygame.draw.rect(surface, DARK_BROWN, (slot_x, slot_y, slot_width - 8, slot_height - 10))
            
            # Highlight selected with glow effect
            if i == selected_spell:
                pygame.draw.rect(surface, color, (slot_x - 3, slot_y - 3, slot_width - 2, slot_height - 4), 3)
                pygame.draw.rect(surface, WHITE, (slot_x, slot_y, slot_width - 8, slot_height - 10), 1)
            
            # Draw spell icon area
            pygame.draw.rect(surface, color, (slot_x + 4, slot_y + 4, slot_width - 16, 24))
            
            # Draw spell initial/abbreviation
            if name == 'Thundr2':
                spell_text = self.font_small.render("T2", True, DARK_BLUE)
                surface.blit(spell_text, (slot_x + 10, slot_y + 8))
            else:
                spell_text = self.font_medium.render(name[0], True, DARK_BLUE)
                surface.blit(spell_text, (slot_x + 12, slot_y + 6))
            
            # Draw spell number
            num_text = self.font_tiny.render(str(i + 1), True, LIGHT_GRAY)
            surface.blit(num_text, (slot_x + 16, slot_y + 30))
        
        # Show active buffs below spell bar
        active_buffs = spell_manager.get_active_buffs()
        if active_buffs:
            buff_y = y + panel_height - 4
            pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, buff_y, panel_width, 24))
            buff_x = x
            for buff in active_buffs:
                buff_color = CYAN if buff == 'shield' else LIME
                pygame.draw.rect(surface, buff_color, (buff_x, buff_y + 4, 12, 12))
                buff_text = self.font_tiny.render(buff.upper(), True, buff_color)
                surface.blit(buff_text, (buff_x + 16, buff_y + 4))
                buff_x += 80
    
    def draw_score(self, surface, score, x=None, y=16):
        """Draw score with background panel"""
        if x is None:
            x = SCREEN_WIDTH - 180
        
        score_str = f"SCORE: {score:,}"
        text_width = self.font_medium.size(score_str)[0]
        panel_width = text_width + 24
        panel_height = 40
        
        # Draw panel background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), (x - 8, y - 8, panel_width, panel_height))
        pygame.draw.rect(surface, YELLOW, (x - 8, y - 8, panel_width, panel_height), 2)
        
        score_text = self.font_medium.render(score_str, True, YELLOW)
        surface.blit(score_text, (x + 4, y + 2))
    
    def draw_level_name(self, surface, name, x=None, y=None):
        """Draw level name at top center with prominent styling"""
        if x is None:
            x = SCREEN_WIDTH // 2
        if y is None:
            y = 24
        
        text = self.font_medium.render(name, True, WHITE)
        text_rect = text.get_rect(center=(x, y))
        
        # Background panel
        panel_rect = pygame.Rect(text_rect.x - 16, text_rect.y - 8, 
                                 text_rect.width + 32, text_rect.height + 16)
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 220), panel_rect)
        pygame.draw.rect(surface, WHITE, panel_rect, 2)
        pygame.draw.rect(surface, YELLOW, panel_rect.inflate(-4, -4), 1)
        
        surface.blit(text, text_rect)
    
    def draw_dialog(self, surface, text, speaker=None):
        """Draw dialog box at bottom of screen"""
        box_height = 100
        box_y = SCREEN_HEIGHT - box_height - 20
        
        # Draw box
        pygame.draw.rect(surface, DARK_BLUE, (20, box_y, SCREEN_WIDTH - 40, box_height))
        pygame.draw.rect(surface, WHITE, (20, box_y, SCREEN_WIDTH - 40, box_height), 2)
        
        # Draw speaker name
        if speaker:
            name_text = self.font_medium.render(speaker, True, YELLOW)
            surface.blit(name_text, (40, box_y + 10))
            text_y = box_y + 40
        else:
            text_y = box_y + 20
        
        # Draw text (word wrap)
        words = text.split()
        lines = []
        current_line = ""
        
        for word in words:
            test_line = current_line + word + " "
            if self.font_medium.size(test_line)[0] < SCREEN_WIDTH - 80:
                current_line = test_line
            else:
                lines.append(current_line)
                current_line = word + " "
        lines.append(current_line)
        
        for i, line in enumerate(lines):
            line_text = self.font_medium.render(line, True, WHITE)
            surface.blit(line_text, (40, text_y + i * 25))
    
    def draw_menu(self, surface, title, options, selected):
        """Draw a menu screen"""
        # Title
        title_text = self.font_large.render(title, True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 150))
        surface.blit(title_text, title_rect)
        
        # Options
        for i, option in enumerate(options):
            if i == selected:
                color = YELLOW
                prefix = "> "
            else:
                color = WHITE
                prefix = "  "
            
            option_text = self.font_medium.render(prefix + option, True, color)
            option_rect = option_text.get_rect(center=(SCREEN_WIDTH // 2, 250 + i * 50))
            surface.blit(option_text, option_rect)
    
    def draw_game_over(self, surface, score):
        """Draw game over screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Game Over text
        text = self.font_large.render("GAME OVER", True, RED)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
        surface.blit(text, text_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 20))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 80))
        surface.blit(inst_text, inst_rect)
    
    def draw_victory(self, surface, score):
        """Draw victory screen"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        surface.blit(overlay, (0, 0))
        
        # Victory text
        text = self.font_large.render("VICTORY!", True, YELLOW)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 80))
        surface.blit(text, text_rect)
        
        # Story
        story = self.font_medium.render("You saved the Princess!", True, MINT)
        story_rect = story.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 20))
        surface.blit(story, story_rect)
        
        # Score
        score_text = self.font_medium.render(f"Final Score: {score}", True, WHITE)
        score_rect = score_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 40))
        surface.blit(score_text, score_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ENTER to return to menu", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 100))
        surface.blit(inst_text, inst_rect)
    
    def draw_pause(self, surface):
        """Draw pause overlay"""
        # Darken background
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 128))
        surface.blit(overlay, (0, 0))
        
        # Pause text
        text = self.font_large.render("PAUSED", True, WHITE)
        text_rect = text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 30))
        surface.blit(text, text_rect)
        
        # Instructions
        inst_text = self.font_small.render("Press ESC to resume", True, LIGHT_GRAY)
        inst_rect = inst_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 30))
        surface.blit(inst_text, inst_rect)
    
    def draw_hud(self, surface, player):
        """Draw the full HUD"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_spell_selector(surface, player.spell_manager.selected_spell, 
                                player.spell_manager)
        self.draw_score(surface, player.score)
    
    def draw_world_map_hud(self, surface, player, current_location):
        """Draw HUD for world map"""
        self.draw_health_bar(surface, player.health, player.max_health)
        self.draw_magic_bar(surface, player.magic, player.max_magic)
        self.draw_score(surface, player.score)
        
        # Location name with prominent panel
        if current_location:
            loc_text = self.font_medium.render(current_location, True, WHITE)
            loc_rect = loc_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 35))
            
            panel_rect = pygame.Rect(loc_rect.x - 20, loc_rect.y - 10,
                                    loc_rect.width + 40, loc_rect.height + 20)
            pygame.draw.rect(surface, (*DARK_BLUE[:3], 230), panel_rect)
            pygame.draw.rect(surface, YELLOW, panel_rect, 3)
            pygame.draw.rect(surface, WHITE, panel_rect.inflate(-4, -4), 1)
            
            surface.blit(loc_text, loc_rect)
    
    def draw_controls_help(self, surface):
        """Draw controls help"""
        controls = [
            "Arrow Keys/WASD: Move",
            "Space: Jump",
            "Z: Attack",
            "X: Cast Spell",
            "1-4: Select Spell",
            "Enter: Interact",
            "ESC: Pause"
        ]
        
        y = SCREEN_HEIGHT - len(controls) * 20 - 20
        for control in controls:
            text = self.font_small.render(control, True, LIGHT_GRAY)
            surface.blit(text, (SCREEN_WIDTH - 180, y))
            y += 20

```

Now let me add the up slash attack to the player:

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import create_chain_sprite, create_chain_attack_sprite, create_chain_world_sprite
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-4)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import create_chain_sprite, create_chain_attack_sprite, create_chain_world_sprite
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up for up-slash)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-4)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import create_chain_sprite, create_chain_attack_sprite, create_chain_world_sprite
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up for up-slash)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import create_chain_sprite, create_chain_attack_sprite, create_chain_world_sprite
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up for up-slash)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
                self.is_up_attack = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import create_chain_sprite, create_chain_attack_sprite, create_chain_world_sprite
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up for up-slash)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
                self.is_up_attack = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        # Up slash attack
        if self.is_up_attack:
            return pygame.Rect(
                self.rect.centerx - 15,
                self.rect.top - 35,
                30,
                40
            )
        
        # Normal horizontal attack
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

Now let me add the up slash sprite:

```python
"""
Sprite rendering utilities for 16-bit pixel art style
"""

import pygame
from settings import *


def create_pixel_surface(width, height, scale=PIXEL_SCALE):
    """Create a surface for pixel art that will be scaled up"""
    return pygame.Surface((width, height), pygame.SRCALPHA)


def create_chain_up_attack_sprite(facing_right=True):
    """Create Chain's up-slash attack sprite"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    offset_x = 4
    
    # Body
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (offset_x + 4, 10, 8, 7))
    
    # Head (looking up slightly)
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (offset_x + 5, 6, 6, 5))
    
    # Hair
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (offset_x + 5, 5, 6, 2))
    
    # Eyes (looking up)
    eye_color = DARK_BLUE
    pygame.draw.rect(surface, eye_color, (offset_x + 6, 7, 1, 1))
    pygame.draw.rect(surface, eye_color, (offset_x + 9, 7, 1, 1))
    
    # Legs
    leg_color = BROWN
    pygame.draw.rect(surface, leg_color, (offset_x + 5, 17, 2, 3))
    pygame.draw.rect(surface, leg_color, (offset_x + 9, 17, 2, 3))
    
    # Arms raised up
    pygame.draw.rect(surface, skin_color, (offset_x + 3, 8, 2, 4))
    pygame.draw.rect(surface, skin_color, (offset_x + 11, 8, 2, 4))
    
    # Sword pointing up
    sword_color = LIGHT_SLATE
    sword_handle = BROWN
    pygame.draw.rect(surface, sword_handle, (offset_x + 6, 4, 4, 3))
    pygame.draw.rect(surface, sword_color, (offset_x + 7, 0, 2, 5))
    pygame.draw.rect(surface, YELLOW, (offset_x + 5, 3, 6, 1))  # Guard
    
    # Slash effect
    pygame.draw.rect(surface, WHITE, (offset_x + 4, 0, 1, 4))
    pygame.draw.rect(surface, WHITE, (offset_x + 11, 0, 1, 4))
    
    return scale_surface(surface)


def _create_pixel_surface(width, height, scale=PIXEL_SCALE):
    """Create a surface for pixel art that will be scaled up"""
    return pygame.Surface((width, height), pygame.SRCALPHA)


def scale_surface(surface, scale=PIXEL_SCALE):
    """Scale a surface up for that chunky 16-bit look"""
    w, h = surface.get_size()
    return pygame.transform.scale(surface, (w * scale, h * scale))


def draw_pixel_rect(surface, color, rect, scale=1):
    """Draw a rectangle with pixel-perfect edges"""
    pygame.draw.rect(surface, color, rect)


def create_chain_sprite(facing_right=True, frame=0):
    """Create Chain's sprite - the hero"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    # Body (tunic)
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (4, 6, 8, 7))
    
    # Head
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (5, 2, 6, 5))
    
    # Hair (blue-ish)
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (5, 1, 6, 2))
    pygame.draw.rect(surface, hair_color, (4, 2, 1, 2))
    if facing_right:
        pygame.draw.rect(surface, hair_color, (11, 2, 1, 3))
    else:
        pygame.draw.rect(surface, hair_color, (4, 2, 1, 3))
    
    # Eyes
    eye_color = DARK_BLUE
    if facing_right:
        pygame.draw.rect(surface, eye_color, (9, 4, 1, 1))
    else:
        pygame.draw.rect(surface, eye_color, (6, 4, 1, 1))
    
    # Legs (animated)
    leg_color = BROWN
    if frame % 2 == 0:
        pygame.draw.rect(surface, leg_color, (5, 13, 2, 3))
        pygame.draw.rect(surface, leg_color, (9, 13, 2, 3))
    else:
        pygame.draw.rect(surface, leg_color, (4, 13, 2, 3))
        pygame.draw.rect(surface, leg_color, (10, 13, 2, 3))
    
    # Boots
    boot_color = DARK_BROWN
    if frame % 2 == 0:
        pygame.draw.rect(surface, boot_color, (5, 15, 2, 1))
        pygame.draw.rect(surface, boot_color, (9, 15, 2, 1))
    else:
        pygame.draw.rect(surface, boot_color, (4, 15, 2, 1))
        pygame.draw.rect(surface, boot_color, (10, 15, 2, 1))
    
    # Belt
    belt_color = BROWN
    pygame.draw.rect(surface, belt_color, (4, 10, 8, 1))
    
    # Belt buckle (chain link symbol)
    pygame.draw.rect(surface, YELLOW, (7, 10, 2, 1))
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_chain_attack_sprite(facing_right=True):
    """Create Chain's attack sprite with sword"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    # Base character (offset to make room for sword)
    offset_x = 4 if facing_right else 4
    
    # Body
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (offset_x + 4, 6, 8, 7))
    
    # Head
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (offset_x + 5, 2, 6, 5))
    
    # Hair
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (offset_x + 5, 1, 6, 2))
    
    # Eyes
    eye_color = DARK_BLUE
    if facing_right:
        pygame.draw.rect(surface, eye_color, (offset_x + 9, 4, 1, 1))
    else:
        pygame.draw.rect(surface, eye_color, (offset_x + 6, 4, 1, 1))
    
    # Legs
    leg_color = BROWN
    pygame.draw.rect(surface, leg_color, (offset_x + 5, 13, 2, 3))
    pygame.draw.rect(surface, leg_color, (offset_x + 9, 13, 2, 3))
    
    # Sword
    sword_color = LIGHT_SLATE
    sword_handle = BROWN
    if facing_right:
        pygame.draw.rect(surface, sword_handle, (offset_x + 12, 6, 2, 3))
        pygame.draw.rect(surface, sword_color, (offset_x + 14, 4, 6, 2))
        pygame.draw.rect(surface, YELLOW, (offset_x + 12, 5, 3, 1))  # Guard
    else:
        pygame.draw.rect(surface, sword_handle, (offset_x - 2, 6, 2, 3))
        pygame.draw.rect(surface, sword_color, (offset_x - 8, 4, 6, 2))
        pygame.draw.rect(surface, YELLOW, (offset_x - 3, 5, 3, 1))  # Guard
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_slime_sprite(frame=0):
    """Create slime enemy sprite"""
    size = 12
    surface = create_pixel_surface(size, size)
    
    color = LIME
    dark = DARK_GREEN
    
    # Body (bouncy animation)
    if frame % 20 < 10:
        pygame.draw.rect(surface, dark, (1, 6, 10, 6))
        pygame.draw.rect(surface, color, (2, 4, 8, 6))
        pygame.draw.rect(surface, color, (3, 3, 6, 2))
    else:
        pygame.draw.rect(surface, dark, (0, 8, 12, 4))
        pygame.draw.rect(surface, color, (1, 6, 10, 4))
        pygame.draw.rect(surface, color, (2, 5, 8, 2))
    
    # Eyes
    pygame.draw.rect(surface, WHITE, (3, 5, 2, 2))
    pygame.draw.rect(surface, WHITE, (7, 5, 2, 2))
    pygame.draw.rect(surface, BLACK, (4, 6, 1, 1))
    pygame.draw.rect(surface, BLACK, (8, 6, 1, 1))
    
    return scale_surface(surface)


def create_bat_sprite(frame=0):
    """Create bat enemy sprite"""
    size = 14
    surface = create_pixel_surface(size, size)
    
    color = PURPLE
    dark = DARK_BLUE
    
    # Body
    pygame.draw.rect(surface, color, (5, 5, 4, 5))
    pygame.draw.rect(surface, dark, (6, 4, 2, 2))
    
    # Wings (animated)
    if frame % 10 < 5:
        # Wings up
        pygame.draw.rect(surface, color, (0, 3, 5, 3))
        pygame.draw.rect(surface, color, (9, 3, 5, 3))
        pygame.draw.rect(surface, color, (1, 2, 3, 2))
        pygame.draw.rect(surface, color, (10, 2, 3, 2))
    else:
        # Wings down
        pygame.draw.rect(surface, color, (0, 6, 5, 3))
        pygame.draw.rect(surface, color, (9, 6, 5, 3))
        pygame.draw.rect(surface, color, (1, 8, 3, 2))
        pygame.draw.rect(surface, color, (10, 8, 3, 2))
    
    # Eyes (red, menacing)
    pygame.draw.rect(surface, RED, (5, 5, 1, 1))
    pygame.draw.rect(surface, RED, (8, 5, 1, 1))
    
    # Ears
    pygame.draw.rect(surface, color, (5, 3, 1, 2))
    pygame.draw.rect(surface, color, (8, 3, 1, 2))
    
    return scale_surface(surface)


def create_knight_sprite(facing_right=True, frame=0):
    """Create knight enemy sprite - armored and tough"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    armor_color = SLATE
    armor_dark = GRAY
    visor_color = DARK_BLUE
    
    # Body (armor)
    pygame.draw.rect(surface, armor_dark, (4, 6, 8, 7))
    pygame.draw.rect(surface, armor_color, (5, 5, 6, 6))
    
    # Helmet
    pygame.draw.rect(surface, armor_dark, (4, 1, 8, 5))
    pygame.draw.rect(surface, armor_color, (5, 2, 6, 3))
    
    # Visor
    pygame.draw.rect(surface, visor_color, (6, 3, 4, 2))
    pygame.draw.rect(surface, RED, (7, 3, 1, 1))  # Glowing eye
    pygame.draw.rect(surface, RED, (9, 3, 1, 1))  # Glowing eye
    
    # Shield
    if facing_right:
        pygame.draw.rect(surface, armor_dark, (2, 6, 3, 5))
        pygame.draw.rect(surface, armor_color, (2, 7, 2, 3))
    else:
        pygame.draw.rect(surface, armor_dark, (11, 6, 3, 5))
        pygame.draw.rect(surface, armor_color, (12, 7, 2, 3))
    
    # Sword
    sword_color = LIGHT_SLATE
    if facing_right:
        pygame.draw.rect(surface, sword_color, (12, 4, 2, 6))
        pygame.draw.rect(surface, sword_color, (13, 2, 1, 3))
    else:
        pygame.draw.rect(surface, sword_color, (2, 4, 2, 6))
        pygame.draw.rect(surface, sword_color, (2, 2, 1, 3))
    
    # Legs (armored)
    if frame % 2 == 0:
        pygame.draw.rect(surface, armor_dark, (5, 13, 2, 3))
        pygame.draw.rect(surface, armor_dark, (9, 13, 2, 3))
    else:
        pygame.draw.rect(surface, armor_dark, (4, 13, 2, 3))
        pygame.draw.rect(surface, armor_dark, (10, 13, 2, 3))
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_cannon_sprite(frame=0):
    """Create Cannon (boss) sprite - the archenemy"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    # Cape
    cape_color = DARK_RED
    pygame.draw.rect(surface, cape_color, (2, 6, 20, 14))
    pygame.draw.rect(surface, RED, (4, 8, 16, 10))
    
    # Body (dark armor)
    armor_color = DARK_BLUE
    armor_accent = NAVY
    pygame.draw.rect(surface, armor_color, (7, 6, 10, 10))
    pygame.draw.rect(surface, armor_accent, (8, 7, 8, 8))
    
    # Head (helmet with crown)
    pygame.draw.rect(surface, armor_color, (8, 1, 8, 6))
    pygame.draw.rect(surface, DARK_RED, (9, 3, 6, 3))  # Visor
    
    # Crown spikes
    pygame.draw.rect(surface, YELLOW, (8, 0, 2, 2))
    pygame.draw.rect(surface, YELLOW, (11, 0, 2, 1))
    pygame.draw.rect(surface, YELLOW, (14, 0, 2, 2))
    
    # Evil eyes
    pygame.draw.rect(surface, YELLOW, (10, 3, 1, 1))
    pygame.draw.rect(surface, YELLOW, (13, 3, 1, 1))
    
    # Cannon arm (signature weapon)
    cannon_color = GRAY
    if frame % 30 < 15:
        pygame.draw.rect(surface, cannon_color, (17, 8, 6, 4))
        pygame.draw.rect(surface, DARK_BROWN, (16, 9, 2, 2))
        pygame.draw.rect(surface, ORANGE, (22, 9, 2, 2))  # Charging
    else:
        pygame.draw.rect(surface, cannon_color, (17, 8, 6, 4))
        pygame.draw.rect(surface, DARK_BROWN, (16, 9, 2, 2))
    
    # Legs
    pygame.draw.rect(surface, armor_color, (8, 16, 3, 6))
    pygame.draw.rect(surface, armor_color, (13, 16, 3, 6))
    pygame.draw.rect(surface, DARK_BROWN, (8, 21, 3, 2))
    pygame.draw.rect(surface, DARK_BROWN, (13, 21, 3, 2))
    
    return scale_surface(surface)


def create_heart_sprite(full=True, is_container=False):
    """Create heart sprite for health display"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if is_container:
        color = YELLOW
        outline = ORANGE
    elif full:
        color = RED
        outline = DARK_RED
    else:
        color = GRAY
        outline = DARK_BROWN
    
    # Heart shape
    pygame.draw.rect(surface, outline, (1, 2, 3, 3))
    pygame.draw.rect(surface, outline, (6, 2, 3, 3))
    pygame.draw.rect(surface, outline, (0, 3, 2, 3))
    pygame.draw.rect(surface, outline, (8, 3, 2, 3))
    pygame.draw.rect(surface, outline, (2, 5, 6, 3))
    pygame.draw.rect(surface, outline, (3, 8, 4, 1))
    pygame.draw.rect(surface, outline, (4, 9, 2, 1))
    
    # Fill
    pygame.draw.rect(surface, color, (2, 3, 2, 2))
    pygame.draw.rect(surface, color, (6, 3, 2, 2))
    pygame.draw.rect(surface, color, (1, 4, 2, 2))
    pygame.draw.rect(surface, color, (7, 4, 2, 2))
    pygame.draw.rect(surface, color, (3, 5, 4, 2))
    pygame.draw.rect(surface, color, (4, 7, 2, 1))
    
    # Highlight
    if full or is_container:
        pygame.draw.rect(surface, WHITE, (2, 3, 1, 1))
    
    return scale_surface(surface)


def create_magic_sprite(full=True, is_bottle=False):
    """Create magic point sprite (star/crystal)"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if is_bottle:
        color = MAGENTA
        outline = PURPLE
    elif full:
        color = CYAN
        outline = TEAL
    else:
        color = GRAY
        outline = DARK_BROWN
    
    # Crystal/star shape
    pygame.draw.rect(surface, outline, (4, 0, 2, 2))
    pygame.draw.rect(surface, outline, (3, 2, 4, 2))
    pygame.draw.rect(surface, outline, (0, 3, 10, 2))
    pygame.draw.rect(surface, outline, (2, 5, 6, 2))
    pygame.draw.rect(surface, outline, (3, 7, 4, 2))
    pygame.draw.rect(surface, outline, (4, 9, 2, 1))
    
    # Fill
    pygame.draw.rect(surface, color, (4, 1, 2, 1))
    pygame.draw.rect(surface, color, (3, 3, 4, 1))
    pygame.draw.rect(surface, color, (1, 4, 8, 1))
    pygame.draw.rect(surface, color, (3, 5, 4, 1))
    pygame.draw.rect(surface, color, (4, 6, 2, 2))
    
    # Highlight
    if full or is_bottle:
        pygame.draw.rect(surface, WHITE, (4, 3, 1, 1))
    
    return scale_surface(surface)


def create_food_sprite(food_type='food'):
    """Create food item sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if food_type == 'feast':
        # Roasted chicken leg
        pygame.draw.rect(surface, TAN, (2, 2, 6, 5))
        pygame.draw.rect(surface, BEIGE, (3, 3, 4, 3))
        pygame.draw.rect(surface, BROWN, (1, 6, 2, 3))  # Bone
        pygame.draw.rect(surface, CREAM, (1, 8, 2, 1))
    else:
        # Apple
        pygame.draw.rect(surface, RED, (2, 3, 6, 5))
        pygame.draw.rect(surface, RED, (3, 2, 4, 1))
        pygame.draw.rect(surface, DARK_RED, (2, 6, 6, 2))
        pygame.draw.rect(surface, BROWN, (4, 0, 2, 3))  # Stem
        pygame.draw.rect(surface, GREEN, (5, 1, 2, 2))  # Leaf
        pygame.draw.rect(surface, WHITE, (3, 3, 1, 1))  # Highlight
    
    return scale_surface(surface)


def create_magic_vial_sprite(vial_type='magic_vial'):
    """Create magic vial sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if vial_type == 'magic_potion':
        color = TEAL
        liquid = CYAN
    else:
        color = PURPLE
        liquid = MAGENTA
    
    # Bottle
    pygame.draw.rect(surface, LIGHT_GRAY, (3, 0, 4, 2))  # Cork
    pygame.draw.rect(surface, LIGHT_SLATE, (2, 2, 6, 2))  # Neck
    pygame.draw.rect(surface, LIGHT_SLATE, (1, 4, 8, 5))  # Body outline
    
    # Liquid
    pygame.draw.rect(surface, color, (2, 5, 6, 3))
    pygame.draw.rect(surface, liquid, (3, 6, 4, 2))
    
    # Highlight
    pygame.draw.rect(surface, WHITE, (2, 4, 1, 2))
    
    # Sparkle
    pygame.draw.rect(surface, WHITE, (5, 5, 1, 1))
    
    return scale_surface(surface)


def create_fireball_sprite(frame=0):
    """Create fireball projectile sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    # Core
    pygame.draw.rect(surface, YELLOW, (3, 3, 4, 4))
    pygame.draw.rect(surface, WHITE, (4, 4, 2, 2))
    
    # Flames (animated)
    if frame % 4 < 2:
        pygame.draw.rect(surface, ORANGE, (2, 2, 2, 2))
        pygame.draw.rect(surface, ORANGE, (6, 2, 2, 2))
        pygame.draw.rect(surface, ORANGE, (2, 6, 2, 2))
        pygame.draw.rect(surface, ORANGE, (6, 6, 2, 2))
        pygame.draw.rect(surface, RED, (1, 4, 2, 2))
    else:
        pygame.draw.rect(surface, ORANGE, (1, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (7, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (1, 5, 2, 2))
        pygame.draw.rect(surface, ORANGE, (7, 5, 2, 2))
        pygame.draw.rect(surface, RED, (0, 4, 2, 2))
    
    return scale_surface(surface)


def create_thunder_sprite(frame=0):
    """Create thunder effect sprite"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    # Lightning bolt shape
    color = YELLOW if frame % 4 < 2 else WHITE
    
    pygame.draw.rect(surface, color, (8, 0, 3, 4))
    pygame.draw.rect(surface, color, (6, 3, 4, 3))
    pygame.draw.rect(surface, color, (4, 5, 6, 3))
    pygame.draw.rect(surface, color, (6, 7, 4, 3))
    pygame.draw.rect(surface, color, (8, 9, 3, 4))
    pygame.draw.rect(surface, color, (10, 12, 2, 4))
    
    return scale_surface(surface)


def create_shield_effect_sprite(frame=0):
    """Create shield buff visual effect"""
    size = 20
    surface = create_pixel_surface(size, size)
    
    # Shimmering shield
    alpha = 128 + int(64 * ((frame % 30) / 30))
    color = (*CYAN[:3], alpha)
    
    # Circular shield
    for i in range(8):
        angle_offset = (frame * 3 + i * 45) % 360
        x = int(10 + 7 * (1 if i % 2 == 0 else -1) * ((frame + i * 5) % 10) / 10)
        y = int(10 + 7 * (1 if i < 4 else -1) * ((frame + i * 5) % 10) / 10)
        pygame.draw.rect(surface, CYAN, (x, y, 2, 2))
    
    # Border
    pygame.draw.rect(surface, TEAL, (0, 8, 2, 4))
    pygame.draw.rect(surface, TEAL, (18, 8, 2, 4))
    pygame.draw.rect(surface, TEAL, (8, 0, 4, 2))
    pygame.draw.rect(surface, TEAL, (8, 18, 4, 2))
    
    return scale_surface(surface)


def create_tile_sprite(tile_type, variant=0):
    """Create tile sprites for levels"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    if tile_type == 'grass':
        pygame.draw.rect(surface, GREEN, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIME, (0, 0, 16, 4))
        # Grass detail
        for i in range(4):
            x = (i * 4 + variant) % 16
            pygame.draw.rect(surface, DARK_GREEN, (x, 4, 1, 2))
    
    elif tile_type == 'dirt':
        pygame.draw.rect(surface, BROWN, (0, 0, 16, 16))
        pygame.draw.rect(surface, TAN, (2, 2, 3, 2))
        pygame.draw.rect(surface, TAN, (10, 8, 4, 3))
        pygame.draw.rect(surface, DARK_BROWN, (6, 12, 2, 2))
    
    elif tile_type == 'stone':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIGHT_GRAY, (1, 1, 6, 5))
        pygame.draw.rect(surface, LIGHT_GRAY, (9, 8, 5, 6))
        pygame.draw.rect(surface, DARK_BROWN, (0, 7, 16, 1))
        pygame.draw.rect(surface, DARK_BROWN, (7, 0, 1, 16))
    
    elif tile_type == 'brick':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        # Brick pattern
        pygame.draw.rect(surface, RED, (1, 1, 6, 6))
        pygame.draw.rect(surface, RED, (9, 1, 6, 6))
        pygame.draw.rect(surface, RED, (1, 9, 14, 6))
        pygame.draw.rect(surface, BROWN, (0, 7, 16, 2))
        pygame.draw.rect(surface, BROWN, (7, 0, 2, 8))
    
    elif tile_type == 'wood':
        pygame.draw.rect(surface, BROWN, (0, 0, 16, 16))
        # Wood grain
        for i in range(4):
            y = i * 4 + 1
            pygame.draw.rect(surface, TAN, (0, y, 16, 2))
        pygame.draw.rect(surface, DARK_BROWN, (4, 0, 1, 16))
        pygame.draw.rect(surface, DARK_BROWN, (11, 0, 1, 16))
    
    elif tile_type == 'water':
        base = TEAL if variant % 2 == 0 else SKY_BLUE
        pygame.draw.rect(surface, base, (0, 0, 16, 16))
        # Waves
        wave_color = CYAN
        for i in range(3):
            x = (i * 6 + variant * 2) % 16
            pygame.draw.rect(surface, wave_color, (x, 4, 4, 1))
            pygame.draw.rect(surface, wave_color, ((x + 3) % 16, 10, 4, 1))
    
    elif tile_type == 'lava':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        pygame.draw.rect(surface, RED, (2, 2, 5, 4))
        pygame.draw.rect(surface, RED, (9, 7, 5, 5))
        pygame.draw.rect(surface, ORANGE, (3, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (10, 9, 3, 2))
        pygame.draw.rect(surface, YELLOW, (4, 3, 1, 1))
    
    elif tile_type == 'sky':
        pygame.draw.rect(surface, SKY_BLUE, (0, 0, 16, 16))
        if variant % 3 == 0:
            # Cloud
            pygame.draw.rect(surface, WHITE, (2, 4, 8, 4))
            pygame.draw.rect(surface, WHITE, (4, 2, 4, 2))
    
    return scale_surface(surface)


def create_world_map_tile(tile_type):
    """Create tiles for the world map"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    if tile_type == 'grass':
        pygame.draw.rect(surface, GREEN, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIME, (3, 3, 2, 2))
        pygame.draw.rect(surface, LIME, (10, 8, 2, 2))
        pygame.draw.rect(surface, DARK_GREEN, (7, 12, 2, 2))
    
    elif tile_type == 'forest':
        pygame.draw.rect(surface, DARK_GREEN, (0, 0, 16, 16))
        # Trees
        pygame.draw.rect(surface, GREEN, (2, 4, 4, 6))
        pygame.draw.rect(surface, GREEN, (10, 2, 4, 8))
        pygame.draw.rect(surface, BROWN, (3, 10, 2, 4))
        pygame.draw.rect(surface, BROWN, (11, 10, 2, 4))
    
    elif tile_type == 'mountain':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        # Mountain peak
        pygame.draw.rect(surface, SLATE, (6, 0, 4, 6))
        pygame.draw.rect(surface, SLATE, (4, 6, 8, 4))
        pygame.draw.rect(surface, SLATE, (2, 10, 12, 6))
        pygame.draw.rect(surface, WHITE, (7, 1, 2, 3))  # Snow cap
    
    elif tile_type == 'water':
        pygame.draw.rect(surface, NAVY, (0, 0, 16, 16))
        pygame.draw.rect(surface, TEAL, (2, 4, 6, 2))
        pygame.draw.rect(surface, TEAL, (8, 10, 6, 2))
    
    elif tile_type == 'path':
        # Full path tile that connects in all directions
        pygame.draw.rect(surface, TAN, (0, 0, 16, 16))
        # Add some texture/detail
        pygame.draw.rect(surface, BEIGE, (2, 2, 4, 4))
        pygame.draw.rect(surface, BEIGE, (10, 10, 4, 4))
        pygame.draw.rect(surface, BROWN, (7, 6, 2, 2))
        pygame.draw.rect(surface, BROWN, (1, 12, 2, 2))
        pygame.draw.rect(surface, BROWN, (12, 2, 2, 2))
    
    elif tile_type == 'castle':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        # Castle structure
        pygame.draw.rect(surface, SLATE, (2, 4, 12, 12))
        pygame.draw.rect(surface, SLATE, (0, 2, 4, 4))
        pygame.draw.rect(surface, SLATE, (12, 2, 4, 4))
        pygame.draw.rect(surface, DARK_BLUE, (6, 10, 4, 6))  # Door
        pygame.draw.rect(surface, RED, (2, 0, 2, 3))  # Flag
    
    elif tile_type == 'cave':
        pygame.draw.rect(surface, DARK_BROWN, (0, 0, 16, 16))
        pygame.draw.rect(surface, BLACK, (4, 6, 8, 10))
        pygame.draw.rect(surface, DARK_BROWN, (2, 4, 12, 4))
    
    elif tile_type == 'fortress':
        # Cannon's Domain entrance - dark fortress
        pygame.draw.rect(surface, DARK_BLUE, (0, 0, 16, 16))
        # Fortress walls
        pygame.draw.rect(surface, NAVY, (1, 2, 14, 14))
        pygame.draw.rect(surface, DARK_BROWN, (3, 4, 10, 10))
        # Gate
        pygame.draw.rect(surface, BLACK, (5, 8, 6, 8))
        # Spikes on top
        pygame.draw.rect(surface, GRAY, (2, 1, 2, 4))
        pygame.draw.rect(surface, GRAY, (7, 1, 2, 4))
        pygame.draw.rect(surface, GRAY, (12, 1, 2, 4))
        # Red glow
        pygame.draw.rect(surface, RED, (6, 9, 4, 2))
    
    elif tile_type == 'boss':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        # Evil castle
        pygame.draw.rect(surface, DARK_BLUE, (2, 4, 12, 12))
        pygame.draw.rect(surface, DARK_BLUE, (0, 2, 4, 4))
        pygame.draw.rect(surface, DARK_BLUE, (12, 2, 4, 4))
        pygame.draw.rect(surface, BLACK, (6, 10, 4, 6))
        pygame.draw.rect(surface, YELLOW, (4, 6, 2, 2))  # Evil eye
        pygame.draw.rect(surface, YELLOW, (10, 6, 2, 2))  # Evil eye
    
    elif tile_type == 'level_marker':
        pygame.draw.rect(surface, YELLOW, (4, 4, 8, 8))
        pygame.draw.rect(surface, ORANGE, (6, 6, 4, 4))
    
    return scale_surface(surface)


def create_chain_world_sprite(facing='down', frame=0):
    """Create Chain sprite for world map (top-down view)"""
    size = 12
    surface = create_pixel_surface(size, size)
    
    # Body
    pygame.draw.rect(surface, TEAL, (3, 3, 6, 6))
    
    # Head direction
    skin = BEIGE
    hair = NAVY
    
    if facing == 'down':
        pygame.draw.rect(surface, hair, (4, 2, 4, 2))
        pygame.draw.rect(surface, skin, (4, 4, 4, 3))
        pygame.draw.rect(surface, DARK_BLUE, (5, 5, 1, 1))
        pygame.draw.rect(surface, DARK_BLUE, (7, 5, 1, 1))
    elif facing == 'up':
        pygame.draw.rect(surface, hair, (4, 2, 4, 4))
        pygame.draw.rect(surface, skin, (5, 5, 2, 2))
    elif facing == 'left':
        pygame.draw.rect(surface, hair, (3, 2, 4, 3))
        pygame.draw.rect(surface, skin, (3, 4, 3, 3))
        pygame.draw.rect(surface, DARK_BLUE, (3, 5, 1, 1))
    elif facing == 'right':
        pygame.draw.rect(surface, hair, (5, 2, 4, 3))
        pygame.draw.rect(surface, skin, (6, 4, 3, 3))
        pygame.draw.rect(surface, DARK_BLUE, (8, 5, 1, 1))
    
    # Feet (animated)
    if frame % 20 < 10:
        pygame.draw.rect(surface, BROWN, (3, 9, 2, 2))
        pygame.draw.rect(surface, BROWN, (7, 9, 2, 2))
    else:
        pygame.draw.rect(surface, BROWN, (4, 9, 2, 2))
        pygame.draw.rect(surface, BROWN, (6, 9, 2, 2))
    
    return scale_surface(surface)

```

```python
"""
Sprite rendering utilities for 16-bit pixel art style
"""

import pygame
from settings import *


def create_pixel_surface(width, height, scale=PIXEL_SCALE):
    """Create a surface for pixel art that will be scaled up"""
    return pygame.Surface((width, height), pygame.SRCALPHA)


def create_chain_up_attack_sprite(facing_right=True):
    """Create Chain's up-slash attack sprite"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    offset_x = 4
    
    # Body
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (offset_x + 4, 10, 8, 7))
    
    # Head (looking up slightly)
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (offset_x + 5, 6, 6, 5))
    
    # Hair
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (offset_x + 5, 5, 6, 2))
    
    # Eyes (looking up)
    eye_color = DARK_BLUE
    pygame.draw.rect(surface, eye_color, (offset_x + 6, 7, 1, 1))
    pygame.draw.rect(surface, eye_color, (offset_x + 9, 7, 1, 1))
    
    # Legs
    leg_color = BROWN
    pygame.draw.rect(surface, leg_color, (offset_x + 5, 17, 2, 3))
    pygame.draw.rect(surface, leg_color, (offset_x + 9, 17, 2, 3))
    
    # Arms raised up
    pygame.draw.rect(surface, skin_color, (offset_x + 3, 8, 2, 4))
    pygame.draw.rect(surface, skin_color, (offset_x + 11, 8, 2, 4))
    
    # Sword pointing up
    sword_color = LIGHT_SLATE
    sword_handle = BROWN
    pygame.draw.rect(surface, sword_handle, (offset_x + 6, 4, 4, 3))
    pygame.draw.rect(surface, sword_color, (offset_x + 7, 0, 2, 5))
    pygame.draw.rect(surface, YELLOW, (offset_x + 5, 3, 6, 1))  # Guard
    
    # Slash effect
    pygame.draw.rect(surface, WHITE, (offset_x + 4, 0, 1, 4))
    pygame.draw.rect(surface, WHITE, (offset_x + 11, 0, 1, 4))
    
    return scale_surface(surface)


def scale_surface(surface, scale=PIXEL_SCALE):
    """Scale a surface up for that chunky 16-bit look"""
    w, h = surface.get_size()
    return pygame.transform.scale(surface, (w * scale, h * scale))


def draw_pixel_rect(surface, color, rect, scale=1):
    """Draw a rectangle with pixel-perfect edges"""
    pygame.draw.rect(surface, color, rect)


def create_chain_sprite(facing_right=True, frame=0):
    """Create Chain's sprite - the hero"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    # Body (tunic)
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (4, 6, 8, 7))
    
    # Head
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (5, 2, 6, 5))
    
    # Hair (blue-ish)
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (5, 1, 6, 2))
    pygame.draw.rect(surface, hair_color, (4, 2, 1, 2))
    if facing_right:
        pygame.draw.rect(surface, hair_color, (11, 2, 1, 3))
    else:
        pygame.draw.rect(surface, hair_color, (4, 2, 1, 3))
    
    # Eyes
    eye_color = DARK_BLUE
    if facing_right:
        pygame.draw.rect(surface, eye_color, (9, 4, 1, 1))
    else:
        pygame.draw.rect(surface, eye_color, (6, 4, 1, 1))
    
    # Legs (animated)
    leg_color = BROWN
    if frame % 2 == 0:
        pygame.draw.rect(surface, leg_color, (5, 13, 2, 3))
        pygame.draw.rect(surface, leg_color, (9, 13, 2, 3))
    else:
        pygame.draw.rect(surface, leg_color, (4, 13, 2, 3))
        pygame.draw.rect(surface, leg_color, (10, 13, 2, 3))
    
    # Boots
    boot_color = DARK_BROWN
    if frame % 2 == 0:
        pygame.draw.rect(surface, boot_color, (5, 15, 2, 1))
        pygame.draw.rect(surface, boot_color, (9, 15, 2, 1))
    else:
        pygame.draw.rect(surface, boot_color, (4, 15, 2, 1))
        pygame.draw.rect(surface, boot_color, (10, 15, 2, 1))
    
    # Belt
    belt_color = BROWN
    pygame.draw.rect(surface, belt_color, (4, 10, 8, 1))
    
    # Belt buckle (chain link symbol)
    pygame.draw.rect(surface, YELLOW, (7, 10, 2, 1))
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_chain_attack_sprite(facing_right=True):
    """Create Chain's attack sprite with sword"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    # Base character (offset to make room for sword)
    offset_x = 4 if facing_right else 4
    
    # Body
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (offset_x + 4, 6, 8, 7))
    
    # Head
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (offset_x + 5, 2, 6, 5))
    
    # Hair
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (offset_x + 5, 1, 6, 2))
    
    # Eyes
    eye_color = DARK_BLUE
    if facing_right:
        pygame.draw.rect(surface, eye_color, (offset_x + 9, 4, 1, 1))
    else:
        pygame.draw.rect(surface, eye_color, (offset_x + 6, 4, 1, 1))
    
    # Legs
    leg_color = BROWN
    pygame.draw.rect(surface, leg_color, (offset_x + 5, 13, 2, 3))
    pygame.draw.rect(surface, leg_color, (offset_x + 9, 13, 2, 3))
    
    # Sword
    sword_color = LIGHT_SLATE
    sword_handle = BROWN
    if facing_right:
        pygame.draw.rect(surface, sword_handle, (offset_x + 12, 6, 2, 3))
        pygame.draw.rect(surface, sword_color, (offset_x + 14, 4, 6, 2))
        pygame.draw.rect(surface, YELLOW, (offset_x + 12, 5, 3, 1))  # Guard
    else:
        pygame.draw.rect(surface, sword_handle, (offset_x - 2, 6, 2, 3))
        pygame.draw.rect(surface, sword_color, (offset_x - 8, 4, 6, 2))
        pygame.draw.rect(surface, YELLOW, (offset_x - 3, 5, 3, 1))  # Guard
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_slime_sprite(frame=0):
    """Create slime enemy sprite"""
    size = 12
    surface = create_pixel_surface(size, size)
    
    color = LIME
    dark = DARK_GREEN
    
    # Body (bouncy animation)
    if frame % 20 < 10:
        pygame.draw.rect(surface, dark, (1, 6, 10, 6))
        pygame.draw.rect(surface, color, (2, 4, 8, 6))
        pygame.draw.rect(surface, color, (3, 3, 6, 2))
    else:
        pygame.draw.rect(surface, dark, (0, 8, 12, 4))
        pygame.draw.rect(surface, color, (1, 6, 10, 4))
        pygame.draw.rect(surface, color, (2, 5, 8, 2))
    
    # Eyes
    pygame.draw.rect(surface, WHITE, (3, 5, 2, 2))
    pygame.draw.rect(surface, WHITE, (7, 5, 2, 2))
    pygame.draw.rect(surface, BLACK, (4, 6, 1, 1))
    pygame.draw.rect(surface, BLACK, (8, 6, 1, 1))
    
    return scale_surface(surface)


def create_bat_sprite(frame=0):
    """Create bat enemy sprite"""
    size = 14
    surface = create_pixel_surface(size, size)
    
    color = PURPLE
    dark = DARK_BLUE
    
    # Body
    pygame.draw.rect(surface, color, (5, 5, 4, 5))
    pygame.draw.rect(surface, dark, (6, 4, 2, 2))
    
    # Wings (animated)
    if frame % 10 < 5:
        # Wings up
        pygame.draw.rect(surface, color, (0, 3, 5, 3))
        pygame.draw.rect(surface, color, (9, 3, 5, 3))
        pygame.draw.rect(surface, color, (1, 2, 3, 2))
        pygame.draw.rect(surface, color, (10, 2, 3, 2))
    else:
        # Wings down
        pygame.draw.rect(surface, color, (0, 6, 5, 3))
        pygame.draw.rect(surface, color, (9, 6, 5, 3))
        pygame.draw.rect(surface, color, (1, 8, 3, 2))
        pygame.draw.rect(surface, color, (10, 8, 3, 2))
    
    # Eyes (red, menacing)
    pygame.draw.rect(surface, RED, (5, 5, 1, 1))
    pygame.draw.rect(surface, RED, (8, 5, 1, 1))
    
    # Ears
    pygame.draw.rect(surface, color, (5, 3, 1, 2))
    pygame.draw.rect(surface, color, (8, 3, 1, 2))
    
    return scale_surface(surface)


def create_knight_sprite(facing_right=True, frame=0):
    """Create knight enemy sprite - armored and tough"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    armor_color = SLATE
    armor_dark = GRAY
    visor_color = DARK_BLUE
    
    # Body (armor)
    pygame.draw.rect(surface, armor_dark, (4, 6, 8, 7))
    pygame.draw.rect(surface, armor_color, (5, 5, 6, 6))
    
    # Helmet
    pygame.draw.rect(surface, armor_dark, (4, 1, 8, 5))
    pygame.draw.rect(surface, armor_color, (5, 2, 6, 3))
    
    # Visor
    pygame.draw.rect(surface, visor_color, (6, 3, 4, 2))
    pygame.draw.rect(surface, RED, (7, 3, 1, 1))  # Glowing eye
    pygame.draw.rect(surface, RED, (9, 3, 1, 1))  # Glowing eye
    
    # Shield
    if facing_right:
        pygame.draw.rect(surface, armor_dark, (2, 6, 3, 5))
        pygame.draw.rect(surface, armor_color, (2, 7, 2, 3))
    else:
        pygame.draw.rect(surface, armor_dark, (11, 6, 3, 5))
        pygame.draw.rect(surface, armor_color, (12, 7, 2, 3))
    
    # Sword
    sword_color = LIGHT_SLATE
    if facing_right:
        pygame.draw.rect(surface, sword_color, (12, 4, 2, 6))
        pygame.draw.rect(surface, sword_color, (13, 2, 1, 3))
    else:
        pygame.draw.rect(surface, sword_color, (2, 4, 2, 6))
        pygame.draw.rect(surface, sword_color, (2, 2, 1, 3))
    
    # Legs (armored)
    if frame % 2 == 0:
        pygame.draw.rect(surface, armor_dark, (5, 13, 2, 3))
        pygame.draw.rect(surface, armor_dark, (9, 13, 2, 3))
    else:
        pygame.draw.rect(surface, armor_dark, (4, 13, 2, 3))
        pygame.draw.rect(surface, armor_dark, (10, 13, 2, 3))
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_cannon_sprite(frame=0):
    """Create Cannon (boss) sprite - the archenemy"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    # Cape
    cape_color = DARK_RED
    pygame.draw.rect(surface, cape_color, (2, 6, 20, 14))
    pygame.draw.rect(surface, RED, (4, 8, 16, 10))
    
    # Body (dark armor)
    armor_color = DARK_BLUE
    armor_accent = NAVY
    pygame.draw.rect(surface, armor_color, (7, 6, 10, 10))
    pygame.draw.rect(surface, armor_accent, (8, 7, 8, 8))
    
    # Head (helmet with crown)
    pygame.draw.rect(surface, armor_color, (8, 1, 8, 6))
    pygame.draw.rect(surface, DARK_RED, (9, 3, 6, 3))  # Visor
    
    # Crown spikes
    pygame.draw.rect(surface, YELLOW, (8, 0, 2, 2))
    pygame.draw.rect(surface, YELLOW, (11, 0, 2, 1))
    pygame.draw.rect(surface, YELLOW, (14, 0, 2, 2))
    
    # Evil eyes
    pygame.draw.rect(surface, YELLOW, (10, 3, 1, 1))
    pygame.draw.rect(surface, YELLOW, (13, 3, 1, 1))
    
    # Cannon arm (signature weapon)
    cannon_color = GRAY
    if frame % 30 < 15:
        pygame.draw.rect(surface, cannon_color, (17, 8, 6, 4))
        pygame.draw.rect(surface, DARK_BROWN, (16, 9, 2, 2))
        pygame.draw.rect(surface, ORANGE, (22, 9, 2, 2))  # Charging
    else:
        pygame.draw.rect(surface, cannon_color, (17, 8, 6, 4))
        pygame.draw.rect(surface, DARK_BROWN, (16, 9, 2, 2))
    
    # Legs
    pygame.draw.rect(surface, armor_color, (8, 16, 3, 6))
    pygame.draw.rect(surface, armor_color, (13, 16, 3, 6))
    pygame.draw.rect(surface, DARK_BROWN, (8, 21, 3, 2))
    pygame.draw.rect(surface, DARK_BROWN, (13, 21, 3, 2))
    
    return scale_surface(surface)


def create_heart_sprite(full=True, is_container=False):
    """Create heart sprite for health display"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if is_container:
        color = YELLOW
        outline = ORANGE
    elif full:
        color = RED
        outline = DARK_RED
    else:
        color = GRAY
        outline = DARK_BROWN
    
    # Heart shape
    pygame.draw.rect(surface, outline, (1, 2, 3, 3))
    pygame.draw.rect(surface, outline, (6, 2, 3, 3))
    pygame.draw.rect(surface, outline, (0, 3, 2, 3))
    pygame.draw.rect(surface, outline, (8, 3, 2, 3))
    pygame.draw.rect(surface, outline, (2, 5, 6, 3))
    pygame.draw.rect(surface, outline, (3, 8, 4, 1))
    pygame.draw.rect(surface, outline, (4, 9, 2, 1))
    
    # Fill
    pygame.draw.rect(surface, color, (2, 3, 2, 2))
    pygame.draw.rect(surface, color, (6, 3, 2, 2))
    pygame.draw.rect(surface, color, (1, 4, 2, 2))
    pygame.draw.rect(surface, color, (7, 4, 2, 2))
    pygame.draw.rect(surface, color, (3, 5, 4, 2))
    pygame.draw.rect(surface, color, (4, 7, 2, 1))
    
    # Highlight
    if full or is_container:
        pygame.draw.rect(surface, WHITE, (2, 3, 1, 1))
    
    return scale_surface(surface)


def create_magic_sprite(full=True, is_bottle=False):
    """Create magic point sprite (star/crystal)"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if is_bottle:
        color = MAGENTA
        outline = PURPLE
    elif full:
        color = CYAN
        outline = TEAL
    else:
        color = GRAY
        outline = DARK_BROWN
    
    # Crystal/star shape
    pygame.draw.rect(surface, outline, (4, 0, 2, 2))
    pygame.draw.rect(surface, outline, (3, 2, 4, 2))
    pygame.draw.rect(surface, outline, (0, 3, 10, 2))
    pygame.draw.rect(surface, outline, (2, 5, 6, 2))
    pygame.draw.rect(surface, outline, (3, 7, 4, 2))
    pygame.draw.rect(surface, outline, (4, 9, 2, 1))
    
    # Fill
    pygame.draw.rect(surface, color, (4, 1, 2, 1))
    pygame.draw.rect(surface, color, (3, 3, 4, 1))
    pygame.draw.rect(surface, color, (1, 4, 8, 1))
    pygame.draw.rect(surface, color, (3, 5, 4, 1))
    pygame.draw.rect(surface, color, (4, 6, 2, 2))
    
    # Highlight
    if full or is_bottle:
        pygame.draw.rect(surface, WHITE, (4, 3, 1, 1))
    
    return scale_surface(surface)


def create_food_sprite(food_type='food'):
    """Create food item sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if food_type == 'feast':
        # Roasted chicken leg
        pygame.draw.rect(surface, TAN, (2, 2, 6, 5))
        pygame.draw.rect(surface, BEIGE, (3, 3, 4, 3))
        pygame.draw.rect(surface, BROWN, (1, 6, 2, 3))  # Bone
        pygame.draw.rect(surface, CREAM, (1, 8, 2, 1))
    else:
        # Apple
        pygame.draw.rect(surface, RED, (2, 3, 6, 5))
        pygame.draw.rect(surface, RED, (3, 2, 4, 1))
        pygame.draw.rect(surface, DARK_RED, (2, 6, 6, 2))
        pygame.draw.rect(surface, BROWN, (4, 0, 2, 3))  # Stem
        pygame.draw.rect(surface, GREEN, (5, 1, 2, 2))  # Leaf
        pygame.draw.rect(surface, WHITE, (3, 3, 1, 1))  # Highlight
    
    return scale_surface(surface)


def create_magic_vial_sprite(vial_type='magic_vial'):
    """Create magic vial sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if vial_type == 'magic_potion':
        color = TEAL
        liquid = CYAN
    else:
        color = PURPLE
        liquid = MAGENTA
    
    # Bottle
    pygame.draw.rect(surface, LIGHT_GRAY, (3, 0, 4, 2))  # Cork
    pygame.draw.rect(surface, LIGHT_SLATE, (2, 2, 6, 2))  # Neck
    pygame.draw.rect(surface, LIGHT_SLATE, (1, 4, 8, 5))  # Body outline
    
    # Liquid
    pygame.draw.rect(surface, color, (2, 5, 6, 3))
    pygame.draw.rect(surface, liquid, (3, 6, 4, 2))
    
    # Highlight
    pygame.draw.rect(surface, WHITE, (2, 4, 1, 2))
    
    # Sparkle
    pygame.draw.rect(surface, WHITE, (5, 5, 1, 1))
    
    return scale_surface(surface)


def create_fireball_sprite(frame=0):
    """Create fireball projectile sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    # Core
    pygame.draw.rect(surface, YELLOW, (3, 3, 4, 4))
    pygame.draw.rect(surface, WHITE, (4, 4, 2, 2))
    
    # Flames (animated)
    if frame % 4 < 2:
        pygame.draw.rect(surface, ORANGE, (2, 2, 2, 2))
        pygame.draw.rect(surface, ORANGE, (6, 2, 2, 2))
        pygame.draw.rect(surface, ORANGE, (2, 6, 2, 2))
        pygame.draw.rect(surface, ORANGE, (6, 6, 2, 2))
        pygame.draw.rect(surface, RED, (1, 4, 2, 2))
    else:
        pygame.draw.rect(surface, ORANGE, (1, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (7, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (1, 5, 2, 2))
        pygame.draw.rect(surface, ORANGE, (7, 5, 2, 2))
        pygame.draw.rect(surface, RED, (0, 4, 2, 2))
    
    return scale_surface(surface)


def create_thunder_sprite(frame=0):
    """Create thunder effect sprite"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    # Lightning bolt shape
    color = YELLOW if frame % 4 < 2 else WHITE
    
    pygame.draw.rect(surface, color, (8, 0, 3, 4))
    pygame.draw.rect(surface, color, (6, 3, 4, 3))
    pygame.draw.rect(surface, color, (4, 5, 6, 3))
    pygame.draw.rect(surface, color, (6, 7, 4, 3))
    pygame.draw.rect(surface, color, (8, 9, 3, 4))
    pygame.draw.rect(surface, color, (10, 12, 2, 4))
    
    return scale_surface(surface)


def create_shield_effect_sprite(frame=0):
    """Create shield buff visual effect"""
    size = 20
    surface = create_pixel_surface(size, size)
    
    # Shimmering shield
    alpha = 128 + int(64 * ((frame % 30) / 30))
    color = (*CYAN[:3], alpha)
    
    # Circular shield
    for i in range(8):
        angle_offset = (frame * 3 + i * 45) % 360
        x = int(10 + 7 * (1 if i % 2 == 0 else -1) * ((frame + i * 5) % 10) / 10)
        y = int(10 + 7 * (1 if i < 4 else -1) * ((frame + i * 5) % 10) / 10)
        pygame.draw.rect(surface, CYAN, (x, y, 2, 2))
    
    # Border
    pygame.draw.rect(surface, TEAL, (0, 8, 2, 4))
    pygame.draw.rect(surface, TEAL, (18, 8, 2, 4))
    pygame.draw.rect(surface, TEAL, (8, 0, 4, 2))
    pygame.draw.rect(surface, TEAL, (8, 18, 4, 2))
    
    return scale_surface(surface)


def create_tile_sprite(tile_type, variant=0):
    """Create tile sprites for levels"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    if tile_type == 'grass':
        pygame.draw.rect(surface, GREEN, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIME, (0, 0, 16, 4))
        # Grass detail
        for i in range(4):
            x = (i * 4 + variant) % 16
            pygame.draw.rect(surface, DARK_GREEN, (x, 4, 1, 2))
    
    elif tile_type == 'dirt':
        pygame.draw.rect(surface, BROWN, (0, 0, 16, 16))
        pygame.draw.rect(surface, TAN, (2, 2, 3, 2))
        pygame.draw.rect(surface, TAN, (10, 8, 4, 3))
        pygame.draw.rect(surface, DARK_BROWN, (6, 12, 2, 2))
    
    elif tile_type == 'stone':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIGHT_GRAY, (1, 1, 6, 5))
        pygame.draw.rect(surface, LIGHT_GRAY, (9, 8, 5, 6))
        pygame.draw.rect(surface, DARK_BROWN, (0, 7, 16, 1))
        pygame.draw.rect(surface, DARK_BROWN, (7, 0, 1, 16))
    
    elif tile_type == 'brick':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        # Brick pattern
        pygame.draw.rect(surface, RED, (1, 1, 6, 6))
        pygame.draw.rect(surface, RED, (9, 1, 6, 6))
        pygame.draw.rect(surface, RED, (1, 9, 14, 6))
        pygame.draw.rect(surface, BROWN, (0, 7, 16, 2))
        pygame.draw.rect(surface, BROWN, (7, 0, 2, 8))
    
    elif tile_type == 'wood':
        pygame.draw.rect(surface, BROWN, (0, 0, 16, 16))
        # Wood grain
        for i in range(4):
            y = i * 4 + 1
            pygame.draw.rect(surface, TAN, (0, y, 16, 2))
        pygame.draw.rect(surface, DARK_BROWN, (4, 0, 1, 16))
        pygame.draw.rect(surface, DARK_BROWN, (11, 0, 1, 16))
    
    elif tile_type == 'water':
        base = TEAL if variant % 2 == 0 else SKY_BLUE
        pygame.draw.rect(surface, base, (0, 0, 16, 16))
        # Waves
        wave_color = CYAN
        for i in range(3):
            x = (i * 6 + variant * 2) % 16
            pygame.draw.rect(surface, wave_color, (x, 4, 4, 1))
            pygame.draw.rect(surface, wave_color, ((x + 3) % 16, 10, 4, 1))
    
    elif tile_type == 'lava':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        pygame.draw.rect(surface, RED, (2, 2, 5, 4))
        pygame.draw.rect(surface, RED, (9, 7, 5, 5))
        pygame.draw.rect(surface, ORANGE, (3, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (10, 9, 3, 2))
        pygame.draw.rect(surface, YELLOW, (4, 3, 1, 1))
    
    elif tile_type == 'sky':
        pygame.draw.rect(surface, SKY_BLUE, (0, 0, 16, 16))
        if variant % 3 == 0:
            # Cloud
            pygame.draw.rect(surface, WHITE, (2, 4, 8, 4))
            pygame.draw.rect(surface, WHITE, (4, 2, 4, 2))
    
    return scale_surface(surface)


def create_world_map_tile(tile_type):
    """Create tiles for the world map"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    if tile_type == 'grass':
        pygame.draw.rect(surface, GREEN, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIME, (3, 3, 2, 2))
        pygame.draw.rect(surface, LIME, (10, 8, 2, 2))
        pygame.draw.rect(surface, DARK_GREEN, (7, 12, 2, 2))
    
    elif tile_type == 'forest':
        pygame.draw.rect(surface, DARK_GREEN, (0, 0, 16, 16))
        # Trees
        pygame.draw.rect(surface, GREEN, (2, 4, 4, 6))
        pygame.draw.rect(surface, GREEN, (10, 2, 4, 8))
        pygame.draw.rect(surface, BROWN, (3, 10, 2, 4))
        pygame.draw.rect(surface, BROWN, (11, 10, 2, 4))
    
    elif tile_type == 'mountain':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        # Mountain peak
        pygame.draw.rect(surface, SLATE, (6, 0, 4, 6))
        pygame.draw.rect(surface, SLATE, (4, 6, 8, 4))
        pygame.draw.rect(surface, SLATE, (2, 10, 12, 6))
        pygame.draw.rect(surface, WHITE, (7, 1, 2, 3))  # Snow cap
    
    elif tile_type == 'water':
        pygame.draw.rect(surface, NAVY, (0, 0, 16, 16))
        pygame.draw.rect(surface, TEAL, (2, 4, 6, 2))
        pygame.draw.rect(surface, TEAL, (8, 10, 6, 2))
    
    elif tile_type == 'path':
        # Full path tile that connects in all directions
        pygame.draw.rect(surface, TAN, (0, 0, 16, 16))
        # Add some texture/detail
        pygame.draw.rect(surface, BEIGE, (2, 2, 4, 4))
        pygame.draw.rect(surface, BEIGE, (10, 10, 4, 4))
        pygame.draw.rect(surface, BROWN, (7, 6, 2, 2))
        pygame.draw.rect(surface, BROWN, (1, 12, 2, 2))
        pygame.draw.rect(surface, BROWN, (12, 2, 2, 2))
    
    elif tile_type == 'castle':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        # Castle structure
        pygame.draw.rect(surface, SLATE, (2, 4, 12, 12))
        pygame.draw.rect(surface, SLATE, (0, 2, 4, 4))
        pygame.draw.rect(surface, SLATE, (12, 2, 4, 4))
        pygame.draw.rect(surface, DARK_BLUE, (6, 10, 4, 6))  # Door
        pygame.draw.rect(surface, RED, (2, 0, 2, 3))  # Flag
    
    elif tile_type == 'cave':
        pygame.draw.rect(surface, DARK_BROWN, (0, 0, 16, 16))
        pygame.draw.rect(surface, BLACK, (4, 6, 8, 10))
        pygame.draw.rect(surface, DARK_BROWN, (2, 4, 12, 4))
    
    elif tile_type == 'fortress':
        # Cannon's Domain entrance - dark fortress
        pygame.draw.rect(surface, DARK_BLUE, (0, 0, 16, 16))
        # Fortress walls
        pygame.draw.rect(surface, NAVY, (1, 2, 14, 14))
        pygame.draw.rect(surface, DARK_BROWN, (3, 4, 10, 10))
        # Gate
        pygame.draw.rect(surface, BLACK, (5, 8, 6, 8))
        # Spikes on top
        pygame.draw.rect(surface, GRAY, (2, 1, 2, 4))
        pygame.draw.rect(surface, GRAY, (7, 1, 2, 4))
        pygame.draw.rect(surface, GRAY, (12, 1, 2, 4))
        # Red glow
        pygame.draw.rect(surface, RED, (6, 9, 4, 2))
    
    elif tile_type == 'boss':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        # Evil castle
        pygame.draw.rect(surface, DARK_BLUE, (2, 4, 12, 12))
        pygame.draw.rect(surface, DARK_BLUE, (0, 2, 4, 4))
        pygame.draw.rect(surface, DARK_BLUE, (12, 2, 4, 4))
        pygame.draw.rect(surface, BLACK, (6, 10, 4, 6))
        pygame.draw.rect(surface, YELLOW, (4, 6, 2, 2))  # Evil eye
        pygame.draw.rect(surface, YELLOW, (10, 6, 2, 2))  # Evil eye
    
    elif tile_type == 'level_marker':
        pygame.draw.rect(surface, YELLOW, (4, 4, 8, 8))
        pygame.draw.rect(surface, ORANGE, (6, 6, 4, 4))
    
    return scale_surface(surface)


def create_chain_world_sprite(facing='down', frame=0):
    """Create Chain sprite for world map (top-down view)"""
    size = 12
    surface = create_pixel_surface(size, size)
    
    # Body
    pygame.draw.rect(surface, TEAL, (3, 3, 6, 6))
    
    # Head direction
    skin = BEIGE
    hair = NAVY
    
    if facing == 'down':
        pygame.draw.rect(surface, hair, (4, 2, 4, 2))
        pygame.draw.rect(surface, skin, (4, 4, 4, 3))
        pygame.draw.rect(surface, DARK_BLUE, (5, 5, 1, 1))
        pygame.draw.rect(surface, DARK_BLUE, (7, 5, 1, 1))
    elif facing == 'up':
        pygame.draw.rect(surface, hair, (4, 2, 4, 4))
        pygame.draw.rect(surface, skin, (5, 5, 2, 2))
    elif facing == 'left':
        pygame.draw.rect(surface, hair, (3, 2, 4, 3))
        pygame.draw.rect(surface, skin, (3, 4, 3, 3))
        pygame.draw.rect(surface, DARK_BLUE, (3, 5, 1, 1))
    elif facing == 'right':
        pygame.draw.rect(surface, hair, (5, 2, 4, 3))
        pygame.draw.rect(surface, skin, (6, 4, 3, 3))
        pygame.draw.rect(surface, DARK_BLUE, (8, 5, 1, 1))
    
    # Feet (animated)
    if frame % 20 < 10:
        pygame.draw.rect(surface, BROWN, (3, 9, 2, 2))
        pygame.draw.rect(surface, BROWN, (7, 9, 2, 2))
    else:
        pygame.draw.rect(surface, BROWN, (4, 9, 2, 2))
        pygame.draw.rect(surface, BROWN, (6, 9, 2, 2))
    
    return scale_surface(surface)

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import create_chain_sprite, create_chain_attack_sprite, create_chain_up_attack_sprite, create_chain_world_sprite
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up for up-slash)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
                self.is_up_attack = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        # Up slash attack
        if self.is_up_attack:
            return pygame.Rect(
                self.rect.centerx - 15,
                self.rect.top - 35,
                30,
                40
            )
        
        # Normal horizontal attack
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import create_chain_sprite, create_chain_attack_sprite, create_chain_up_attack_sprite, create_chain_world_sprite
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            if self.is_up_attack:
                self.image = create_chain_up_attack_sprite(self.facing_right)
            else:
                self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up for up-slash)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
                self.is_up_attack = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        # Up slash attack
        if self.is_up_attack:
            return pygame.Rect(
                self.rect.centerx - 15,
                self.rect.top - 35,
                30,
                40
            )
        
        # Normal horizontal attack
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

Let me check the boss health bar implementation:

The boss health bar exists. Let me make it more prominent with a label:

```python
"""
Enemy classes for Chain
"""

import pygame
import math
import random
from settings import *
from sprites import create_slime_sprite, create_bat_sprite, create_knight_sprite, create_cannon_sprite


class Enemy(pygame.sprite.Sprite):
    """Base enemy class"""
    
    def __init__(self, x, y, enemy_type):
        super().__init__()
        self.enemy_type = enemy_type
        self.stats = ENEMY_TYPES[enemy_type]
        
        self.max_health = self.stats['health']
        self.health = self.max_health
        self.damage = self.stats['damage']
        self.speed = self.stats['speed']
        self.score = self.stats['score']
        
        self.frame = 0
        self.facing_right = True
        
        # AI state
        self.state = 'patrol'
        self.patrol_distance = 100
        self.start_x = x
        self.direction = 1
        
        # Physics
        self.velocity_x = 0
        self.velocity_y = 0
        
        # Combat
        self.hurt_timer = 0
        self.attack_cooldown = 0
        
        # Create initial sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
    
    def update_sprite(self):
        """Override in subclasses"""
        pass
    
    def update(self, player=None, tiles=None):
        """Update enemy state"""
        self.frame += 1
        
        if self.hurt_timer > 0:
            self.hurt_timer -= 1
        
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        self.ai_update(player)
        self.physics_update(tiles)
        self.update_sprite()
    
    def ai_update(self, player):
        """AI behavior - override in subclasses"""
        pass
    
    def physics_update(self, tiles):
        """Apply physics"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:
            self.velocity_y = 15
        
        # Move
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def take_damage(self, amount):
        """Take damage"""
        self.health -= amount
        self.hurt_timer = 10
        
        if self.health <= 0:
            self.kill()
            return True  # Enemy died
        return False
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw enemy"""
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.hurt_timer > 0 and self.frame % 4 < 2:
            return
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw health bar for tough enemies
        if self.max_health > 2:
            self.draw_health_bar(surface, camera_offset)
    
    def draw_health_bar(self, surface, camera_offset):
        """Draw health bar above enemy"""
        bar_width = 30
        bar_height = 4
        
        x = self.rect.centerx - camera_offset[0] - bar_width // 2
        y = self.rect.top - camera_offset[1] - 8
        
        # Background
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health
        health_width = int(bar_width * (self.health / self.max_health))
        pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))


class Slime(Enemy):
    """Slime enemy - easy, hops around"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'slime')
        self.hop_timer = 0
    
    def update_sprite(self):
        self.image = create_slime_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Hop periodically
        self.hop_timer += 1
        if self.hop_timer >= 60:
            self.hop_timer = 0
            self.velocity_y = -6
            
            # Move toward player if nearby, otherwise patrol
            if player and abs(player.rect.centerx - self.rect.centerx) < 200:
                if player.rect.centerx < self.rect.centerx:
                    self.velocity_x = -self.speed * 2
                else:
                    self.velocity_x = self.speed * 2
            else:
                # Patrol
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                self.velocity_x = self.speed * self.direction


class Bat(Enemy):
    """Bat enemy - flying, erratic movement"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'bat')
        self.start_y = y
        self.angle = 0
        self.swoop_target = None
    
    def update_sprite(self):
        self.image = create_bat_sprite(self.frame)
    
    def ai_update(self, player):
        # Erratic flying pattern
        self.angle += 0.05
        
        if player and abs(player.rect.centerx - self.rect.centerx) < 150:
            # Swoop toward player
            dx = player.rect.centerx - self.rect.centerx
            dy = player.rect.centery - self.rect.centery
            dist = math.sqrt(dx * dx + dy * dy)
            
            if dist > 0:
                self.velocity_x = (dx / dist) * self.speed * 1.5
                self.velocity_y = (dy / dist) * self.speed * 1.5
        else:
            # Patrol pattern
            self.velocity_x = math.sin(self.angle) * self.speed
            self.velocity_y = math.cos(self.angle * 2) * self.speed * 0.5
        
        self.facing_right = self.velocity_x > 0
    
    def physics_update(self, tiles):
        # Bats don't use gravity
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Keep within bounds
        if self.rect.y < self.start_y - 100:
            self.rect.y = self.start_y - 100
        if self.rect.y > self.start_y + 100:
            self.rect.y = self.start_y + 100


class Knight(Enemy):
    """Knight enemy - tough, shielded, aggressive"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'knight')
        self.shield_active = True
        self.charge_timer = 0
        self.charging = False
    
    def update_sprite(self):
        self.image = create_knight_sprite(self.facing_right, self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        if player:
            dx = player.rect.centerx - self.rect.centerx
            
            # Face player
            self.facing_right = dx > 0
            
            if abs(dx) < 250:
                # Aggressive pursuit
                self.charge_timer += 1
                
                if self.charge_timer >= 90:
                    # Charge attack
                    self.charging = True
                    self.charge_timer = 0
                
                if self.charging:
                    self.velocity_x = self.speed * 3 * (1 if self.facing_right else -1)
                    if abs(dx) < 30 or abs(dx) > 200:
                        self.charging = False
                else:
                    # Walk toward player
                    if abs(dx) > 40:
                        self.velocity_x = self.speed * (1 if dx > 0 else -1)
            else:
                # Patrol
                self.charge_timer = 0
                self.charging = False
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                    self.facing_right = False
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                    self.facing_right = True
                self.velocity_x = self.speed * self.direction
    
    def take_damage(self, amount):
        """Knights take reduced damage from front when shield is up"""
        if self.shield_active:
            # Shield blocks some damage
            amount = max(1, amount - 1)
        return super().take_damage(amount)


class Cannon(Enemy):
    """Boss enemy - the archenemy"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'cannon')
        self.phase = 1
        self.attack_pattern = 0
        self.pattern_timer = 0
        self.projectiles = pygame.sprite.Group()
        self.arena_bounds = (x - 200, x + 200)
    
    def update_sprite(self):
        self.image = create_cannon_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        if not player:
            return
        
        # Update phase based on health
        if self.health <= self.max_health * 0.3:
            self.phase = 3
        elif self.health <= self.max_health * 0.6:
            self.phase = 2
        
        dx = player.rect.centerx - self.rect.centerx
        self.facing_right = dx > 0
        
        self.pattern_timer += 1
        
        if self.phase == 1:
            self.phase1_ai(player)
        elif self.phase == 2:
            self.phase2_ai(player)
        else:
            self.phase3_ai(player)
    
    def phase1_ai(self, player):
        """Phase 1: Patrol and shoot"""
        # Move back and forth
        if self.rect.x > self.arena_bounds[1]:
            self.direction = -1
        elif self.rect.x < self.arena_bounds[0]:
            self.direction = 1
        
        self.velocity_x = self.speed * self.direction
        
        # Shoot periodically
        if self.pattern_timer >= 90:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase2_ai(self, player):
        """Phase 2: Chase and rapid fire"""
        dx = player.rect.centerx - self.rect.centerx
        
        if abs(dx) > 100:
            self.velocity_x = self.speed * 1.5 * (1 if dx > 0 else -1)
        
        # Rapid fire
        if self.pattern_timer >= 45:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase3_ai(self, player):
        """Phase 3: Enraged - fast and aggressive"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive pursuit
        self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Very rapid fire
        if self.pattern_timer >= 30:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def shoot_cannon_ball(self, player):
        """Fire a cannon ball at the player"""
        ball = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery
        )
        self.projectiles.add(ball)
    
    def update(self, player=None, tiles=None):
        super().update(player, tiles)
        self.projectiles.update()
    
    def draw(self, surface, camera_offset=(0, 0)):
        super().draw(surface, camera_offset)
        
        # Draw projectiles
        for ball in self.projectiles:
            ball.draw(surface, camera_offset)
        
        # Draw boss health bar at top of screen
        self.draw_boss_health_bar(surface)
    
    def draw_boss_health_bar(self, surface):
        """Draw large boss health bar at top"""
        bar_width = 400
        bar_height = 28
        x = SCREEN_WIDTH // 2 - bar_width // 2
        y = 50
        
        # Boss name label
        pygame.font.init()
        font = pygame.font.Font(None, 36)
        name_text = font.render("~ CANNON ~", True, YELLOW)
        name_rect = name_text.get_rect(center=(SCREEN_WIDTH // 2, 25))
        
        # Name background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), 
                        (name_rect.x - 15, name_rect.y - 5, name_rect.width + 30, name_rect.height + 10))
        pygame.draw.rect(surface, RED, 
                        (name_rect.x - 15, name_rect.y - 5, name_rect.width + 30, name_rect.height + 10), 2)
        surface.blit(name_text, name_rect)
        
        # Health bar background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 220), (x - 6, y - 6, bar_width + 12, bar_height + 12))
        pygame.draw.rect(surface, DARK_BROWN, (x - 2, y - 2, bar_width + 4, bar_height + 4))
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health (gradient effect)
        health_width = int(bar_width * (self.health / self.max_health))
        if health_width > 0:
            # Main health bar
            pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))
            # Highlight
            pygame.draw.rect(surface, ORANGE, (x, y, health_width, bar_height // 3))
        
        # Border
        pygame.draw.rect(surface, YELLOW, (x - 4, y - 4, bar_width + 8, bar_height + 8), 3)
        
        # Phase indicator
        if self.phase >= 2:
            phase_text = font.render(f"PHASE {self.phase}", True, MAGENTA if self.phase == 3 else ORANGE)
            phase_rect = phase_text.get_rect(center=(SCREEN_WIDTH // 2, y + bar_height + 20))
            surface.blit(phase_text, phase_rect)


class CannonBall(pygame.sprite.Sprite):
    """Projectile fired by Cannon boss"""
    
    def __init__(self, x, y, target_x, target_y):
        super().__init__()
        
        # Calculate direction
        dx = target_x - x
        dy = target_y - y
        dist = math.sqrt(dx * dx + dy * dy)
        
        self.speed = 5
        if dist > 0:
            self.velocity_x = (dx / dist) * self.speed
            self.velocity_y = (dy / dist) * self.speed
        else:
            self.velocity_x = self.speed
            self.velocity_y = 0
        
        self.damage = 2
        self.lifetime = 180
        
        # Create sprite
        self.image = pygame.Surface((16, 16), pygame.SRCALPHA)
        pygame.draw.circle(self.image, GRAY, (8, 8), 7)
        pygame.draw.circle(self.image, DARK_BROWN, (8, 8), 5)
        pygame.draw.circle(self.image, ORANGE, (6, 6), 2)
        
        self.rect = self.image.get_rect(center=(x, y))
    
    def update(self):
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


def create_enemy(enemy_type, x, y):
    """Factory function to create enemies"""
    if enemy_type == 'slime':
        return Slime(x, y)
    elif enemy_type == 'bat':
        return Bat(x, y)
    elif enemy_type == 'knight':
        return Knight(x, y)
    elif enemy_type == 'cannon':
        return Cannon(x, y)
    else:
        return Slime(x, y)  # Default

```

Done! Here's what I've added:

### 1. Swift Spell Trail Particles
- Particles now trail **behind Chain** no matter what direction you're moving
- Creates a colorful trail effect with cyan, teal, mint, and white particles that fade out

### 2. Up Slash Attack
- Hold **Up + Z** to perform an upward slash attack
- Chain raises his sword above his head and slashes upward
- Great for hitting enemies above you or bats flying overhead

### 3. Thunder 2.0 Spell (Press 5)
- Costs **2 magic points**
- Calls down a powerful **lightning bolt from above** that strikes downward
- Deals 4 damage (more than regular Thunder's 3)
- Creates a dramatic zigzag lightning visual effect
- Shows as "T2" in the spell selector with a magenta color

### 4. Cannon's Health Bar
- Large, prominent health bar at the **top of the screen** during boss fight
- Displays "~ CANNON ~" label above the bar
- Shows **phase indicator** ("PHASE 2" or "PHASE 3") when the boss enters harder phases
- Bar is bigger (400px wide, 28px tall) with gradient highlighting
- Has a nice gold border and dark panel background

---

**User**

Add music, and also a downward stab

---

**Cursor**

I'll add music and a downward stab attack. Let me create a sound system and the down stab mechanic.

```python
"""
Sound and music system for Chain
Uses procedurally generated sounds and music
"""

import pygame
import math
import array


def init_sound():
    """Initialize the sound system"""
    pygame.mixer.init(frequency=22050, size=-16, channels=2, buffer=512)


def generate_square_wave(frequency, duration, volume=0.3):
    """Generate a square wave sound"""
    sample_rate = 22050
    n_samples = int(sample_rate * duration)
    
    buf = array.array('h')
    amplitude = int(32767 * volume)
    
    period = sample_rate / frequency
    
    for i in range(n_samples):
        if (i / period) % 1 < 0.5:
            buf.append(amplitude)
        else:
            buf.append(-amplitude)
    
    # Stereo
    stereo_buf = array.array('h')
    for sample in buf:
        stereo_buf.append(sample)
        stereo_buf.append(sample)
    
    sound = pygame.mixer.Sound(buffer=stereo_buf)
    return sound


def generate_noise(duration, volume=0.2):
    """Generate white noise"""
    import random
    sample_rate = 22050
    n_samples = int(sample_rate * duration)
    
    buf = array.array('h')
    amplitude = int(32767 * volume)
    
    for i in range(n_samples):
        buf.append(random.randint(-amplitude, amplitude))
    
    # Stereo
    stereo_buf = array.array('h')
    for sample in buf:
        stereo_buf.append(sample)
        stereo_buf.append(sample)
    
    sound = pygame.mixer.Sound(buffer=stereo_buf)
    return sound


def generate_melody(notes, tempo=120, volume=0.25):
    """Generate a melody from a list of (note, duration) tuples"""
    sample_rate = 22050
    beat_duration = 60 / tempo
    
    all_samples = array.array('h')
    
    # Note frequencies (A4 = 440Hz)
    note_freqs = {
        'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F3': 174.61, 
        'G3': 196.00, 'A3': 220.00, 'B3': 246.94,
        'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
        'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
        'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46,
        'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
        'REST': 0
    }
    
    for note, beats in notes:
        duration = beat_duration * beats
        n_samples = int(sample_rate * duration)
        
        if note == 'REST' or note not in note_freqs:
            # Silence
            for _ in range(n_samples):
                all_samples.append(0)
        else:
            freq = note_freqs[note]
            amplitude = int(32767 * volume)
            period = sample_rate / freq if freq > 0 else 1
            
            for i in range(n_samples):
                # Square wave with envelope
                envelope = 1.0
                if i < n_samples * 0.1:
                    envelope = i / (n_samples * 0.1)
                elif i > n_samples * 0.7:
                    envelope = (n_samples - i) / (n_samples * 0.3)
                
                if (i / period) % 1 < 0.5:
                    all_samples.append(int(amplitude * envelope))
                else:
                    all_samples.append(int(-amplitude * envelope))
    
    # Stereo
    stereo_buf = array.array('h')
    for sample in all_samples:
        stereo_buf.append(sample)
        stereo_buf.append(sample)
    
    sound = pygame.mixer.Sound(buffer=stereo_buf)
    return sound


class SoundManager:
    """Manages all game sounds and music"""
    
    def __init__(self):
        init_sound()
        
        self.sounds = {}
        self.music = {}
        self.current_music = None
        self.music_enabled = True
        self.sound_enabled = True
        
        self._generate_sounds()
        self._generate_music()
    
    def _generate_sounds(self):
        """Generate all sound effects"""
        # Attack sound
        self.sounds['attack'] = generate_square_wave(200, 0.1, 0.2)
        
        # Jump sound
        self.sounds['jump'] = self._make_jump_sound()
        
        # Hit sound
        self.sounds['hit'] = generate_noise(0.15, 0.3)
        
        # Pickup sound
        self.sounds['pickup'] = self._make_pickup_sound()
        
        # Spell sounds
        self.sounds['spell'] = generate_square_wave(440, 0.2, 0.2)
        
        # Enemy death
        self.sounds['enemy_death'] = self._make_death_sound()
        
        # Menu select
        self.sounds['menu'] = generate_square_wave(330, 0.1, 0.15)
    
    def _make_jump_sound(self):
        """Create a jump sound effect (rising pitch)"""
        sample_rate = 22050
        duration = 0.15
        n_samples = int(sample_rate * duration)
        
        buf = array.array('h')
        volume = 0.2
        amplitude = int(32767 * volume)
        
        for i in range(n_samples):
            # Rising frequency
            t = i / n_samples
            freq = 150 + t * 400
            period = sample_rate / freq
            
            if (i / period) % 1 < 0.5:
                buf.append(int(amplitude * (1 - t * 0.5)))
            else:
                buf.append(int(-amplitude * (1 - t * 0.5)))
        
        stereo_buf = array.array('h')
        for sample in buf:
            stereo_buf.append(sample)
            stereo_buf.append(sample)
        
        return pygame.mixer.Sound(buffer=stereo_buf)
    
    def _make_pickup_sound(self):
        """Create a pickup sound effect (arpeggio)"""
        sample_rate = 22050
        
        buf = array.array('h')
        volume = 0.2
        amplitude = int(32767 * volume)
        
        freqs = [330, 440, 550, 660]  # Rising arpeggio
        
        for freq in freqs:
            duration = 0.05
            n_samples = int(sample_rate * duration)
            period = sample_rate / freq
            
            for i in range(n_samples):
                envelope = 1 - (i / n_samples) * 0.5
                if (i / period) % 1 < 0.5:
                    buf.append(int(amplitude * envelope))
                else:
                    buf.append(int(-amplitude * envelope))
        
        stereo_buf = array.array('h')
        for sample in buf:
            stereo_buf.append(sample)
            stereo_buf.append(sample)
        
        return pygame.mixer.Sound(buffer=stereo_buf)
    
    def _make_death_sound(self):
        """Create enemy death sound (descending)"""
        sample_rate = 22050
        duration = 0.2
        n_samples = int(sample_rate * duration)
        
        buf = array.array('h')
        volume = 0.25
        amplitude = int(32767 * volume)
        
        for i in range(n_samples):
            t = i / n_samples
            freq = 400 - t * 300
            period = sample_rate / freq if freq > 0 else 1
            
            if (i / period) % 1 < 0.5:
                buf.append(int(amplitude * (1 - t)))
            else:
                buf.append(int(-amplitude * (1 - t)))
        
        stereo_buf = array.array('h')
        for sample in buf:
            stereo_buf.append(sample)
            stereo_buf.append(sample)
        
        return pygame.mixer.Sound(buffer=stereo_buf)
    
    def _generate_music(self):
        """Generate background music tracks"""
        
        # Menu music - calm, mysterious
        menu_melody = [
            ('E4', 1), ('G4', 1), ('A4', 2),
            ('E4', 1), ('G4', 1), ('B4', 2),
            ('A4', 1), ('G4', 1), ('E4', 2),
            ('D4', 1), ('E4', 1), ('G4', 2),
            ('E4', 1), ('G4', 1), ('A4', 2),
            ('G4', 1), ('E4', 1), ('D4', 2),
            ('E4', 4),
            ('REST', 2),
        ]
        self.music['menu'] = generate_melody(menu_melody, tempo=80, volume=0.2)
        
        # World map music - adventurous
        world_melody = [
            ('C4', 1), ('E4', 1), ('G4', 1), ('C5', 1),
            ('B4', 1), ('G4', 1), ('E4', 1), ('G4', 1),
            ('A4', 1), ('F4', 1), ('A4', 1), ('C5', 1),
            ('G4', 2), ('E4', 2),
            ('C4', 1), ('D4', 1), ('E4', 1), ('F4', 1),
            ('G4', 2), ('A4', 1), ('G4', 1),
            ('F4', 1), ('E4', 1), ('D4', 1), ('C4', 1),
            ('E4', 4),
        ]
        self.music['world'] = generate_melody(world_melody, tempo=100, volume=0.2)
        
        # Level music - energetic
        level_melody = [
            ('E4', 0.5), ('E4', 0.5), ('E4', 0.5), ('REST', 0.5),
            ('E4', 0.5), ('G4', 0.5), ('E4', 1),
            ('D4', 0.5), ('D4', 0.5), ('D4', 0.5), ('REST', 0.5),
            ('D4', 0.5), ('F4', 0.5), ('D4', 1),
            ('E4', 0.5), ('E4', 0.5), ('G4', 0.5), ('G4', 0.5),
            ('A4', 0.5), ('A4', 0.5), ('G4', 1),
            ('F4', 0.5), ('E4', 0.5), ('D4', 0.5), ('E4', 0.5),
            ('E4', 2),
        ]
        self.music['level'] = generate_melody(level_melody, tempo=140, volume=0.2)
        
        # Boss music - intense
        boss_melody = [
            ('E3', 0.5), ('E3', 0.5), ('E4', 0.5), ('E3', 0.5),
            ('E3', 0.5), ('D4', 0.5), ('E3', 0.5), ('E3', 0.5),
            ('E3', 0.5), ('E3', 0.5), ('E4', 0.5), ('G4', 0.5),
            ('F4', 0.5), ('E4', 0.5), ('D4', 1),
            ('A3', 0.5), ('A3', 0.5), ('A4', 0.5), ('A3', 0.5),
            ('A3', 0.5), ('G4', 0.5), ('A3', 0.5), ('A3', 0.5),
            ('B3', 0.5), ('B3', 0.5), ('B4', 0.5), ('A4', 0.5),
            ('G4', 0.5), ('F4', 0.5), ('E4', 1),
        ]
        self.music['boss'] = generate_melody(boss_melody, tempo=160, volume=0.25)
    
    def play_sound(self, sound_name):
        """Play a sound effect"""
        if self.sound_enabled and sound_name in self.sounds:
            self.sounds[sound_name].play()
    
    def play_music(self, music_name):
        """Play background music (loops)"""
        if not self.music_enabled:
            return
        
        if music_name == self.current_music:
            return
        
        # Stop current music
        pygame.mixer.stop()
        
        if music_name in self.music:
            self.current_music = music_name
            # Loop the music by playing it repeatedly
            self.music[music_name].play(loops=-1)
    
    def stop_music(self):
        """Stop all music"""
        pygame.mixer.stop()
        self.current_music = None
    
    def toggle_music(self):
        """Toggle music on/off"""
        self.music_enabled = not self.music_enabled
        if not self.music_enabled:
            self.stop_music()
        return self.music_enabled
    
    def toggle_sound(self):
        """Toggle sound effects on/off"""
        self.sound_enabled = not self.sound_enabled
        return self.sound_enabled


# Global sound manager instance
_sound_manager = None


def get_sound_manager():
    """Get the global sound manager"""
    global _sound_manager
    if _sound_manager is None:
        _sound_manager = SoundManager()
    return _sound_manager

```

```python
    return scale_surface(surface)


def create_chain_down_attack_sprite(facing_right=True):
    """Create Chain's downward stab attack sprite"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    offset_x = 4
    
    # Body (crouched/diving position)
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (offset_x + 4, 4, 8, 7))
    
    # Head (looking down)
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (offset_x + 5, 0, 6, 5))
    
    # Hair
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (offset_x + 5, 0, 6, 2))
    
    # Legs tucked
    leg_color = BROWN
    pygame.draw.rect(surface, leg_color, (offset_x + 4, 11, 3, 3))
    pygame.draw.rect(surface, leg_color, (offset_x + 9, 11, 3, 3))
    
    # Arms pointing down
    pygame.draw.rect(surface, skin_color, (offset_x + 6, 10, 2, 3))
    pygame.draw.rect(surface, skin_color, (offset_x + 8, 10, 2, 3))
    
    # Sword pointing down
    sword_color = LIGHT_SLATE
    sword_handle = BROWN
    pygame.draw.rect(surface, sword_handle, (offset_x + 6, 13, 4, 2))
    pygame.draw.rect(surface, sword_color, (offset_x + 7, 15, 2, 8))
    pygame.draw.rect(surface, YELLOW, (offset_x + 5, 14, 6, 1))  # Guard
    
    # Stab effect
    pygame.draw.rect(surface, WHITE, (offset_x + 6, 20, 1, 3))
    pygame.draw.rect(surface, WHITE, (offset_x + 9, 20, 1, 3))
    pygame.draw.rect(surface, YELLOW, (offset_x + 7, 22, 2, 2))
    
    return scale_surface(surface)


def create_pixel_surface(width, height, scale=PIXEL_SCALE):
```

```python
"""
Sprite rendering utilities for 16-bit pixel art style
"""

import pygame
from settings import *


def create_pixel_surface(width, height, scale=PIXEL_SCALE):
    """Create a surface for pixel art that will be scaled up"""
    return pygame.Surface((width, height), pygame.SRCALPHA)


def create_chain_up_attack_sprite(facing_right=True):
    """Create Chain's up-slash attack sprite"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    offset_x = 4
    
    # Body
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (offset_x + 4, 10, 8, 7))
    
    # Head (looking up slightly)
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (offset_x + 5, 6, 6, 5))
    
    # Hair
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (offset_x + 5, 5, 6, 2))
    
    # Eyes (looking up)
    eye_color = DARK_BLUE
    pygame.draw.rect(surface, eye_color, (offset_x + 6, 7, 1, 1))
    pygame.draw.rect(surface, eye_color, (offset_x + 9, 7, 1, 1))
    
    # Legs
    leg_color = BROWN
    pygame.draw.rect(surface, leg_color, (offset_x + 5, 17, 2, 3))
    pygame.draw.rect(surface, leg_color, (offset_x + 9, 17, 2, 3))
    
    # Arms raised up
    pygame.draw.rect(surface, skin_color, (offset_x + 3, 8, 2, 4))
    pygame.draw.rect(surface, skin_color, (offset_x + 11, 8, 2, 4))
    
    # Sword pointing up
    sword_color = LIGHT_SLATE
    sword_handle = BROWN
    pygame.draw.rect(surface, sword_handle, (offset_x + 6, 4, 4, 3))
    pygame.draw.rect(surface, sword_color, (offset_x + 7, 0, 2, 5))
    pygame.draw.rect(surface, YELLOW, (offset_x + 5, 3, 6, 1))  # Guard
    
    # Slash effect
    pygame.draw.rect(surface, WHITE, (offset_x + 4, 0, 1, 4))
    pygame.draw.rect(surface, WHITE, (offset_x + 11, 0, 1, 4))
    
    return scale_surface(surface)


def create_chain_down_attack_sprite(facing_right=True):
    """Create Chain's downward stab attack sprite"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    offset_x = 4
    
    # Body (crouched/diving position)
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (offset_x + 4, 2, 8, 7))
    
    # Head (looking down)
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (offset_x + 5, 0, 6, 4))
    
    # Hair
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (offset_x + 5, 0, 6, 2))
    
    # Legs tucked
    leg_color = BROWN
    pygame.draw.rect(surface, leg_color, (offset_x + 4, 9, 3, 3))
    pygame.draw.rect(surface, leg_color, (offset_x + 9, 9, 3, 3))
    
    # Arms pointing down
    pygame.draw.rect(surface, skin_color, (offset_x + 6, 8, 2, 3))
    pygame.draw.rect(surface, skin_color, (offset_x + 8, 8, 2, 3))
    
    # Sword pointing down
    sword_color = LIGHT_SLATE
    sword_handle = BROWN
    pygame.draw.rect(surface, sword_handle, (offset_x + 6, 11, 4, 2))
    pygame.draw.rect(surface, sword_color, (offset_x + 7, 13, 2, 8))
    pygame.draw.rect(surface, YELLOW, (offset_x + 5, 12, 6, 1))  # Guard
    
    # Stab effect
    pygame.draw.rect(surface, WHITE, (offset_x + 6, 18, 1, 3))
    pygame.draw.rect(surface, WHITE, (offset_x + 9, 18, 1, 3))
    pygame.draw.rect(surface, YELLOW, (offset_x + 7, 20, 2, 2))
    
    return scale_surface(surface)


def scale_surface(surface, scale=PIXEL_SCALE):
    """Scale a surface up for that chunky 16-bit look"""
    w, h = surface.get_size()
    return pygame.transform.scale(surface, (w * scale, h * scale))


def draw_pixel_rect(surface, color, rect, scale=1):
    """Draw a rectangle with pixel-perfect edges"""
    pygame.draw.rect(surface, color, rect)


def create_chain_sprite(facing_right=True, frame=0):
    """Create Chain's sprite - the hero"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    # Body (tunic)
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (4, 6, 8, 7))
    
    # Head
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (5, 2, 6, 5))
    
    # Hair (blue-ish)
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (5, 1, 6, 2))
    pygame.draw.rect(surface, hair_color, (4, 2, 1, 2))
    if facing_right:
        pygame.draw.rect(surface, hair_color, (11, 2, 1, 3))
    else:
        pygame.draw.rect(surface, hair_color, (4, 2, 1, 3))
    
    # Eyes
    eye_color = DARK_BLUE
    if facing_right:
        pygame.draw.rect(surface, eye_color, (9, 4, 1, 1))
    else:
        pygame.draw.rect(surface, eye_color, (6, 4, 1, 1))
    
    # Legs (animated)
    leg_color = BROWN
    if frame % 2 == 0:
        pygame.draw.rect(surface, leg_color, (5, 13, 2, 3))
        pygame.draw.rect(surface, leg_color, (9, 13, 2, 3))
    else:
        pygame.draw.rect(surface, leg_color, (4, 13, 2, 3))
        pygame.draw.rect(surface, leg_color, (10, 13, 2, 3))
    
    # Boots
    boot_color = DARK_BROWN
    if frame % 2 == 0:
        pygame.draw.rect(surface, boot_color, (5, 15, 2, 1))
        pygame.draw.rect(surface, boot_color, (9, 15, 2, 1))
    else:
        pygame.draw.rect(surface, boot_color, (4, 15, 2, 1))
        pygame.draw.rect(surface, boot_color, (10, 15, 2, 1))
    
    # Belt
    belt_color = BROWN
    pygame.draw.rect(surface, belt_color, (4, 10, 8, 1))
    
    # Belt buckle (chain link symbol)
    pygame.draw.rect(surface, YELLOW, (7, 10, 2, 1))
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_chain_attack_sprite(facing_right=True):
    """Create Chain's attack sprite with sword"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    # Base character (offset to make room for sword)
    offset_x = 4 if facing_right else 4
    
    # Body
    body_color = TEAL
    pygame.draw.rect(surface, body_color, (offset_x + 4, 6, 8, 7))
    
    # Head
    skin_color = BEIGE
    pygame.draw.rect(surface, skin_color, (offset_x + 5, 2, 6, 5))
    
    # Hair
    hair_color = NAVY
    pygame.draw.rect(surface, hair_color, (offset_x + 5, 1, 6, 2))
    
    # Eyes
    eye_color = DARK_BLUE
    if facing_right:
        pygame.draw.rect(surface, eye_color, (offset_x + 9, 4, 1, 1))
    else:
        pygame.draw.rect(surface, eye_color, (offset_x + 6, 4, 1, 1))
    
    # Legs
    leg_color = BROWN
    pygame.draw.rect(surface, leg_color, (offset_x + 5, 13, 2, 3))
    pygame.draw.rect(surface, leg_color, (offset_x + 9, 13, 2, 3))
    
    # Sword
    sword_color = LIGHT_SLATE
    sword_handle = BROWN
    if facing_right:
        pygame.draw.rect(surface, sword_handle, (offset_x + 12, 6, 2, 3))
        pygame.draw.rect(surface, sword_color, (offset_x + 14, 4, 6, 2))
        pygame.draw.rect(surface, YELLOW, (offset_x + 12, 5, 3, 1))  # Guard
    else:
        pygame.draw.rect(surface, sword_handle, (offset_x - 2, 6, 2, 3))
        pygame.draw.rect(surface, sword_color, (offset_x - 8, 4, 6, 2))
        pygame.draw.rect(surface, YELLOW, (offset_x - 3, 5, 3, 1))  # Guard
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_slime_sprite(frame=0):
    """Create slime enemy sprite"""
    size = 12
    surface = create_pixel_surface(size, size)
    
    color = LIME
    dark = DARK_GREEN
    
    # Body (bouncy animation)
    if frame % 20 < 10:
        pygame.draw.rect(surface, dark, (1, 6, 10, 6))
        pygame.draw.rect(surface, color, (2, 4, 8, 6))
        pygame.draw.rect(surface, color, (3, 3, 6, 2))
    else:
        pygame.draw.rect(surface, dark, (0, 8, 12, 4))
        pygame.draw.rect(surface, color, (1, 6, 10, 4))
        pygame.draw.rect(surface, color, (2, 5, 8, 2))
    
    # Eyes
    pygame.draw.rect(surface, WHITE, (3, 5, 2, 2))
    pygame.draw.rect(surface, WHITE, (7, 5, 2, 2))
    pygame.draw.rect(surface, BLACK, (4, 6, 1, 1))
    pygame.draw.rect(surface, BLACK, (8, 6, 1, 1))
    
    return scale_surface(surface)


def create_bat_sprite(frame=0):
    """Create bat enemy sprite"""
    size = 14
    surface = create_pixel_surface(size, size)
    
    color = PURPLE
    dark = DARK_BLUE
    
    # Body
    pygame.draw.rect(surface, color, (5, 5, 4, 5))
    pygame.draw.rect(surface, dark, (6, 4, 2, 2))
    
    # Wings (animated)
    if frame % 10 < 5:
        # Wings up
        pygame.draw.rect(surface, color, (0, 3, 5, 3))
        pygame.draw.rect(surface, color, (9, 3, 5, 3))
        pygame.draw.rect(surface, color, (1, 2, 3, 2))
        pygame.draw.rect(surface, color, (10, 2, 3, 2))
    else:
        # Wings down
        pygame.draw.rect(surface, color, (0, 6, 5, 3))
        pygame.draw.rect(surface, color, (9, 6, 5, 3))
        pygame.draw.rect(surface, color, (1, 8, 3, 2))
        pygame.draw.rect(surface, color, (10, 8, 3, 2))
    
    # Eyes (red, menacing)
    pygame.draw.rect(surface, RED, (5, 5, 1, 1))
    pygame.draw.rect(surface, RED, (8, 5, 1, 1))
    
    # Ears
    pygame.draw.rect(surface, color, (5, 3, 1, 2))
    pygame.draw.rect(surface, color, (8, 3, 1, 2))
    
    return scale_surface(surface)


def create_knight_sprite(facing_right=True, frame=0):
    """Create knight enemy sprite - armored and tough"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    armor_color = SLATE
    armor_dark = GRAY
    visor_color = DARK_BLUE
    
    # Body (armor)
    pygame.draw.rect(surface, armor_dark, (4, 6, 8, 7))
    pygame.draw.rect(surface, armor_color, (5, 5, 6, 6))
    
    # Helmet
    pygame.draw.rect(surface, armor_dark, (4, 1, 8, 5))
    pygame.draw.rect(surface, armor_color, (5, 2, 6, 3))
    
    # Visor
    pygame.draw.rect(surface, visor_color, (6, 3, 4, 2))
    pygame.draw.rect(surface, RED, (7, 3, 1, 1))  # Glowing eye
    pygame.draw.rect(surface, RED, (9, 3, 1, 1))  # Glowing eye
    
    # Shield
    if facing_right:
        pygame.draw.rect(surface, armor_dark, (2, 6, 3, 5))
        pygame.draw.rect(surface, armor_color, (2, 7, 2, 3))
    else:
        pygame.draw.rect(surface, armor_dark, (11, 6, 3, 5))
        pygame.draw.rect(surface, armor_color, (12, 7, 2, 3))
    
    # Sword
    sword_color = LIGHT_SLATE
    if facing_right:
        pygame.draw.rect(surface, sword_color, (12, 4, 2, 6))
        pygame.draw.rect(surface, sword_color, (13, 2, 1, 3))
    else:
        pygame.draw.rect(surface, sword_color, (2, 4, 2, 6))
        pygame.draw.rect(surface, sword_color, (2, 2, 1, 3))
    
    # Legs (armored)
    if frame % 2 == 0:
        pygame.draw.rect(surface, armor_dark, (5, 13, 2, 3))
        pygame.draw.rect(surface, armor_dark, (9, 13, 2, 3))
    else:
        pygame.draw.rect(surface, armor_dark, (4, 13, 2, 3))
        pygame.draw.rect(surface, armor_dark, (10, 13, 2, 3))
    
    if not facing_right:
        surface = pygame.transform.flip(surface, True, False)
    
    return scale_surface(surface)


def create_cannon_sprite(frame=0):
    """Create Cannon (boss) sprite - the archenemy"""
    size = 24
    surface = create_pixel_surface(size, size)
    
    # Cape
    cape_color = DARK_RED
    pygame.draw.rect(surface, cape_color, (2, 6, 20, 14))
    pygame.draw.rect(surface, RED, (4, 8, 16, 10))
    
    # Body (dark armor)
    armor_color = DARK_BLUE
    armor_accent = NAVY
    pygame.draw.rect(surface, armor_color, (7, 6, 10, 10))
    pygame.draw.rect(surface, armor_accent, (8, 7, 8, 8))
    
    # Head (helmet with crown)
    pygame.draw.rect(surface, armor_color, (8, 1, 8, 6))
    pygame.draw.rect(surface, DARK_RED, (9, 3, 6, 3))  # Visor
    
    # Crown spikes
    pygame.draw.rect(surface, YELLOW, (8, 0, 2, 2))
    pygame.draw.rect(surface, YELLOW, (11, 0, 2, 1))
    pygame.draw.rect(surface, YELLOW, (14, 0, 2, 2))
    
    # Evil eyes
    pygame.draw.rect(surface, YELLOW, (10, 3, 1, 1))
    pygame.draw.rect(surface, YELLOW, (13, 3, 1, 1))
    
    # Cannon arm (signature weapon)
    cannon_color = GRAY
    if frame % 30 < 15:
        pygame.draw.rect(surface, cannon_color, (17, 8, 6, 4))
        pygame.draw.rect(surface, DARK_BROWN, (16, 9, 2, 2))
        pygame.draw.rect(surface, ORANGE, (22, 9, 2, 2))  # Charging
    else:
        pygame.draw.rect(surface, cannon_color, (17, 8, 6, 4))
        pygame.draw.rect(surface, DARK_BROWN, (16, 9, 2, 2))
    
    # Legs
    pygame.draw.rect(surface, armor_color, (8, 16, 3, 6))
    pygame.draw.rect(surface, armor_color, (13, 16, 3, 6))
    pygame.draw.rect(surface, DARK_BROWN, (8, 21, 3, 2))
    pygame.draw.rect(surface, DARK_BROWN, (13, 21, 3, 2))
    
    return scale_surface(surface)


def create_heart_sprite(full=True, is_container=False):
    """Create heart sprite for health display"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if is_container:
        color = YELLOW
        outline = ORANGE
    elif full:
        color = RED
        outline = DARK_RED
    else:
        color = GRAY
        outline = DARK_BROWN
    
    # Heart shape
    pygame.draw.rect(surface, outline, (1, 2, 3, 3))
    pygame.draw.rect(surface, outline, (6, 2, 3, 3))
    pygame.draw.rect(surface, outline, (0, 3, 2, 3))
    pygame.draw.rect(surface, outline, (8, 3, 2, 3))
    pygame.draw.rect(surface, outline, (2, 5, 6, 3))
    pygame.draw.rect(surface, outline, (3, 8, 4, 1))
    pygame.draw.rect(surface, outline, (4, 9, 2, 1))
    
    # Fill
    pygame.draw.rect(surface, color, (2, 3, 2, 2))
    pygame.draw.rect(surface, color, (6, 3, 2, 2))
    pygame.draw.rect(surface, color, (1, 4, 2, 2))
    pygame.draw.rect(surface, color, (7, 4, 2, 2))
    pygame.draw.rect(surface, color, (3, 5, 4, 2))
    pygame.draw.rect(surface, color, (4, 7, 2, 1))
    
    # Highlight
    if full or is_container:
        pygame.draw.rect(surface, WHITE, (2, 3, 1, 1))
    
    return scale_surface(surface)


def create_magic_sprite(full=True, is_bottle=False):
    """Create magic point sprite (star/crystal)"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if is_bottle:
        color = MAGENTA
        outline = PURPLE
    elif full:
        color = CYAN
        outline = TEAL
    else:
        color = GRAY
        outline = DARK_BROWN
    
    # Crystal/star shape
    pygame.draw.rect(surface, outline, (4, 0, 2, 2))
    pygame.draw.rect(surface, outline, (3, 2, 4, 2))
    pygame.draw.rect(surface, outline, (0, 3, 10, 2))
    pygame.draw.rect(surface, outline, (2, 5, 6, 2))
    pygame.draw.rect(surface, outline, (3, 7, 4, 2))
    pygame.draw.rect(surface, outline, (4, 9, 2, 1))
    
    # Fill
    pygame.draw.rect(surface, color, (4, 1, 2, 1))
    pygame.draw.rect(surface, color, (3, 3, 4, 1))
    pygame.draw.rect(surface, color, (1, 4, 8, 1))
    pygame.draw.rect(surface, color, (3, 5, 4, 1))
    pygame.draw.rect(surface, color, (4, 6, 2, 2))
    
    # Highlight
    if full or is_bottle:
        pygame.draw.rect(surface, WHITE, (4, 3, 1, 1))
    
    return scale_surface(surface)


def create_food_sprite(food_type='food'):
    """Create food item sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if food_type == 'feast':
        # Roasted chicken leg
        pygame.draw.rect(surface, TAN, (2, 2, 6, 5))
        pygame.draw.rect(surface, BEIGE, (3, 3, 4, 3))
        pygame.draw.rect(surface, BROWN, (1, 6, 2, 3))  # Bone
        pygame.draw.rect(surface, CREAM, (1, 8, 2, 1))
    else:
        # Apple
        pygame.draw.rect(surface, RED, (2, 3, 6, 5))
        pygame.draw.rect(surface, RED, (3, 2, 4, 1))
        pygame.draw.rect(surface, DARK_RED, (2, 6, 6, 2))
        pygame.draw.rect(surface, BROWN, (4, 0, 2, 3))  # Stem
        pygame.draw.rect(surface, GREEN, (5, 1, 2, 2))  # Leaf
        pygame.draw.rect(surface, WHITE, (3, 3, 1, 1))  # Highlight
    
    return scale_surface(surface)


def create_magic_vial_sprite(vial_type='magic_vial'):
    """Create magic vial sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    if vial_type == 'magic_potion':
        color = TEAL
        liquid = CYAN
    else:
        color = PURPLE
        liquid = MAGENTA
    
    # Bottle
    pygame.draw.rect(surface, LIGHT_GRAY, (3, 0, 4, 2))  # Cork
    pygame.draw.rect(surface, LIGHT_SLATE, (2, 2, 6, 2))  # Neck
    pygame.draw.rect(surface, LIGHT_SLATE, (1, 4, 8, 5))  # Body outline
    
    # Liquid
    pygame.draw.rect(surface, color, (2, 5, 6, 3))
    pygame.draw.rect(surface, liquid, (3, 6, 4, 2))
    
    # Highlight
    pygame.draw.rect(surface, WHITE, (2, 4, 1, 2))
    
    # Sparkle
    pygame.draw.rect(surface, WHITE, (5, 5, 1, 1))
    
    return scale_surface(surface)


def create_fireball_sprite(frame=0):
    """Create fireball projectile sprite"""
    size = 10
    surface = create_pixel_surface(size, size)
    
    # Core
    pygame.draw.rect(surface, YELLOW, (3, 3, 4, 4))
    pygame.draw.rect(surface, WHITE, (4, 4, 2, 2))
    
    # Flames (animated)
    if frame % 4 < 2:
        pygame.draw.rect(surface, ORANGE, (2, 2, 2, 2))
        pygame.draw.rect(surface, ORANGE, (6, 2, 2, 2))
        pygame.draw.rect(surface, ORANGE, (2, 6, 2, 2))
        pygame.draw.rect(surface, ORANGE, (6, 6, 2, 2))
        pygame.draw.rect(surface, RED, (1, 4, 2, 2))
    else:
        pygame.draw.rect(surface, ORANGE, (1, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (7, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (1, 5, 2, 2))
        pygame.draw.rect(surface, ORANGE, (7, 5, 2, 2))
        pygame.draw.rect(surface, RED, (0, 4, 2, 2))
    
    return scale_surface(surface)


def create_thunder_sprite(frame=0):
    """Create thunder effect sprite"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    # Lightning bolt shape
    color = YELLOW if frame % 4 < 2 else WHITE
    
    pygame.draw.rect(surface, color, (8, 0, 3, 4))
    pygame.draw.rect(surface, color, (6, 3, 4, 3))
    pygame.draw.rect(surface, color, (4, 5, 6, 3))
    pygame.draw.rect(surface, color, (6, 7, 4, 3))
    pygame.draw.rect(surface, color, (8, 9, 3, 4))
    pygame.draw.rect(surface, color, (10, 12, 2, 4))
    
    return scale_surface(surface)


def create_shield_effect_sprite(frame=0):
    """Create shield buff visual effect"""
    size = 20
    surface = create_pixel_surface(size, size)
    
    # Shimmering shield
    alpha = 128 + int(64 * ((frame % 30) / 30))
    color = (*CYAN[:3], alpha)
    
    # Circular shield
    for i in range(8):
        angle_offset = (frame * 3 + i * 45) % 360
        x = int(10 + 7 * (1 if i % 2 == 0 else -1) * ((frame + i * 5) % 10) / 10)
        y = int(10 + 7 * (1 if i < 4 else -1) * ((frame + i * 5) % 10) / 10)
        pygame.draw.rect(surface, CYAN, (x, y, 2, 2))
    
    # Border
    pygame.draw.rect(surface, TEAL, (0, 8, 2, 4))
    pygame.draw.rect(surface, TEAL, (18, 8, 2, 4))
    pygame.draw.rect(surface, TEAL, (8, 0, 4, 2))
    pygame.draw.rect(surface, TEAL, (8, 18, 4, 2))
    
    return scale_surface(surface)


def create_tile_sprite(tile_type, variant=0):
    """Create tile sprites for levels"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    if tile_type == 'grass':
        pygame.draw.rect(surface, GREEN, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIME, (0, 0, 16, 4))
        # Grass detail
        for i in range(4):
            x = (i * 4 + variant) % 16
            pygame.draw.rect(surface, DARK_GREEN, (x, 4, 1, 2))
    
    elif tile_type == 'dirt':
        pygame.draw.rect(surface, BROWN, (0, 0, 16, 16))
        pygame.draw.rect(surface, TAN, (2, 2, 3, 2))
        pygame.draw.rect(surface, TAN, (10, 8, 4, 3))
        pygame.draw.rect(surface, DARK_BROWN, (6, 12, 2, 2))
    
    elif tile_type == 'stone':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIGHT_GRAY, (1, 1, 6, 5))
        pygame.draw.rect(surface, LIGHT_GRAY, (9, 8, 5, 6))
        pygame.draw.rect(surface, DARK_BROWN, (0, 7, 16, 1))
        pygame.draw.rect(surface, DARK_BROWN, (7, 0, 1, 16))
    
    elif tile_type == 'brick':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        # Brick pattern
        pygame.draw.rect(surface, RED, (1, 1, 6, 6))
        pygame.draw.rect(surface, RED, (9, 1, 6, 6))
        pygame.draw.rect(surface, RED, (1, 9, 14, 6))
        pygame.draw.rect(surface, BROWN, (0, 7, 16, 2))
        pygame.draw.rect(surface, BROWN, (7, 0, 2, 8))
    
    elif tile_type == 'wood':
        pygame.draw.rect(surface, BROWN, (0, 0, 16, 16))
        # Wood grain
        for i in range(4):
            y = i * 4 + 1
            pygame.draw.rect(surface, TAN, (0, y, 16, 2))
        pygame.draw.rect(surface, DARK_BROWN, (4, 0, 1, 16))
        pygame.draw.rect(surface, DARK_BROWN, (11, 0, 1, 16))
    
    elif tile_type == 'water':
        base = TEAL if variant % 2 == 0 else SKY_BLUE
        pygame.draw.rect(surface, base, (0, 0, 16, 16))
        # Waves
        wave_color = CYAN
        for i in range(3):
            x = (i * 6 + variant * 2) % 16
            pygame.draw.rect(surface, wave_color, (x, 4, 4, 1))
            pygame.draw.rect(surface, wave_color, ((x + 3) % 16, 10, 4, 1))
    
    elif tile_type == 'lava':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        pygame.draw.rect(surface, RED, (2, 2, 5, 4))
        pygame.draw.rect(surface, RED, (9, 7, 5, 5))
        pygame.draw.rect(surface, ORANGE, (3, 3, 2, 2))
        pygame.draw.rect(surface, ORANGE, (10, 9, 3, 2))
        pygame.draw.rect(surface, YELLOW, (4, 3, 1, 1))
    
    elif tile_type == 'sky':
        pygame.draw.rect(surface, SKY_BLUE, (0, 0, 16, 16))
        if variant % 3 == 0:
            # Cloud
            pygame.draw.rect(surface, WHITE, (2, 4, 8, 4))
            pygame.draw.rect(surface, WHITE, (4, 2, 4, 2))
    
    return scale_surface(surface)


def create_world_map_tile(tile_type):
    """Create tiles for the world map"""
    size = 16
    surface = create_pixel_surface(size, size)
    
    if tile_type == 'grass':
        pygame.draw.rect(surface, GREEN, (0, 0, 16, 16))
        pygame.draw.rect(surface, LIME, (3, 3, 2, 2))
        pygame.draw.rect(surface, LIME, (10, 8, 2, 2))
        pygame.draw.rect(surface, DARK_GREEN, (7, 12, 2, 2))
    
    elif tile_type == 'forest':
        pygame.draw.rect(surface, DARK_GREEN, (0, 0, 16, 16))
        # Trees
        pygame.draw.rect(surface, GREEN, (2, 4, 4, 6))
        pygame.draw.rect(surface, GREEN, (10, 2, 4, 8))
        pygame.draw.rect(surface, BROWN, (3, 10, 2, 4))
        pygame.draw.rect(surface, BROWN, (11, 10, 2, 4))
    
    elif tile_type == 'mountain':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        # Mountain peak
        pygame.draw.rect(surface, SLATE, (6, 0, 4, 6))
        pygame.draw.rect(surface, SLATE, (4, 6, 8, 4))
        pygame.draw.rect(surface, SLATE, (2, 10, 12, 6))
        pygame.draw.rect(surface, WHITE, (7, 1, 2, 3))  # Snow cap
    
    elif tile_type == 'water':
        pygame.draw.rect(surface, NAVY, (0, 0, 16, 16))
        pygame.draw.rect(surface, TEAL, (2, 4, 6, 2))
        pygame.draw.rect(surface, TEAL, (8, 10, 6, 2))
    
    elif tile_type == 'path':
        # Full path tile that connects in all directions
        pygame.draw.rect(surface, TAN, (0, 0, 16, 16))
        # Add some texture/detail
        pygame.draw.rect(surface, BEIGE, (2, 2, 4, 4))
        pygame.draw.rect(surface, BEIGE, (10, 10, 4, 4))
        pygame.draw.rect(surface, BROWN, (7, 6, 2, 2))
        pygame.draw.rect(surface, BROWN, (1, 12, 2, 2))
        pygame.draw.rect(surface, BROWN, (12, 2, 2, 2))
    
    elif tile_type == 'castle':
        pygame.draw.rect(surface, GRAY, (0, 0, 16, 16))
        # Castle structure
        pygame.draw.rect(surface, SLATE, (2, 4, 12, 12))
        pygame.draw.rect(surface, SLATE, (0, 2, 4, 4))
        pygame.draw.rect(surface, SLATE, (12, 2, 4, 4))
        pygame.draw.rect(surface, DARK_BLUE, (6, 10, 4, 6))  # Door
        pygame.draw.rect(surface, RED, (2, 0, 2, 3))  # Flag
    
    elif tile_type == 'cave':
        pygame.draw.rect(surface, DARK_BROWN, (0, 0, 16, 16))
        pygame.draw.rect(surface, BLACK, (4, 6, 8, 10))
        pygame.draw.rect(surface, DARK_BROWN, (2, 4, 12, 4))
    
    elif tile_type == 'fortress':
        # Cannon's Domain entrance - dark fortress
        pygame.draw.rect(surface, DARK_BLUE, (0, 0, 16, 16))
        # Fortress walls
        pygame.draw.rect(surface, NAVY, (1, 2, 14, 14))
        pygame.draw.rect(surface, DARK_BROWN, (3, 4, 10, 10))
        # Gate
        pygame.draw.rect(surface, BLACK, (5, 8, 6, 8))
        # Spikes on top
        pygame.draw.rect(surface, GRAY, (2, 1, 2, 4))
        pygame.draw.rect(surface, GRAY, (7, 1, 2, 4))
        pygame.draw.rect(surface, GRAY, (12, 1, 2, 4))
        # Red glow
        pygame.draw.rect(surface, RED, (6, 9, 4, 2))
    
    elif tile_type == 'boss':
        pygame.draw.rect(surface, DARK_RED, (0, 0, 16, 16))
        # Evil castle
        pygame.draw.rect(surface, DARK_BLUE, (2, 4, 12, 12))
        pygame.draw.rect(surface, DARK_BLUE, (0, 2, 4, 4))
        pygame.draw.rect(surface, DARK_BLUE, (12, 2, 4, 4))
        pygame.draw.rect(surface, BLACK, (6, 10, 4, 6))
        pygame.draw.rect(surface, YELLOW, (4, 6, 2, 2))  # Evil eye
        pygame.draw.rect(surface, YELLOW, (10, 6, 2, 2))  # Evil eye
    
    elif tile_type == 'level_marker':
        pygame.draw.rect(surface, YELLOW, (4, 4, 8, 8))
        pygame.draw.rect(surface, ORANGE, (6, 6, 4, 4))
    
    return scale_surface(surface)


def create_chain_world_sprite(facing='down', frame=0):
    """Create Chain sprite for world map (top-down view)"""
    size = 12
    surface = create_pixel_surface(size, size)
    
    # Body
    pygame.draw.rect(surface, TEAL, (3, 3, 6, 6))
    
    # Head direction
    skin = BEIGE
    hair = NAVY
    
    if facing == 'down':
        pygame.draw.rect(surface, hair, (4, 2, 4, 2))
        pygame.draw.rect(surface, skin, (4, 4, 4, 3))
        pygame.draw.rect(surface, DARK_BLUE, (5, 5, 1, 1))
        pygame.draw.rect(surface, DARK_BLUE, (7, 5, 1, 1))
    elif facing == 'up':
        pygame.draw.rect(surface, hair, (4, 2, 4, 4))
        pygame.draw.rect(surface, skin, (5, 5, 2, 2))
    elif facing == 'left':
        pygame.draw.rect(surface, hair, (3, 2, 4, 3))
        pygame.draw.rect(surface, skin, (3, 4, 3, 3))
        pygame.draw.rect(surface, DARK_BLUE, (3, 5, 1, 1))
    elif facing == 'right':
        pygame.draw.rect(surface, hair, (5, 2, 4, 3))
        pygame.draw.rect(surface, skin, (6, 4, 3, 3))
        pygame.draw.rect(surface, DARK_BLUE, (8, 5, 1, 1))
    
    # Feet (animated)
    if frame % 20 < 10:
        pygame.draw.rect(surface, BROWN, (3, 9, 2, 2))
        pygame.draw.rect(surface, BROWN, (7, 9, 2, 2))
    else:
        pygame.draw.rect(surface, BROWN, (4, 9, 2, 2))
        pygame.draw.rect(surface, BROWN, (6, 9, 2, 2))
    
    return scale_surface(surface)

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import (create_chain_sprite, create_chain_attack_sprite, 
                     create_chain_up_attack_sprite, create_chain_down_attack_sprite,
                     create_chain_world_sprite)
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            if self.is_up_attack:
                self.image = create_chain_up_attack_sprite(self.facing_right)
            else:
                self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up for up-slash)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
                self.is_up_attack = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        # Up slash attack
        if self.is_up_attack:
            return pygame.Rect(
                self.rect.centerx - 15,
                self.rect.top - 35,
                30,
                40
            )
        
        # Normal horizontal attack
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import (create_chain_sprite, create_chain_attack_sprite, 
                     create_chain_up_attack_sprite, create_chain_down_attack_sprite,
                     create_chain_world_sprite)
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        self.is_down_attack = False  # For downward stab
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            if self.is_up_attack:
                self.image = create_chain_up_attack_sprite(self.facing_right)
            else:
                self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up for up-slash)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
                self.is_up_attack = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        # Up slash attack
        if self.is_up_attack:
            return pygame.Rect(
                self.rect.centerx - 15,
                self.rect.top - 35,
                30,
                40
            )
        
        # Normal horizontal attack
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import (create_chain_sprite, create_chain_attack_sprite, 
                     create_chain_up_attack_sprite, create_chain_down_attack_sprite,
                     create_chain_world_sprite)
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        self.is_down_attack = False  # For downward stab
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            if self.is_up_attack:
                self.image = create_chain_up_attack_sprite(self.facing_right)
            else:
                self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up/down for directional attacks)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                    # Check if down is held for down-stab (only in air)
                    self.is_down_attack = (keys[pygame.K_DOWN] or keys[pygame.K_s]) and not self.on_ground
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
                self.is_up_attack = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        # Up slash attack
        if self.is_up_attack:
            return pygame.Rect(
                self.rect.centerx - 15,
                self.rect.top - 35,
                30,
                40
            )
        
        # Normal horizontal attack
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import (create_chain_sprite, create_chain_attack_sprite, 
                     create_chain_up_attack_sprite, create_chain_down_attack_sprite,
                     create_chain_world_sprite)
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        self.is_down_attack = False  # For downward stab
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            if self.is_up_attack:
                self.image = create_chain_up_attack_sprite(self.facing_right)
            else:
                self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up/down for directional attacks)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                    # Check if down is held for down-stab (only in air)
                    self.is_down_attack = (keys[pygame.K_DOWN] or keys[pygame.K_s]) and not self.on_ground
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
                self.is_up_attack = False
                self.is_down_attack = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        # Up slash attack
        if self.is_up_attack:
            return pygame.Rect(
                self.rect.centerx - 15,
                self.rect.top - 35,
                30,
                40
            )
        
        # Normal horizontal attack
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import (create_chain_sprite, create_chain_attack_sprite, 
                     create_chain_up_attack_sprite, create_chain_down_attack_sprite,
                     create_chain_world_sprite)
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        self.is_down_attack = False  # For downward stab
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            if self.is_up_attack:
                self.image = create_chain_up_attack_sprite(self.facing_right)
            elif self.is_down_attack:
                self.image = create_chain_down_attack_sprite(self.facing_right)
            else:
                self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up/down for directional attacks)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                    # Check if down is held for down-stab (only in air)
                    self.is_down_attack = (keys[pygame.K_DOWN] or keys[pygame.K_s]) and not self.on_ground
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
                self.is_up_attack = False
                self.is_down_attack = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        # Up slash attack
        if self.is_up_attack:
            return pygame.Rect(
                self.rect.centerx - 15,
                self.rect.top - 35,
                30,
                40
            )
        
        # Normal horizontal attack
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import (create_chain_sprite, create_chain_attack_sprite, 
                     create_chain_up_attack_sprite, create_chain_down_attack_sprite,
                     create_chain_world_sprite)
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        self.is_down_attack = False  # For downward stab
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            if self.is_up_attack:
                self.image = create_chain_up_attack_sprite(self.facing_right)
            elif self.is_down_attack:
                self.image = create_chain_down_attack_sprite(self.facing_right)
            else:
                self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up/down for directional attacks)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                    # Check if down is held for down-stab (only in air)
                    self.is_down_attack = (keys[pygame.K_DOWN] or keys[pygame.K_s]) and not self.on_ground
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
                self.is_up_attack = False
                self.is_down_attack = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        # Up slash attack
        if self.is_up_attack:
            return pygame.Rect(
                self.rect.centerx - 15,
                self.rect.top - 35,
                30,
                40
            )
        
        # Down stab attack
        if self.is_down_attack:
            return pygame.Rect(
                self.rect.centerx - 12,
                self.rect.bottom,
                24,
                40
            )
        
        # Normal horizontal attack
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

Now let me integrate the sound system into the game:

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
        elif event.key == pygame.K_RETURN:
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                else:
                    self.player.take_damage(enemy.damage)
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
        elif event.key == pygame.K_RETURN:
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                else:
                    self.player.take_damage(enemy.damage)
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
        elif event.key == pygame.K_RETURN:
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                else:
                    self.player.take_damage(enemy.damage)
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
        
        # Play appropriate music
        if level_marker.level_id == 'boss':
            self.sound.play_music('boss')
        else:
            self.sound.play_music('level')
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
        elif event.key == pygame.K_RETURN:
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                else:
                    self.player.take_damage(enemy.damage)
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
        
        # Play appropriate music
        if level_marker.level_id == 'boss':
            self.sound.play_music('boss')
        else:
            self.sound.play_music('level')
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
        elif event.key == pygame.K_RETURN:
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                else:
                    self.player.take_damage(enemy.damage)
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
        
        # Play appropriate music
        if level_marker.level_id == 'boss':
            self.sound.play_music('boss')
        else:
            self.sound.play_music('level')
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
                self.sound.play_sound('menu')
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_RETURN:
            self.sound.play_sound('menu')
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                else:
                    self.player.take_damage(enemy.damage)
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
        
        # Play appropriate music
        if level_marker.level_id == 'boss':
            self.sound.play_music('boss')
        else:
            self.sound.play_music('level')
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
                self.sound.play_sound('menu')
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_RETURN:
            self.sound.play_sound('menu')
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                else:
                    self.player.take_damage(enemy.damage)
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
        
        # Play appropriate music
        if level_marker.level_id == 'boss':
            self.sound.play_music('boss')
        else:
            self.sound.play_music('level')
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
                self.sound.play_sound('menu')
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_RETURN:
            self.sound.play_sound('menu')
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                else:
                    self.player.take_damage(enemy.damage)
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

Now let me add combat sound effects:

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
        
        # Play appropriate music
        if level_marker.level_id == 'boss':
            self.sound.play_music('boss')
        else:
            self.sound.play_music('level')
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
                self.sound.play_sound('menu')
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_RETURN:
            self.sound.play_sound('menu')
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    else:
                        self.sound.play_sound('hit')
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                else:
                    self.player.take_damage(enemy.damage)
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
        
        # Play appropriate music
        if level_marker.level_id == 'boss':
            self.sound.play_music('boss')
        else:
            self.sound.play_music('level')
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
                self.sound.play_sound('menu')
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_RETURN:
            self.sound.play_sound('menu')
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    else:
                        self.sound.play_sound('hit')
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                else:
                    self.player.take_damage(enemy.damage)
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
        
        # Play appropriate music
        if level_marker.level_id == 'boss':
            self.sound.play_music('boss')
        else:
            self.sound.play_music('level')
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
                self.sound.play_sound('menu')
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_RETURN:
            self.sound.play_sound('menu')
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    else:
                        self.sound.play_sound('hit')
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                else:
                    self.player.take_damage(enemy.damage)
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
        
        # Play appropriate music
        if level_marker.level_id == 'boss':
            self.sound.play_music('boss')
        else:
            self.sound.play_music('level')
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
                self.sound.play_sound('menu')
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_RETURN:
            self.sound.play_sound('menu')
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        self.current_level.item_manager.check_collection(self.player)
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    else:
                        self.sound.play_sound('hit')
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                    self.sound.play_sound('enemy_death')
                else:
                    if self.player.take_damage(enemy.damage):
                        pass  # Player died
                    else:
                        self.sound.play_sound('hit')
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

Now let me add pickup sounds and start the menu music:

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
        
        # Play appropriate music
        if level_marker.level_id == 'boss':
            self.sound.play_music('boss')
        else:
            self.sound.play_music('level')
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
                self.sound.play_sound('menu')
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_RETURN:
            self.sound.play_sound('menu')
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        items_before = len(self.current_level.item_manager.items)
        self.current_level.item_manager.check_collection(self.player)
        if len(self.current_level.item_manager.items) < items_before:
            self.sound.play_sound('pickup')
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    else:
                        self.sound.play_sound('hit')
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                    self.sound.play_sound('enemy_death')
                else:
                    if self.player.take_damage(enemy.damage):
                        pass  # Player died
                    else:
                        self.sound.play_sound('hit')
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
        
        # Play appropriate music
        if level_marker.level_id == 'boss':
            self.sound.play_music('boss')
        else:
            self.sound.play_music('level')
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
                self.sound.play_sound('menu')
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_RETURN:
            self.sound.play_sound('menu')
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        items_before = len(self.current_level.item_manager.items)
        self.current_level.item_manager.check_collection(self.player)
        if len(self.current_level.item_manager.items) < items_before:
            self.sound.play_sound('pickup')
        
        # Check enemy collisions
        self.check_combat()
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    else:
                        self.sound.play_sound('hit')
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                    self.sound.play_sound('enemy_death')
                else:
                    if self.player.take_damage(enemy.damage):
                        pass  # Player died
                    else:
                        self.sound.play_sound('hit')
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Start menu music if not playing
        if self.sound.current_music != 'menu':
            self.sound.play_music('menu')
        
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

Done! Here's what I added:

### Music System
Created a procedural 8-bit style music system with different tracks for:
- **Menu** - Calm, mysterious melody
- **World Map** - Adventurous, upbeat tune
- **Levels** - Energetic, fast-paced music
- **Boss Fight** - Intense, driving battle music

### Sound Effects
- **Attack** - Square wave slash sound
- **Jump** - Rising pitch effect
- **Hit** - When taking damage
- **Pickup** - Arpeggio chime for collecting items
- **Enemy Death** - Descending tone
- **Menu Navigation** - Click sounds

### Downward Stab Attack
- Press **Down + Z while in the air** to perform a downward stab
- Chain dives down with sword pointing below
- Great for hitting enemies beneath you while jumping
- Has a distinct diving sprite with the sword pointing down

The music and sounds are all procedurally generated using square waves and simple synthesis - no external audio files needed! The music loops automatically and changes based on game state.

---

**User**

Make it so that when you fall in a pit, You are... spawned back where you were last standing. with one heart less.

---

**Cursor**

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import (create_chain_sprite, create_chain_attack_sprite, 
                     create_chain_up_attack_sprite, create_chain_down_attack_sprite,
                     create_chain_world_sprite)
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Last safe position (for pit respawn)
        self.last_safe_x = x
        self.last_safe_y = y
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        self.is_down_attack = False  # For downward stab
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            if self.is_up_attack:
                self.image = create_chain_up_attack_sprite(self.facing_right)
            elif self.is_down_attack:
                self.image = create_chain_down_attack_sprite(self.facing_right)
            else:
                self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up/down for directional attacks)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                    # Check if down is held for down-stab (only in air)
                    self.is_down_attack = (keys[pygame.K_DOWN] or keys[pygame.K_s]) and not self.on_ground
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
                self.is_up_attack = False
                self.is_down_attack = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        # Up slash attack
        if self.is_up_attack:
            return pygame.Rect(
                self.rect.centerx - 15,
                self.rect.top - 35,
                30,
                40
            )
        
        # Down stab attack
        if self.is_down_attack:
            return pygame.Rect(
                self.rect.centerx - 12,
                self.rect.bottom,
                24,
                40
            )
        
        # Normal horizontal attack
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import (create_chain_sprite, create_chain_attack_sprite, 
                     create_chain_up_attack_sprite, create_chain_down_attack_sprite,
                     create_chain_world_sprite)
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Last safe position (for pit respawn)
        self.last_safe_x = x
        self.last_safe_y = y
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        self.is_down_attack = False  # For downward stab
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            if self.is_up_attack:
                self.image = create_chain_up_attack_sprite(self.facing_right)
            elif self.is_down_attack:
                self.image = create_chain_down_attack_sprite(self.facing_right)
            else:
                self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up/down for directional attacks)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                    # Check if down is held for down-stab (only in air)
                    self.is_down_attack = (keys[pygame.K_DOWN] or keys[pygame.K_s]) and not self.on_ground
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
                self.is_up_attack = False
                self.is_down_attack = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                        # Save safe position when landing
                        self.last_safe_x = self.rect.x
                        self.last_safe_y = self.rect.y
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        # Up slash attack
        if self.is_up_attack:
            return pygame.Rect(
                self.rect.centerx - 15,
                self.rect.top - 35,
                30,
                40
            )
        
        # Down stab attack
        if self.is_down_attack:
            return pygame.Rect(
                self.rect.centerx - 12,
                self.rect.bottom,
                24,
                40
            )
        
        # Normal horizontal attack
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0

```

```python
"""
Player (Chain) class for the game
"""

import pygame
from settings import *
from sprites import (create_chain_sprite, create_chain_attack_sprite, 
                     create_chain_up_attack_sprite, create_chain_down_attack_sprite,
                     create_chain_world_sprite)
from spells import SpellManager


class Player(pygame.sprite.Sprite):
    """The main character - Chain"""
    
    def __init__(self, x, y, mode='level'):
        super().__init__()
        self.mode = mode  # 'level' for side-scroller, 'world' for top-down
        
        # Animation
        self.frame = 0
        self.facing_right = True
        self.facing = 'down'  # For world map
        self.is_attacking = False
        self.attack_frame = 0
        
        # Create sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
        
        # Physics (for side-scroller)
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = False
        
        # Last safe position (for pit respawn)
        self.last_safe_x = x
        self.last_safe_y = y
        
        # Stats
        self.max_health = PLAYER_MAX_HEALTH
        self.health = self.max_health
        self.max_magic = PLAYER_MAX_MAGIC
        self.magic = self.max_magic
        
        # Combat
        self.attack_cooldown = 0
        self.invincibility = 0
        self.is_hurt = False
        self.is_up_attack = False  # For upward slash
        self.is_down_attack = False  # For downward stab
        
        # Spells
        self.spell_manager = SpellManager()
        
        # Score
        self.score = 0
        
        # Invincible mode (cheat)
        self.invincible_mode = False
        self.invincible_frame = 0
    
    def update_sprite(self):
        """Update the current sprite based on state"""
        if self.mode == 'world':
            self.image = create_chain_world_sprite(self.facing, self.frame)
        elif self.is_attacking:
            if self.is_up_attack:
                self.image = create_chain_up_attack_sprite(self.facing_right)
            elif self.is_down_attack:
                self.image = create_chain_down_attack_sprite(self.facing_right)
            else:
                self.image = create_chain_attack_sprite(self.facing_right)
        else:
            self.image = create_chain_sprite(self.facing_right, self.frame)
    
    def handle_input(self, keys, events):
        """Handle player input"""
        if self.mode == 'level':
            self.handle_level_input(keys, events)
        else:
            self.handle_world_input(keys, events)
    
    def handle_level_input(self, keys, events):
        """Handle input for side-scroller mode"""
        # Get speed multiplier from swift spell
        speed_mult = self.spell_manager.get_speed_multiplier()
        jump_mult = self.spell_manager.get_jump_multiplier()
        
        # Horizontal movement
        self.velocity_x = 0
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -PLAYER_SPEED * speed_mult
            self.facing_right = False
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = PLAYER_SPEED * speed_mult
            self.facing_right = True
        
        # Check for key events
        for event in events:
            if event.type == pygame.KEYDOWN:
                # Jump
                if event.key == pygame.K_SPACE and self.on_ground:
                    self.velocity_y = PLAYER_JUMP_SPEED * jump_mult
                    self.on_ground = False
                
                # Attack (check if holding up/down for directional attacks)
                if event.key == pygame.K_z and self.attack_cooldown <= 0:
                    self.is_attacking = True
                    self.attack_frame = 15
                    self.attack_cooldown = PLAYER_ATTACK_COOLDOWN
                    # Check if up is held for up-slash
                    self.is_up_attack = keys[pygame.K_UP] or keys[pygame.K_w]
                    # Check if down is held for down-stab (only in air)
                    self.is_down_attack = (keys[pygame.K_DOWN] or keys[pygame.K_s]) and not self.on_ground
                
                # Cast spell
                if event.key == pygame.K_x:
                    cost = self.spell_manager.cast_current_spell(
                        self, self.magic, self.facing_right
                    )
                    self.magic -= cost
                
                # Select spell (1-5)
                if event.key == pygame.K_1:
                    self.spell_manager.select_spell(0)
                if event.key == pygame.K_2:
                    self.spell_manager.select_spell(1)
                if event.key == pygame.K_3:
                    self.spell_manager.select_spell(2)
                if event.key == pygame.K_4:
                    self.spell_manager.select_spell(3)
                if event.key == pygame.K_5:
                    self.spell_manager.select_spell(4)
                
                # Toggle invincible mode
                if event.key == pygame.K_i:
                    self.invincible_mode = not self.invincible_mode
    
    def handle_world_input(self, keys, events):
        """Handle input for world map mode"""
        speed = WORLD_PLAYER_SPEED
        
        self.velocity_x = 0
        self.velocity_y = 0
        
        if keys[pygame.K_LEFT] or keys[pygame.K_a]:
            self.velocity_x = -speed
            self.facing = 'left'
        if keys[pygame.K_RIGHT] or keys[pygame.K_d]:
            self.velocity_x = speed
            self.facing = 'right'
        if keys[pygame.K_UP] or keys[pygame.K_w]:
            self.velocity_y = -speed
            self.facing = 'up'
        if keys[pygame.K_DOWN] or keys[pygame.K_s]:
            self.velocity_y = speed
            self.facing = 'down'
    
    def update(self, tiles=None):
        """Update player state"""
        self.frame += 1
        
        # Update cooldowns
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        if self.invincibility > 0:
            self.invincibility -= 1
            self.is_hurt = self.invincibility % 10 < 5  # Flashing effect
        else:
            self.is_hurt = False
        
        # Update attack animation
        if self.is_attacking:
            self.attack_frame -= 1
            if self.attack_frame <= 0:
                self.is_attacking = False
                self.is_up_attack = False
                self.is_down_attack = False
        
        # Update spells
        self.spell_manager.update()
        
        if self.mode == 'level':
            self.update_level_physics(tiles)
        else:
            self.update_world_movement(tiles)
        
        self.update_sprite()
    
    def update_level_physics(self, tiles):
        """Update physics for side-scroller mode"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:  # Terminal velocity
            self.velocity_y = 15
        
        # Move horizontally
        self.rect.x += self.velocity_x
        
        # Check horizontal collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_x > 0:
                        self.rect.right = tile.rect.left
                    elif self.velocity_x < 0:
                        self.rect.left = tile.rect.right
        
        # Move vertically
        self.rect.y += self.velocity_y
        
        # Check vertical collisions
        self.on_ground = False
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                        self.on_ground = True
                        # Save safe position when landing
                        self.last_safe_x = self.rect.x
                        self.last_safe_y = self.rect.y
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def update_world_movement(self, tiles):
        """Update movement for world map mode"""
        # Move and check collisions
        old_x, old_y = self.rect.x, self.rect.y
        
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if not tile.walkable and self.rect.colliderect(tile.rect):
                    self.rect.x = old_x
                    self.rect.y = old_y
                    break
    
    def take_damage(self, amount):
        """Take damage from an enemy or hazard"""
        # Invincible mode blocks all damage
        if self.invincible_mode:
            return False
        
        if self.invincibility > 0:
            return False
        
        # Apply shield damage reduction
        damage_mult = self.spell_manager.get_damage_multiplier()
        actual_damage = max(1, int(amount * damage_mult))
        
        self.health -= actual_damage
        self.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        if self.health <= 0:
            self.health = 0
            return True  # Player died
        return False
    
    def heal(self, amount):
        """Restore health"""
        self.health = min(self.max_health, self.health + amount)
    
    def restore_magic(self, amount):
        """Restore magic points"""
        self.magic = min(self.max_magic, self.magic + amount)
    
    def increase_max_health(self, amount=1):
        """Increase maximum health"""
        self.max_health += amount
        self.health += amount  # Also heal by the same amount
    
    def increase_max_magic(self, amount=1):
        """Increase maximum magic"""
        self.max_magic += amount
        self.magic += amount  # Also restore by the same amount
    
    def add_score(self, points):
        """Add to score"""
        self.score += points
    
    def get_attack_rect(self):
        """Get the attack hitbox"""
        if not self.is_attacking:
            return None
        
        # Up slash attack
        if self.is_up_attack:
            return pygame.Rect(
                self.rect.centerx - 15,
                self.rect.top - 35,
                30,
                40
            )
        
        # Down stab attack
        if self.is_down_attack:
            return pygame.Rect(
                self.rect.centerx - 12,
                self.rect.bottom,
                24,
                40
            )
        
        # Normal horizontal attack
        if self.facing_right:
            return pygame.Rect(
                self.rect.right,
                self.rect.centery - 10,
                30,
                20
            )
        else:
            return pygame.Rect(
                self.rect.left - 30,
                self.rect.centery - 10,
                30,
                20
            )
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw the player"""
        # Calculate draw position with camera offset
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.is_hurt and self.frame % 4 < 2:
            return  # Don't draw (flashing effect)
        
        # Rainbow shimmer effect when in invincible mode
        if self.invincible_mode:
            self.invincible_frame += 1
            # Create rainbow-tinted copy of sprite
            rainbow_img = self.image.copy()
            
            # Cycle through rainbow colors
            hue = (self.invincible_frame * 8) % 360
            # Convert hue to RGB (simplified rainbow)
            if hue < 60:
                r, g, b = 255, int(hue * 4.25), 0
            elif hue < 120:
                r, g, b = int((120 - hue) * 4.25), 255, 0
            elif hue < 180:
                r, g, b = 0, 255, int((hue - 120) * 4.25)
            elif hue < 240:
                r, g, b = 0, int((240 - hue) * 4.25), 255
            elif hue < 300:
                r, g, b = int((hue - 240) * 4.25), 0, 255
            else:
                r, g, b = 255, 0, int((360 - hue) * 4.25)
            
            # Apply rainbow tint
            rainbow_img.fill((r, g, b, 100), special_flags=pygame.BLEND_RGBA_ADD)
            
            # Draw with glow effect
            glow_surface = pygame.Surface((rainbow_img.get_width() + 8, rainbow_img.get_height() + 8), pygame.SRCALPHA)
            glow_surface.fill((r, g, b, 50))
            surface.blit(glow_surface, (draw_x - 4, draw_y - 4))
            surface.blit(rainbow_img, (draw_x, draw_y))
        else:
            surface.blit(self.image, (draw_x, draw_y))
        
        # Draw spell effects
        player_center = (
            self.rect.centerx - camera_offset[0],
            self.rect.centery - camera_offset[1]
        )
        self.spell_manager.draw(surface, player_center)
    
    def set_mode(self, mode):
        """Switch between level and world mode"""
        self.mode = mode
        self.velocity_x = 0
        self.velocity_y = 0
        self.update_sprite()
    
    def reset_position(self, x, y):
        """Reset player position"""
        self.rect.topleft = (x, y)
        self.velocity_x = 0
        self.velocity_y = 0
        self.last_safe_x = x
        self.last_safe_y = y
    
    def respawn_at_safe_position(self):
        """Respawn at last safe position after falling in pit"""
        self.rect.x = self.last_safe_x
        self.rect.y = self.last_safe_y
        self.velocity_x = 0
        self.velocity_y = 0
        self.on_ground = True
    
    def fell_in_pit(self, level_height):
        """Check if player fell below the level"""
        return self.rect.top > level_height + 100

```

Now let me add the pit detection to the game loop:

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
        
        # Play appropriate music
        if level_marker.level_id == 'boss':
            self.sound.play_music('boss')
        else:
            self.sound.play_music('level')
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
                self.sound.play_sound('menu')
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_RETURN:
            self.sound.play_sound('menu')
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        items_before = len(self.current_level.item_manager.items)
        self.current_level.item_manager.check_collection(self.player)
        if len(self.current_level.item_manager.items) < items_before:
            self.sound.play_sound('pickup')
        
        # Check enemy collisions
        self.check_combat()
        
        # Check if player fell in a pit
        if self.player.fell_in_pit(self.current_level.height):
            # Lose 1 health and respawn at last safe position
            self.player.health -= 1
            self.sound.play_sound('hit')
            if self.player.health <= 0:
                self.state = STATE_GAME_OVER
            else:
                self.player.respawn_at_safe_position()
                self.player.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    else:
                        self.sound.play_sound('hit')
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                    self.sound.play_sound('enemy_death')
                else:
                    if self.player.take_damage(enemy.damage):
                        pass  # Player died
                    else:
                        self.sound.play_sound('hit')
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Start menu music if not playing
        if self.sound.current_music != 'menu':
            self.sound.play_music('menu')
        
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

Done! Now when Chain falls into a pit:

1. **Loses 1 heart** of health
2. **Respawns at the last safe position** (where you were last standing on the ground)
3. Gets **invincibility frames** after respawning (so you don't immediately get hurt again)
4. If you have **no health left** when falling, it's game over

The game tracks your last safe position every time you land on solid ground, so you'll always respawn on the last platform you were standing on.

---

**User**

Let's add some harmony and chiptune rhythm to the soundtrack

---

**Cursor**

```python
"""
Sound and music system for Chain
Uses procedurally generated sounds and music
"""

import pygame
import math
import array


def init_sound():
    """Initialize the sound system"""
    pygame.mixer.init(frequency=22050, size=-16, channels=2, buffer=512)


def generate_square_wave(frequency, duration, volume=0.3):
    """Generate a square wave sound"""
    sample_rate = 22050
    n_samples = int(sample_rate * duration)
    
    buf = array.array('h')
    amplitude = int(32767 * volume)
    
    period = sample_rate / frequency
    
    for i in range(n_samples):
        if (i / period) % 1 < 0.5:
            buf.append(amplitude)
        else:
            buf.append(-amplitude)
    
    # Stereo
    stereo_buf = array.array('h')
    for sample in buf:
        stereo_buf.append(sample)
        stereo_buf.append(sample)
    
    sound = pygame.mixer.Sound(buffer=stereo_buf)
    return sound


def generate_noise(duration, volume=0.2):
    """Generate white noise"""
    import random
    sample_rate = 22050
    n_samples = int(sample_rate * duration)
    
    buf = array.array('h')
    amplitude = int(32767 * volume)
    
    for i in range(n_samples):
        buf.append(random.randint(-amplitude, amplitude))
    
    # Stereo
    stereo_buf = array.array('h')
    for sample in buf:
        stereo_buf.append(sample)
        stereo_buf.append(sample)
    
    sound = pygame.mixer.Sound(buffer=stereo_buf)
    return sound


def generate_melody(notes, tempo=120, volume=0.25):
    """Generate a melody from a list of (note, duration) tuples"""
    sample_rate = 22050
    beat_duration = 60 / tempo
    
    all_samples = array.array('h')
    
    # Note frequencies (A4 = 440Hz)
    note_freqs = {
        'C2': 65.41, 'D2': 73.42, 'E2': 82.41, 'F2': 87.31,
        'G2': 98.00, 'A2': 110.00, 'B2': 123.47,
        'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F3': 174.61, 
        'G3': 196.00, 'A3': 220.00, 'B3': 246.94,
        'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
        'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
        'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46,
        'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
        'REST': 0
    }
    
    for note, beats in notes:
        duration = beat_duration * beats
        n_samples = int(sample_rate * duration)
        
        if note == 'REST' or note not in note_freqs:
            # Silence
            for _ in range(n_samples):
                all_samples.append(0)
        else:
            freq = note_freqs[note]
            amplitude = int(32767 * volume)
            period = sample_rate / freq if freq > 0 else 1
            
            for i in range(n_samples):
                # Square wave with envelope
                envelope = 1.0
                if i < n_samples * 0.1:
                    envelope = i / (n_samples * 0.1)
                elif i > n_samples * 0.7:
                    envelope = (n_samples - i) / (n_samples * 0.3)
                
                if (i / period) % 1 < 0.5:
                    all_samples.append(int(amplitude * envelope))
                else:
                    all_samples.append(int(-amplitude * envelope))
    
    # Stereo
    stereo_buf = array.array('h')
    for sample in all_samples:
        stereo_buf.append(sample)
        stereo_buf.append(sample)
    
    sound = pygame.mixer.Sound(buffer=stereo_buf)
    return sound


def generate_chiptune_track(melody, bass, tempo=120, volume=0.2):
    """Generate a full chiptune track with melody, bass, and drums"""
    import random
    sample_rate = 22050
    beat_duration = 60 / tempo
    
    # Note frequencies
    note_freqs = {
        'C2': 65.41, 'D2': 73.42, 'E2': 82.41, 'F2': 87.31,
        'G2': 98.00, 'A2': 110.00, 'B2': 123.47,
        'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F3': 174.61, 
        'G3': 196.00, 'A3': 220.00, 'B3': 246.94,
        'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
        'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
        'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46,
        'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
        'REST': 0
    }
    
    # Calculate total duration
    total_beats = sum(beats for _, beats in melody)
    total_samples = int(sample_rate * beat_duration * total_beats)
    
    # Generate each channel
    melody_samples = array.array('h', [0] * total_samples)
    bass_samples = array.array('h', [0] * total_samples)
    drum_samples = array.array('h', [0] * total_samples)
    arp_samples = array.array('h', [0] * total_samples)
    
    # Generate melody (square wave, 25% duty cycle for that classic sound)
    sample_pos = 0
    for note, beats in melody:
        duration = beat_duration * beats
        n_samples = int(sample_rate * duration)
        
        if note != 'REST' and note in note_freqs:
            freq = note_freqs[note]
            amplitude = int(32767 * volume * 0.5)
            period = sample_rate / freq if freq > 0 else 1
            
            for i in range(min(n_samples, total_samples - sample_pos)):
                # 25% duty cycle square wave
                envelope = 1.0
                if i < n_samples * 0.05:
                    envelope = i / (n_samples * 0.05)
                elif i > n_samples * 0.8:
                    envelope = (n_samples - i) / (n_samples * 0.2)
                
                duty = 0.25
                if (i / period) % 1 < duty:
                    melody_samples[sample_pos + i] = int(amplitude * envelope)
                else:
                    melody_samples[sample_pos + i] = int(-amplitude * envelope * 0.3)
        
        sample_pos += n_samples
    
    # Generate bass (triangle wave for warmer sound)
    sample_pos = 0
    bass_idx = 0
    beats_elapsed = 0
    
    for note, beats in melody:
        duration = beat_duration * beats
        n_samples = int(sample_rate * duration)
        
        # Get corresponding bass note
        if bass_idx < len(bass):
            bass_note, bass_beats = bass[bass_idx % len(bass)]
            if bass_note != 'REST' and bass_note in note_freqs:
                freq = note_freqs[bass_note]
                amplitude = int(32767 * volume * 0.4)
                period = sample_rate / freq if freq > 0 else 1
                
                for i in range(min(n_samples, total_samples - sample_pos)):
                    # Triangle wave
                    t = (i / period) % 1
                    if t < 0.5:
                        val = t * 4 - 1
                    else:
                        val = 3 - t * 4
                    bass_samples[sample_pos + i] = int(amplitude * val * 0.7)
        
        sample_pos += n_samples
        beats_elapsed += beats
        if beats_elapsed >= (bass[bass_idx % len(bass)][1] if bass_idx < len(bass) else 1):
            bass_idx += 1
            beats_elapsed = 0
    
    # Generate drums (noise kicks and hi-hats)
    beat_samples = int(sample_rate * beat_duration)
    for beat in range(int(total_beats)):
        start = beat * beat_samples
        
        # Kick on beats 1 and 3 (every 2 beats in 4/4)
        if beat % 2 == 0:
            kick_len = min(int(beat_samples * 0.15), total_samples - start)
            for i in range(kick_len):
                # Descending pitch noise burst
                freq = 150 - (i / kick_len) * 100
                period = sample_rate / max(freq, 20)
                envelope = 1 - (i / kick_len)
                amplitude = int(32767 * volume * 0.5 * envelope)
                if (i / period) % 1 < 0.5:
                    drum_samples[start + i] += amplitude
                else:
                    drum_samples[start + i] -= amplitude
        
        # Hi-hat on every beat
        hat_start = start + int(beat_samples * 0.5) if beat % 2 == 1 else start
        if hat_start < total_samples:
            hat_len = min(int(beat_samples * 0.08), total_samples - hat_start)
            for i in range(hat_len):
                envelope = 1 - (i / hat_len)
                amplitude = int(32767 * volume * 0.15 * envelope)
                drum_samples[hat_start + i] += random.randint(-amplitude, amplitude)
    
    # Generate arpeggios (fast note sequences for texture)
    arp_notes = ['C4', 'E4', 'G4', 'C5']  # Major chord arpeggio
    arp_speed = beat_duration / 4  # 16th notes
    arp_samples_per_note = int(sample_rate * arp_speed)
    
    for i in range(0, total_samples, arp_samples_per_note):
        note_idx = (i // arp_samples_per_note) % len(arp_notes)
        note = arp_notes[note_idx]
        freq = note_freqs[note]
        amplitude = int(32767 * volume * 0.15)
        period = sample_rate / freq
        
        for j in range(min(arp_samples_per_note, total_samples - i)):
            envelope = 1 - (j / arp_samples_per_note) * 0.7
            # Pulse wave
            if (j / period) % 1 < 0.125:
                arp_samples[i + j] = int(amplitude * envelope)
    
    # Mix all channels
    mixed = array.array('h')
    for i in range(total_samples):
        # Combine and clip
        total = melody_samples[i] + bass_samples[i] + drum_samples[i] + arp_samples[i]
        total = max(-32767, min(32767, total))
        mixed.append(int(total))
    
    # Stereo with slight panning
    stereo_buf = array.array('h')
    for i, sample in enumerate(mixed):
        # Slight stereo variation
        left = int(sample * 0.9)
        right = int(sample * 1.0)
        stereo_buf.append(left)
        stereo_buf.append(right)
    
    return pygame.mixer.Sound(buffer=stereo_buf)


class SoundManager:
    """Manages all game sounds and music"""
    
    def __init__(self):
        init_sound()
        
        self.sounds = {}
        self.music = {}
        self.current_music = None
        self.music_enabled = True
        self.sound_enabled = True
        
        self._generate_sounds()
        self._generate_music()
    
    def _generate_sounds(self):
        """Generate all sound effects"""
        # Attack sound
        self.sounds['attack'] = generate_square_wave(200, 0.1, 0.2)
        
        # Jump sound
        self.sounds['jump'] = self._make_jump_sound()
        
        # Hit sound
        self.sounds['hit'] = generate_noise(0.15, 0.3)
        
        # Pickup sound
        self.sounds['pickup'] = self._make_pickup_sound()
        
        # Spell sounds
        self.sounds['spell'] = generate_square_wave(440, 0.2, 0.2)
        
        # Enemy death
        self.sounds['enemy_death'] = self._make_death_sound()
        
        # Menu select
        self.sounds['menu'] = generate_square_wave(330, 0.1, 0.15)
    
    def _make_jump_sound(self):
        """Create a jump sound effect (rising pitch)"""
        sample_rate = 22050
        duration = 0.15
        n_samples = int(sample_rate * duration)
        
        buf = array.array('h')
        volume = 0.2
        amplitude = int(32767 * volume)
        
        for i in range(n_samples):
            # Rising frequency
            t = i / n_samples
            freq = 150 + t * 400
            period = sample_rate / freq
            
            if (i / period) % 1 < 0.5:
                buf.append(int(amplitude * (1 - t * 0.5)))
            else:
                buf.append(int(-amplitude * (1 - t * 0.5)))
        
        stereo_buf = array.array('h')
        for sample in buf:
            stereo_buf.append(sample)
            stereo_buf.append(sample)
        
        return pygame.mixer.Sound(buffer=stereo_buf)
    
    def _make_pickup_sound(self):
        """Create a pickup sound effect (arpeggio)"""
        sample_rate = 22050
        
        buf = array.array('h')
        volume = 0.2
        amplitude = int(32767 * volume)
        
        freqs = [330, 440, 550, 660]  # Rising arpeggio
        
        for freq in freqs:
            duration = 0.05
            n_samples = int(sample_rate * duration)
            period = sample_rate / freq
            
            for i in range(n_samples):
                envelope = 1 - (i / n_samples) * 0.5
                if (i / period) % 1 < 0.5:
                    buf.append(int(amplitude * envelope))
                else:
                    buf.append(int(-amplitude * envelope))
        
        stereo_buf = array.array('h')
        for sample in buf:
            stereo_buf.append(sample)
            stereo_buf.append(sample)
        
        return pygame.mixer.Sound(buffer=stereo_buf)
    
    def _make_death_sound(self):
        """Create enemy death sound (descending)"""
        sample_rate = 22050
        duration = 0.2
        n_samples = int(sample_rate * duration)
        
        buf = array.array('h')
        volume = 0.25
        amplitude = int(32767 * volume)
        
        for i in range(n_samples):
            t = i / n_samples
            freq = 400 - t * 300
            period = sample_rate / freq if freq > 0 else 1
            
            if (i / period) % 1 < 0.5:
                buf.append(int(amplitude * (1 - t)))
            else:
                buf.append(int(-amplitude * (1 - t)))
        
        stereo_buf = array.array('h')
        for sample in buf:
            stereo_buf.append(sample)
            stereo_buf.append(sample)
        
        return pygame.mixer.Sound(buffer=stereo_buf)
    
    def _generate_music(self):
        """Generate background music tracks"""
        
        # Menu music - calm, mysterious
        menu_melody = [
            ('E4', 1), ('G4', 1), ('A4', 2),
            ('E4', 1), ('G4', 1), ('B4', 2),
            ('A4', 1), ('G4', 1), ('E4', 2),
            ('D4', 1), ('E4', 1), ('G4', 2),
            ('E4', 1), ('G4', 1), ('A4', 2),
            ('G4', 1), ('E4', 1), ('D4', 2),
            ('E4', 4),
            ('REST', 2),
        ]
        self.music['menu'] = generate_melody(menu_melody, tempo=80, volume=0.2)
        
        # World map music - adventurous
        world_melody = [
            ('C4', 1), ('E4', 1), ('G4', 1), ('C5', 1),
            ('B4', 1), ('G4', 1), ('E4', 1), ('G4', 1),
            ('A4', 1), ('F4', 1), ('A4', 1), ('C5', 1),
            ('G4', 2), ('E4', 2),
            ('C4', 1), ('D4', 1), ('E4', 1), ('F4', 1),
            ('G4', 2), ('A4', 1), ('G4', 1),
            ('F4', 1), ('E4', 1), ('D4', 1), ('C4', 1),
            ('E4', 4),
        ]
        self.music['world'] = generate_melody(world_melody, tempo=100, volume=0.2)
        
        # Level music - energetic
        level_melody = [
            ('E4', 0.5), ('E4', 0.5), ('E4', 0.5), ('REST', 0.5),
            ('E4', 0.5), ('G4', 0.5), ('E4', 1),
            ('D4', 0.5), ('D4', 0.5), ('D4', 0.5), ('REST', 0.5),
            ('D4', 0.5), ('F4', 0.5), ('D4', 1),
            ('E4', 0.5), ('E4', 0.5), ('G4', 0.5), ('G4', 0.5),
            ('A4', 0.5), ('A4', 0.5), ('G4', 1),
            ('F4', 0.5), ('E4', 0.5), ('D4', 0.5), ('E4', 0.5),
            ('E4', 2),
        ]
        self.music['level'] = generate_melody(level_melody, tempo=140, volume=0.2)
        
        # Boss music - intense
        boss_melody = [
            ('E3', 0.5), ('E3', 0.5), ('E4', 0.5), ('E3', 0.5),
            ('E3', 0.5), ('D4', 0.5), ('E3', 0.5), ('E3', 0.5),
            ('E3', 0.5), ('E3', 0.5), ('E4', 0.5), ('G4', 0.5),
            ('F4', 0.5), ('E4', 0.5), ('D4', 1),
            ('A3', 0.5), ('A3', 0.5), ('A4', 0.5), ('A3', 0.5),
            ('A3', 0.5), ('G4', 0.5), ('A3', 0.5), ('A3', 0.5),
            ('B3', 0.5), ('B3', 0.5), ('B4', 0.5), ('A4', 0.5),
            ('G4', 0.5), ('F4', 0.5), ('E4', 1),
        ]
        self.music['boss'] = generate_melody(boss_melody, tempo=160, volume=0.25)
    
    def play_sound(self, sound_name):
        """Play a sound effect"""
        if self.sound_enabled and sound_name in self.sounds:
            self.sounds[sound_name].play()
    
    def play_music(self, music_name):
        """Play background music (loops)"""
        if not self.music_enabled:
            return
        
        if music_name == self.current_music:
            return
        
        # Stop current music
        pygame.mixer.stop()
        
        if music_name in self.music:
            self.current_music = music_name
            # Loop the music by playing it repeatedly
            self.music[music_name].play(loops=-1)
    
    def stop_music(self):
        """Stop all music"""
        pygame.mixer.stop()
        self.current_music = None
    
    def toggle_music(self):
        """Toggle music on/off"""
        self.music_enabled = not self.music_enabled
        if not self.music_enabled:
            self.stop_music()
        return self.music_enabled
    
    def toggle_sound(self):
        """Toggle sound effects on/off"""
        self.sound_enabled = not self.sound_enabled
        return self.sound_enabled


# Global sound manager instance
_sound_manager = None


def get_sound_manager():
    """Get the global sound manager"""
    global _sound_manager
    if _sound_manager is None:
        _sound_manager = SoundManager()
    return _sound_manager

```

```python
"""
Sound and music system for Chain
Uses procedurally generated sounds and music
"""

import pygame
import math
import array


def init_sound():
    """Initialize the sound system"""
    pygame.mixer.init(frequency=22050, size=-16, channels=2, buffer=512)


def generate_square_wave(frequency, duration, volume=0.3):
    """Generate a square wave sound"""
    sample_rate = 22050
    n_samples = int(sample_rate * duration)
    
    buf = array.array('h')
    amplitude = int(32767 * volume)
    
    period = sample_rate / frequency
    
    for i in range(n_samples):
        if (i / period) % 1 < 0.5:
            buf.append(amplitude)
        else:
            buf.append(-amplitude)
    
    # Stereo
    stereo_buf = array.array('h')
    for sample in buf:
        stereo_buf.append(sample)
        stereo_buf.append(sample)
    
    sound = pygame.mixer.Sound(buffer=stereo_buf)
    return sound


def generate_noise(duration, volume=0.2):
    """Generate white noise"""
    import random
    sample_rate = 22050
    n_samples = int(sample_rate * duration)
    
    buf = array.array('h')
    amplitude = int(32767 * volume)
    
    for i in range(n_samples):
        buf.append(random.randint(-amplitude, amplitude))
    
    # Stereo
    stereo_buf = array.array('h')
    for sample in buf:
        stereo_buf.append(sample)
        stereo_buf.append(sample)
    
    sound = pygame.mixer.Sound(buffer=stereo_buf)
    return sound


def generate_melody(notes, tempo=120, volume=0.25):
    """Generate a melody from a list of (note, duration) tuples"""
    sample_rate = 22050
    beat_duration = 60 / tempo
    
    all_samples = array.array('h')
    
    # Note frequencies (A4 = 440Hz)
    note_freqs = {
        'C2': 65.41, 'D2': 73.42, 'E2': 82.41, 'F2': 87.31,
        'G2': 98.00, 'A2': 110.00, 'B2': 123.47,
        'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F3': 174.61, 
        'G3': 196.00, 'A3': 220.00, 'B3': 246.94,
        'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
        'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
        'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46,
        'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
        'REST': 0
    }
    
    for note, beats in notes:
        duration = beat_duration * beats
        n_samples = int(sample_rate * duration)
        
        if note == 'REST' or note not in note_freqs:
            # Silence
            for _ in range(n_samples):
                all_samples.append(0)
        else:
            freq = note_freqs[note]
            amplitude = int(32767 * volume)
            period = sample_rate / freq if freq > 0 else 1
            
            for i in range(n_samples):
                # Square wave with envelope
                envelope = 1.0
                if i < n_samples * 0.1:
                    envelope = i / (n_samples * 0.1)
                elif i > n_samples * 0.7:
                    envelope = (n_samples - i) / (n_samples * 0.3)
                
                if (i / period) % 1 < 0.5:
                    all_samples.append(int(amplitude * envelope))
                else:
                    all_samples.append(int(-amplitude * envelope))
    
    # Stereo
    stereo_buf = array.array('h')
    for sample in all_samples:
        stereo_buf.append(sample)
        stereo_buf.append(sample)
    
    sound = pygame.mixer.Sound(buffer=stereo_buf)
    return sound


def generate_chiptune_track(melody, bass, tempo=120, volume=0.2):
    """Generate a full chiptune track with melody, bass, and drums"""
    import random
    sample_rate = 22050
    beat_duration = 60 / tempo
    
    # Note frequencies
    note_freqs = {
        'C2': 65.41, 'D2': 73.42, 'E2': 82.41, 'F2': 87.31,
        'G2': 98.00, 'A2': 110.00, 'B2': 123.47,
        'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F3': 174.61, 
        'G3': 196.00, 'A3': 220.00, 'B3': 246.94,
        'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
        'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
        'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46,
        'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
        'REST': 0
    }
    
    # Calculate total duration
    total_beats = sum(beats for _, beats in melody)
    total_samples = int(sample_rate * beat_duration * total_beats)
    
    # Generate each channel
    melody_samples = array.array('h', [0] * total_samples)
    bass_samples = array.array('h', [0] * total_samples)
    drum_samples = array.array('h', [0] * total_samples)
    arp_samples = array.array('h', [0] * total_samples)
    
    # Generate melody (square wave, 25% duty cycle for that classic sound)
    sample_pos = 0
    for note, beats in melody:
        duration = beat_duration * beats
        n_samples = int(sample_rate * duration)
        
        if note != 'REST' and note in note_freqs:
            freq = note_freqs[note]
            amplitude = int(32767 * volume * 0.5)
            period = sample_rate / freq if freq > 0 else 1
            
            for i in range(min(n_samples, total_samples - sample_pos)):
                # 25% duty cycle square wave
                envelope = 1.0
                if i < n_samples * 0.05:
                    envelope = i / (n_samples * 0.05)
                elif i > n_samples * 0.8:
                    envelope = (n_samples - i) / (n_samples * 0.2)
                
                duty = 0.25
                if (i / period) % 1 < duty:
                    melody_samples[sample_pos + i] = int(amplitude * envelope)
                else:
                    melody_samples[sample_pos + i] = int(-amplitude * envelope * 0.3)
        
        sample_pos += n_samples
    
    # Generate bass (triangle wave for warmer sound)
    sample_pos = 0
    bass_idx = 0
    beats_elapsed = 0
    
    for note, beats in melody:
        duration = beat_duration * beats
        n_samples = int(sample_rate * duration)
        
        # Get corresponding bass note
        if bass_idx < len(bass):
            bass_note, bass_beats = bass[bass_idx % len(bass)]
            if bass_note != 'REST' and bass_note in note_freqs:
                freq = note_freqs[bass_note]
                amplitude = int(32767 * volume * 0.4)
                period = sample_rate / freq if freq > 0 else 1
                
                for i in range(min(n_samples, total_samples - sample_pos)):
                    # Triangle wave
                    t = (i / period) % 1
                    if t < 0.5:
                        val = t * 4 - 1
                    else:
                        val = 3 - t * 4
                    bass_samples[sample_pos + i] = int(amplitude * val * 0.7)
        
        sample_pos += n_samples
        beats_elapsed += beats
        if beats_elapsed >= (bass[bass_idx % len(bass)][1] if bass_idx < len(bass) else 1):
            bass_idx += 1
            beats_elapsed = 0
    
    # Generate drums (noise kicks and hi-hats)
    beat_samples = int(sample_rate * beat_duration)
    for beat in range(int(total_beats)):
        start = beat * beat_samples
        
        # Kick on beats 1 and 3 (every 2 beats in 4/4)
        if beat % 2 == 0:
            kick_len = min(int(beat_samples * 0.15), total_samples - start)
            for i in range(kick_len):
                # Descending pitch noise burst
                freq = 150 - (i / kick_len) * 100
                period = sample_rate / max(freq, 20)
                envelope = 1 - (i / kick_len)
                amplitude = int(32767 * volume * 0.5 * envelope)
                if (i / period) % 1 < 0.5:
                    drum_samples[start + i] += amplitude
                else:
                    drum_samples[start + i] -= amplitude
        
        # Hi-hat on every beat
        hat_start = start + int(beat_samples * 0.5) if beat % 2 == 1 else start
        if hat_start < total_samples:
            hat_len = min(int(beat_samples * 0.08), total_samples - hat_start)
            for i in range(hat_len):
                envelope = 1 - (i / hat_len)
                amplitude = int(32767 * volume * 0.15 * envelope)
                drum_samples[hat_start + i] += random.randint(-amplitude, amplitude)
    
    # Generate arpeggios (fast note sequences for texture)
    arp_notes = ['C4', 'E4', 'G4', 'C5']  # Major chord arpeggio
    arp_speed = beat_duration / 4  # 16th notes
    arp_samples_per_note = int(sample_rate * arp_speed)
    
    for i in range(0, total_samples, arp_samples_per_note):
        note_idx = (i // arp_samples_per_note) % len(arp_notes)
        note = arp_notes[note_idx]
        freq = note_freqs[note]
        amplitude = int(32767 * volume * 0.15)
        period = sample_rate / freq
        
        for j in range(min(arp_samples_per_note, total_samples - i)):
            envelope = 1 - (j / arp_samples_per_note) * 0.7
            # Pulse wave
            if (j / period) % 1 < 0.125:
                arp_samples[i + j] = int(amplitude * envelope)
    
    # Mix all channels
    mixed = array.array('h')
    for i in range(total_samples):
        # Combine and clip
        total = melody_samples[i] + bass_samples[i] + drum_samples[i] + arp_samples[i]
        total = max(-32767, min(32767, total))
        mixed.append(int(total))
    
    # Stereo with slight panning
    stereo_buf = array.array('h')
    for i, sample in enumerate(mixed):
        # Slight stereo variation
        left = int(sample * 0.9)
        right = int(sample * 1.0)
        stereo_buf.append(left)
        stereo_buf.append(right)
    
    return pygame.mixer.Sound(buffer=stereo_buf)


class SoundManager:
    """Manages all game sounds and music"""
    
    def __init__(self):
        init_sound()
        
        self.sounds = {}
        self.music = {}
        self.current_music = None
        self.music_enabled = True
        self.sound_enabled = True
        
        self._generate_sounds()
        self._generate_music()
    
    def _generate_sounds(self):
        """Generate all sound effects"""
        # Attack sound
        self.sounds['attack'] = generate_square_wave(200, 0.1, 0.2)
        
        # Jump sound
        self.sounds['jump'] = self._make_jump_sound()
        
        # Hit sound
        self.sounds['hit'] = generate_noise(0.15, 0.3)
        
        # Pickup sound
        self.sounds['pickup'] = self._make_pickup_sound()
        
        # Spell sounds
        self.sounds['spell'] = generate_square_wave(440, 0.2, 0.2)
        
        # Enemy death
        self.sounds['enemy_death'] = self._make_death_sound()
        
        # Menu select
        self.sounds['menu'] = generate_square_wave(330, 0.1, 0.15)
    
    def _make_jump_sound(self):
        """Create a jump sound effect (rising pitch)"""
        sample_rate = 22050
        duration = 0.15
        n_samples = int(sample_rate * duration)
        
        buf = array.array('h')
        volume = 0.2
        amplitude = int(32767 * volume)
        
        for i in range(n_samples):
            # Rising frequency
            t = i / n_samples
            freq = 150 + t * 400
            period = sample_rate / freq
            
            if (i / period) % 1 < 0.5:
                buf.append(int(amplitude * (1 - t * 0.5)))
            else:
                buf.append(int(-amplitude * (1 - t * 0.5)))
        
        stereo_buf = array.array('h')
        for sample in buf:
            stereo_buf.append(sample)
            stereo_buf.append(sample)
        
        return pygame.mixer.Sound(buffer=stereo_buf)
    
    def _make_pickup_sound(self):
        """Create a pickup sound effect (arpeggio)"""
        sample_rate = 22050
        
        buf = array.array('h')
        volume = 0.2
        amplitude = int(32767 * volume)
        
        freqs = [330, 440, 550, 660]  # Rising arpeggio
        
        for freq in freqs:
            duration = 0.05
            n_samples = int(sample_rate * duration)
            period = sample_rate / freq
            
            for i in range(n_samples):
                envelope = 1 - (i / n_samples) * 0.5
                if (i / period) % 1 < 0.5:
                    buf.append(int(amplitude * envelope))
                else:
                    buf.append(int(-amplitude * envelope))
        
        stereo_buf = array.array('h')
        for sample in buf:
            stereo_buf.append(sample)
            stereo_buf.append(sample)
        
        return pygame.mixer.Sound(buffer=stereo_buf)
    
    def _make_death_sound(self):
        """Create enemy death sound (descending)"""
        sample_rate = 22050
        duration = 0.2
        n_samples = int(sample_rate * duration)
        
        buf = array.array('h')
        volume = 0.25
        amplitude = int(32767 * volume)
        
        for i in range(n_samples):
            t = i / n_samples
            freq = 400 - t * 300
            period = sample_rate / freq if freq > 0 else 1
            
            if (i / period) % 1 < 0.5:
                buf.append(int(amplitude * (1 - t)))
            else:
                buf.append(int(-amplitude * (1 - t)))
        
        stereo_buf = array.array('h')
        for sample in buf:
            stereo_buf.append(sample)
            stereo_buf.append(sample)
        
        return pygame.mixer.Sound(buffer=stereo_buf)
    
    def _generate_music(self):
        """Generate background music tracks with harmony and rhythm"""
        
        # Menu music - calm, mysterious with arpeggios
        menu_melody = [
            ('E4', 1), ('G4', 1), ('A4', 2),
            ('E4', 1), ('G4', 1), ('B4', 2),
            ('A4', 1), ('G4', 1), ('E4', 2),
            ('D4', 1), ('E4', 1), ('G4', 2),
            ('E4', 1), ('G4', 1), ('A4', 2),
            ('G4', 1), ('E4', 1), ('D4', 2),
            ('E4', 4),
            ('REST', 2),
        ]
        menu_bass = [
            ('A2', 4), ('E2', 4),
            ('A2', 4), ('D3', 4),
            ('A2', 4), ('E2', 4),
            ('A2', 2), ('REST', 4),
        ]
        self.music['menu'] = generate_chiptune_track(menu_melody, menu_bass, tempo=85, volume=0.18)
        
        # World map music - adventurous with bouncy rhythm
        world_melody = [
            ('C5', 0.5), ('E5', 0.5), ('G5', 1), ('E5', 0.5), ('C5', 0.5),
            ('D5', 0.5), ('F5', 0.5), ('A5', 1), ('F5', 0.5), ('D5', 0.5),
            ('E5', 0.5), ('G5', 0.5), ('B5', 1), ('G5', 0.5), ('E5', 0.5),
            ('C5', 1), ('G4', 1), ('E4', 1), ('C4', 1),
            ('C5', 0.5), ('D5', 0.5), ('E5', 0.5), ('F5', 0.5), ('G5', 1), ('E5', 1),
            ('A4', 0.5), ('B4', 0.5), ('C5', 0.5), ('D5', 0.5), ('E5', 2),
            ('G4', 1), ('A4', 1), ('B4', 1), ('C5', 1),
            ('E5', 2), ('C5', 2),
        ]
        world_bass = [
            ('C3', 2), ('G2', 2),
            ('D3', 2), ('A2', 2),
            ('E3', 2), ('B2', 2),
            ('C3', 2), ('G2', 2),
            ('C3', 2), ('E3', 2),
            ('A2', 2), ('E3', 2),
            ('G2', 2), ('C3', 2),
            ('C3', 4),
        ]
        self.music['world'] = generate_chiptune_track(world_melody, world_bass, tempo=120, volume=0.18)
        
        # Level music - energetic action with driving beat
        level_melody = [
            ('E5', 0.25), ('E5', 0.25), ('REST', 0.25), ('E5', 0.25),
            ('REST', 0.25), ('C5', 0.25), ('E5', 0.5),
            ('G5', 1), ('G4', 1),
            ('C5', 0.5), ('REST', 0.25), ('G4', 0.25), ('REST', 0.5), ('E4', 0.5),
            ('REST', 0.25), ('A4', 0.5), ('B4', 0.25), ('REST', 0.25), ('A4', 0.25), ('G4', 0.5),
            ('E5', 0.5), ('G5', 0.5), ('A5', 0.5), ('F5', 0.25), ('G5', 0.25),
            ('REST', 0.25), ('E5', 0.5), ('C5', 0.25), ('D5', 0.25), ('B4', 0.5),
            ('C5', 1), ('REST', 1),
        ]
        level_bass = [
            ('C3', 1), ('C3', 1),
            ('G2', 1), ('G2', 1),
            ('C3', 0.5), ('C3', 0.5), ('G2', 0.5), ('G2', 0.5),
            ('A2', 1), ('E2', 1),
            ('C3', 0.5), ('G2', 0.5), ('A2', 0.5), ('F2', 0.5),
            ('G2', 1), ('C3', 1),
        ]
        self.music['level'] = generate_chiptune_track(level_melody, level_bass, tempo=150, volume=0.2)
        
        # Boss music - intense and aggressive
        boss_melody = [
            ('E4', 0.25), ('E4', 0.25), ('E5', 0.25), ('E4', 0.25),
            ('E4', 0.25), ('D5', 0.25), ('E4', 0.25), ('E4', 0.25),
            ('E4', 0.25), ('E4', 0.25), ('E5', 0.25), ('G5', 0.25),
            ('F5', 0.25), ('E5', 0.25), ('D5', 0.5),
            ('A4', 0.25), ('A4', 0.25), ('A5', 0.25), ('A4', 0.25),
            ('A4', 0.25), ('G5', 0.25), ('A4', 0.25), ('A4', 0.25),
            ('B4', 0.25), ('B4', 0.25), ('B5', 0.25), ('A5', 0.25),
            ('G5', 0.25), ('F5', 0.25), ('E5', 0.5),
            ('E5', 0.25), ('REST', 0.25), ('E5', 0.25), ('REST', 0.25),
            ('D5', 0.25), ('REST', 0.25), ('C5', 0.25), ('REST', 0.25),
            ('B4', 0.5), ('A4', 0.5),
            ('G4', 0.25), ('A4', 0.25), ('B4', 0.25), ('C5', 0.25),
            ('D5', 0.25), ('E5', 0.25), ('F5', 0.25), ('G5', 0.25),
            ('A5', 1),
            ('E5', 0.5), ('D5', 0.5),
            ('E5', 1),
        ]
        boss_bass = [
            ('E2', 0.5), ('E2', 0.5), ('E2', 0.5), ('E2', 0.5),
            ('E2', 0.5), ('E2', 0.5), ('E2', 0.5), ('E2', 0.5),
            ('A2', 0.5), ('A2', 0.5), ('A2', 0.5), ('A2', 0.5),
            ('B2', 0.5), ('B2', 0.5), ('B2', 0.5), ('B2', 0.5),
            ('E2', 0.5), ('E2', 0.5), ('D2', 0.5), ('D2', 0.5),
            ('C2', 0.5), ('C2', 0.5), ('B2', 0.5), ('B2', 0.5),
            ('A2', 1), ('E2', 1),
            ('E2', 1), ('E2', 1),
        ]
        self.music['boss'] = generate_chiptune_track(boss_melody, boss_bass, tempo=170, volume=0.22)
    
    def play_sound(self, sound_name):
        """Play a sound effect"""
        if self.sound_enabled and sound_name in self.sounds:
            self.sounds[sound_name].play()
    
    def play_music(self, music_name):
        """Play background music (loops)"""
        if not self.music_enabled:
            return
        
        if music_name == self.current_music:
            return
        
        # Stop current music
        pygame.mixer.stop()
        
        if music_name in self.music:
            self.current_music = music_name
            # Loop the music by playing it repeatedly
            self.music[music_name].play(loops=-1)
    
    def stop_music(self):
        """Stop all music"""
        pygame.mixer.stop()
        self.current_music = None
    
    def toggle_music(self):
        """Toggle music on/off"""
        self.music_enabled = not self.music_enabled
        if not self.music_enabled:
            self.stop_music()
        return self.music_enabled
    
    def toggle_sound(self):
        """Toggle sound effects on/off"""
        self.sound_enabled = not self.sound_enabled
        return self.sound_enabled


# Global sound manager instance
_sound_manager = None


def get_sound_manager():
    """Get the global sound manager"""
    global _sound_manager
    if _sound_manager is None:
        _sound_manager = SoundManager()
    return _sound_manager

```

Done! The soundtrack now features full chiptune-style music with:

### Harmony & Layers
- **Melody channel** - 25% duty cycle square wave for that classic NES lead sound
- **Bass channel** - Triangle wave for warm, punchy low end
- **Arpeggio channel** - Fast 16th note arpeggios for texture and sparkle

### Rhythm Section
- **Kick drums** - On beats 1 and 3 (descending pitch burst)
- **Hi-hats** - Noise-based percussion on off-beats for groove

### Track Improvements
- **Menu** - Dreamy arpeggios with a slow, mysterious vibe (85 BPM)
- **World Map** - Bouncy, adventurous melody with a walking bass line (120 BPM)
- **Level** - Driving action music inspired by classic platformers (150 BPM)
- **Boss** - Intense, aggressive track with pounding rhythm (170 BPM)

Each track now has proper musical structure with melody, bass harmony, rhythmic drums, and shimmering arpeggios - true chiptune style!

---

**User**

the level music is too fast paced, also the boss needs a large health bar on the screen that says Cannon on top of it, cannon also needs an animation for when you first encounter him, also a second phase

---

**Cursor**

```python
"""
Sound and music system for Chain
Uses procedurally generated sounds and music
"""

import pygame
import math
import array


def init_sound():
    """Initialize the sound system"""
    pygame.mixer.init(frequency=22050, size=-16, channels=2, buffer=512)


def generate_square_wave(frequency, duration, volume=0.3):
    """Generate a square wave sound"""
    sample_rate = 22050
    n_samples = int(sample_rate * duration)
    
    buf = array.array('h')
    amplitude = int(32767 * volume)
    
    period = sample_rate / frequency
    
    for i in range(n_samples):
        if (i / period) % 1 < 0.5:
            buf.append(amplitude)
        else:
            buf.append(-amplitude)
    
    # Stereo
    stereo_buf = array.array('h')
    for sample in buf:
        stereo_buf.append(sample)
        stereo_buf.append(sample)
    
    sound = pygame.mixer.Sound(buffer=stereo_buf)
    return sound


def generate_noise(duration, volume=0.2):
    """Generate white noise"""
    import random
    sample_rate = 22050
    n_samples = int(sample_rate * duration)
    
    buf = array.array('h')
    amplitude = int(32767 * volume)
    
    for i in range(n_samples):
        buf.append(random.randint(-amplitude, amplitude))
    
    # Stereo
    stereo_buf = array.array('h')
    for sample in buf:
        stereo_buf.append(sample)
        stereo_buf.append(sample)
    
    sound = pygame.mixer.Sound(buffer=stereo_buf)
    return sound


def generate_melody(notes, tempo=120, volume=0.25):
    """Generate a melody from a list of (note, duration) tuples"""
    sample_rate = 22050
    beat_duration = 60 / tempo
    
    all_samples = array.array('h')
    
    # Note frequencies (A4 = 440Hz)
    note_freqs = {
        'C2': 65.41, 'D2': 73.42, 'E2': 82.41, 'F2': 87.31,
        'G2': 98.00, 'A2': 110.00, 'B2': 123.47,
        'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F3': 174.61, 
        'G3': 196.00, 'A3': 220.00, 'B3': 246.94,
        'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
        'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
        'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46,
        'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
        'REST': 0
    }
    
    for note, beats in notes:
        duration = beat_duration * beats
        n_samples = int(sample_rate * duration)
        
        if note == 'REST' or note not in note_freqs:
            # Silence
            for _ in range(n_samples):
                all_samples.append(0)
        else:
            freq = note_freqs[note]
            amplitude = int(32767 * volume)
            period = sample_rate / freq if freq > 0 else 1
            
            for i in range(n_samples):
                # Square wave with envelope
                envelope = 1.0
                if i < n_samples * 0.1:
                    envelope = i / (n_samples * 0.1)
                elif i > n_samples * 0.7:
                    envelope = (n_samples - i) / (n_samples * 0.3)
                
                if (i / period) % 1 < 0.5:
                    all_samples.append(int(amplitude * envelope))
                else:
                    all_samples.append(int(-amplitude * envelope))
    
    # Stereo
    stereo_buf = array.array('h')
    for sample in all_samples:
        stereo_buf.append(sample)
        stereo_buf.append(sample)
    
    sound = pygame.mixer.Sound(buffer=stereo_buf)
    return sound


def generate_chiptune_track(melody, bass, tempo=120, volume=0.2):
    """Generate a full chiptune track with melody, bass, and drums"""
    import random
    sample_rate = 22050
    beat_duration = 60 / tempo
    
    # Note frequencies
    note_freqs = {
        'C2': 65.41, 'D2': 73.42, 'E2': 82.41, 'F2': 87.31,
        'G2': 98.00, 'A2': 110.00, 'B2': 123.47,
        'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F3': 174.61, 
        'G3': 196.00, 'A3': 220.00, 'B3': 246.94,
        'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23,
        'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
        'C5': 523.25, 'D5': 587.33, 'E5': 659.25, 'F5': 698.46,
        'G5': 783.99, 'A5': 880.00, 'B5': 987.77,
        'REST': 0
    }
    
    # Calculate total duration
    total_beats = sum(beats for _, beats in melody)
    total_samples = int(sample_rate * beat_duration * total_beats)
    
    # Generate each channel
    melody_samples = array.array('h', [0] * total_samples)
    bass_samples = array.array('h', [0] * total_samples)
    drum_samples = array.array('h', [0] * total_samples)
    arp_samples = array.array('h', [0] * total_samples)
    
    # Generate melody (square wave, 25% duty cycle for that classic sound)
    sample_pos = 0
    for note, beats in melody:
        duration = beat_duration * beats
        n_samples = int(sample_rate * duration)
        
        if note != 'REST' and note in note_freqs:
            freq = note_freqs[note]
            amplitude = int(32767 * volume * 0.5)
            period = sample_rate / freq if freq > 0 else 1
            
            for i in range(min(n_samples, total_samples - sample_pos)):
                # 25% duty cycle square wave
                envelope = 1.0
                if i < n_samples * 0.05:
                    envelope = i / (n_samples * 0.05)
                elif i > n_samples * 0.8:
                    envelope = (n_samples - i) / (n_samples * 0.2)
                
                duty = 0.25
                if (i / period) % 1 < duty:
                    melody_samples[sample_pos + i] = int(amplitude * envelope)
                else:
                    melody_samples[sample_pos + i] = int(-amplitude * envelope * 0.3)
        
        sample_pos += n_samples
    
    # Generate bass (triangle wave for warmer sound)
    sample_pos = 0
    bass_idx = 0
    beats_elapsed = 0
    
    for note, beats in melody:
        duration = beat_duration * beats
        n_samples = int(sample_rate * duration)
        
        # Get corresponding bass note
        if bass_idx < len(bass):
            bass_note, bass_beats = bass[bass_idx % len(bass)]
            if bass_note != 'REST' and bass_note in note_freqs:
                freq = note_freqs[bass_note]
                amplitude = int(32767 * volume * 0.4)
                period = sample_rate / freq if freq > 0 else 1
                
                for i in range(min(n_samples, total_samples - sample_pos)):
                    # Triangle wave
                    t = (i / period) % 1
                    if t < 0.5:
                        val = t * 4 - 1
                    else:
                        val = 3 - t * 4
                    bass_samples[sample_pos + i] = int(amplitude * val * 0.7)
        
        sample_pos += n_samples
        beats_elapsed += beats
        if beats_elapsed >= (bass[bass_idx % len(bass)][1] if bass_idx < len(bass) else 1):
            bass_idx += 1
            beats_elapsed = 0
    
    # Generate drums (noise kicks and hi-hats)
    beat_samples = int(sample_rate * beat_duration)
    for beat in range(int(total_beats)):
        start = beat * beat_samples
        
        # Kick on beats 1 and 3 (every 2 beats in 4/4)
        if beat % 2 == 0:
            kick_len = min(int(beat_samples * 0.15), total_samples - start)
            for i in range(kick_len):
                # Descending pitch noise burst
                freq = 150 - (i / kick_len) * 100
                period = sample_rate / max(freq, 20)
                envelope = 1 - (i / kick_len)
                amplitude = int(32767 * volume * 0.5 * envelope)
                if (i / period) % 1 < 0.5:
                    drum_samples[start + i] += amplitude
                else:
                    drum_samples[start + i] -= amplitude
        
        # Hi-hat on every beat
        hat_start = start + int(beat_samples * 0.5) if beat % 2 == 1 else start
        if hat_start < total_samples:
            hat_len = min(int(beat_samples * 0.08), total_samples - hat_start)
            for i in range(hat_len):
                envelope = 1 - (i / hat_len)
                amplitude = int(32767 * volume * 0.15 * envelope)
                drum_samples[hat_start + i] += random.randint(-amplitude, amplitude)
    
    # Generate arpeggios (fast note sequences for texture)
    arp_notes = ['C4', 'E4', 'G4', 'C5']  # Major chord arpeggio
    arp_speed = beat_duration / 4  # 16th notes
    arp_samples_per_note = int(sample_rate * arp_speed)
    
    for i in range(0, total_samples, arp_samples_per_note):
        note_idx = (i // arp_samples_per_note) % len(arp_notes)
        note = arp_notes[note_idx]
        freq = note_freqs[note]
        amplitude = int(32767 * volume * 0.15)
        period = sample_rate / freq
        
        for j in range(min(arp_samples_per_note, total_samples - i)):
            envelope = 1 - (j / arp_samples_per_note) * 0.7
            # Pulse wave
            if (j / period) % 1 < 0.125:
                arp_samples[i + j] = int(amplitude * envelope)
    
    # Mix all channels
    mixed = array.array('h')
    for i in range(total_samples):
        # Combine and clip
        total = melody_samples[i] + bass_samples[i] + drum_samples[i] + arp_samples[i]
        total = max(-32767, min(32767, total))
        mixed.append(int(total))
    
    # Stereo with slight panning
    stereo_buf = array.array('h')
    for i, sample in enumerate(mixed):
        # Slight stereo variation
        left = int(sample * 0.9)
        right = int(sample * 1.0)
        stereo_buf.append(left)
        stereo_buf.append(right)
    
    return pygame.mixer.Sound(buffer=stereo_buf)


class SoundManager:
    """Manages all game sounds and music"""
    
    def __init__(self):
        init_sound()
        
        self.sounds = {}
        self.music = {}
        self.current_music = None
        self.music_enabled = True
        self.sound_enabled = True
        
        self._generate_sounds()
        self._generate_music()
    
    def _generate_sounds(self):
        """Generate all sound effects"""
        # Attack sound
        self.sounds['attack'] = generate_square_wave(200, 0.1, 0.2)
        
        # Jump sound
        self.sounds['jump'] = self._make_jump_sound()
        
        # Hit sound
        self.sounds['hit'] = generate_noise(0.15, 0.3)
        
        # Pickup sound
        self.sounds['pickup'] = self._make_pickup_sound()
        
        # Spell sounds
        self.sounds['spell'] = generate_square_wave(440, 0.2, 0.2)
        
        # Enemy death
        self.sounds['enemy_death'] = self._make_death_sound()
        
        # Menu select
        self.sounds['menu'] = generate_square_wave(330, 0.1, 0.15)
    
    def _make_jump_sound(self):
        """Create a jump sound effect (rising pitch)"""
        sample_rate = 22050
        duration = 0.15
        n_samples = int(sample_rate * duration)
        
        buf = array.array('h')
        volume = 0.2
        amplitude = int(32767 * volume)
        
        for i in range(n_samples):
            # Rising frequency
            t = i / n_samples
            freq = 150 + t * 400
            period = sample_rate / freq
            
            if (i / period) % 1 < 0.5:
                buf.append(int(amplitude * (1 - t * 0.5)))
            else:
                buf.append(int(-amplitude * (1 - t * 0.5)))
        
        stereo_buf = array.array('h')
        for sample in buf:
            stereo_buf.append(sample)
            stereo_buf.append(sample)
        
        return pygame.mixer.Sound(buffer=stereo_buf)
    
    def _make_pickup_sound(self):
        """Create a pickup sound effect (arpeggio)"""
        sample_rate = 22050
        
        buf = array.array('h')
        volume = 0.2
        amplitude = int(32767 * volume)
        
        freqs = [330, 440, 550, 660]  # Rising arpeggio
        
        for freq in freqs:
            duration = 0.05
            n_samples = int(sample_rate * duration)
            period = sample_rate / freq
            
            for i in range(n_samples):
                envelope = 1 - (i / n_samples) * 0.5
                if (i / period) % 1 < 0.5:
                    buf.append(int(amplitude * envelope))
                else:
                    buf.append(int(-amplitude * envelope))
        
        stereo_buf = array.array('h')
        for sample in buf:
            stereo_buf.append(sample)
            stereo_buf.append(sample)
        
        return pygame.mixer.Sound(buffer=stereo_buf)
    
    def _make_death_sound(self):
        """Create enemy death sound (descending)"""
        sample_rate = 22050
        duration = 0.2
        n_samples = int(sample_rate * duration)
        
        buf = array.array('h')
        volume = 0.25
        amplitude = int(32767 * volume)
        
        for i in range(n_samples):
            t = i / n_samples
            freq = 400 - t * 300
            period = sample_rate / freq if freq > 0 else 1
            
            if (i / period) % 1 < 0.5:
                buf.append(int(amplitude * (1 - t)))
            else:
                buf.append(int(-amplitude * (1 - t)))
        
        stereo_buf = array.array('h')
        for sample in buf:
            stereo_buf.append(sample)
            stereo_buf.append(sample)
        
        return pygame.mixer.Sound(buffer=stereo_buf)
    
    def _generate_music(self):
        """Generate background music tracks with harmony and rhythm"""
        
        # Menu music - calm, mysterious with arpeggios
        menu_melody = [
            ('E4', 1), ('G4', 1), ('A4', 2),
            ('E4', 1), ('G4', 1), ('B4', 2),
            ('A4', 1), ('G4', 1), ('E4', 2),
            ('D4', 1), ('E4', 1), ('G4', 2),
            ('E4', 1), ('G4', 1), ('A4', 2),
            ('G4', 1), ('E4', 1), ('D4', 2),
            ('E4', 4),
            ('REST', 2),
        ]
        menu_bass = [
            ('A2', 4), ('E2', 4),
            ('A2', 4), ('D3', 4),
            ('A2', 4), ('E2', 4),
            ('A2', 2), ('REST', 4),
        ]
        self.music['menu'] = generate_chiptune_track(menu_melody, menu_bass, tempo=85, volume=0.18)
        
        # World map music - adventurous with bouncy rhythm
        world_melody = [
            ('C5', 0.5), ('E5', 0.5), ('G5', 1), ('E5', 0.5), ('C5', 0.5),
            ('D5', 0.5), ('F5', 0.5), ('A5', 1), ('F5', 0.5), ('D5', 0.5),
            ('E5', 0.5), ('G5', 0.5), ('B5', 1), ('G5', 0.5), ('E5', 0.5),
            ('C5', 1), ('G4', 1), ('E4', 1), ('C4', 1),
            ('C5', 0.5), ('D5', 0.5), ('E5', 0.5), ('F5', 0.5), ('G5', 1), ('E5', 1),
            ('A4', 0.5), ('B4', 0.5), ('C5', 0.5), ('D5', 0.5), ('E5', 2),
            ('G4', 1), ('A4', 1), ('B4', 1), ('C5', 1),
            ('E5', 2), ('C5', 2),
        ]
        world_bass = [
            ('C3', 2), ('G2', 2),
            ('D3', 2), ('A2', 2),
            ('E3', 2), ('B2', 2),
            ('C3', 2), ('G2', 2),
            ('C3', 2), ('E3', 2),
            ('A2', 2), ('E3', 2),
            ('G2', 2), ('C3', 2),
            ('C3', 4),
        ]
        self.music['world'] = generate_chiptune_track(world_melody, world_bass, tempo=120, volume=0.18)
        
        # Level music - energetic action with driving beat
        level_melody = [
            ('E5', 0.25), ('E5', 0.25), ('REST', 0.25), ('E5', 0.25),
            ('REST', 0.25), ('C5', 0.25), ('E5', 0.5),
            ('G5', 1), ('G4', 1),
            ('C5', 0.5), ('REST', 0.25), ('G4', 0.25), ('REST', 0.5), ('E4', 0.5),
            ('REST', 0.25), ('A4', 0.5), ('B4', 0.25), ('REST', 0.25), ('A4', 0.25), ('G4', 0.5),
            ('E5', 0.5), ('G5', 0.5), ('A5', 0.5), ('F5', 0.25), ('G5', 0.25),
            ('REST', 0.25), ('E5', 0.5), ('C5', 0.25), ('D5', 0.25), ('B4', 0.5),
            ('C5', 1), ('REST', 1),
        ]
        level_bass = [
            ('C3', 1), ('C3', 1),
            ('G2', 1), ('G2', 1),
            ('C3', 0.5), ('C3', 0.5), ('G2', 0.5), ('G2', 0.5),
            ('A2', 1), ('E2', 1),
            ('C3', 0.5), ('G2', 0.5), ('A2', 0.5), ('F2', 0.5),
            ('G2', 1), ('C3', 1),
        ]
        self.music['level'] = generate_chiptune_track(level_melody, level_bass, tempo=115, volume=0.2)
        
        # Boss music - intense and aggressive
        boss_melody = [
            ('E4', 0.25), ('E4', 0.25), ('E5', 0.25), ('E4', 0.25),
            ('E4', 0.25), ('D5', 0.25), ('E4', 0.25), ('E4', 0.25),
            ('E4', 0.25), ('E4', 0.25), ('E5', 0.25), ('G5', 0.25),
            ('F5', 0.25), ('E5', 0.25), ('D5', 0.5),
            ('A4', 0.25), ('A4', 0.25), ('A5', 0.25), ('A4', 0.25),
            ('A4', 0.25), ('G5', 0.25), ('A4', 0.25), ('A4', 0.25),
            ('B4', 0.25), ('B4', 0.25), ('B5', 0.25), ('A5', 0.25),
            ('G5', 0.25), ('F5', 0.25), ('E5', 0.5),
            ('E5', 0.25), ('REST', 0.25), ('E5', 0.25), ('REST', 0.25),
            ('D5', 0.25), ('REST', 0.25), ('C5', 0.25), ('REST', 0.25),
            ('B4', 0.5), ('A4', 0.5),
            ('G4', 0.25), ('A4', 0.25), ('B4', 0.25), ('C5', 0.25),
            ('D5', 0.25), ('E5', 0.25), ('F5', 0.25), ('G5', 0.25),
            ('A5', 1),
            ('E5', 0.5), ('D5', 0.5),
            ('E5', 1),
        ]
        boss_bass = [
            ('E2', 0.5), ('E2', 0.5), ('E2', 0.5), ('E2', 0.5),
            ('E2', 0.5), ('E2', 0.5), ('E2', 0.5), ('E2', 0.5),
            ('A2', 0.5), ('A2', 0.5), ('A2', 0.5), ('A2', 0.5),
            ('B2', 0.5), ('B2', 0.5), ('B2', 0.5), ('B2', 0.5),
            ('E2', 0.5), ('E2', 0.5), ('D2', 0.5), ('D2', 0.5),
            ('C2', 0.5), ('C2', 0.5), ('B2', 0.5), ('B2', 0.5),
            ('A2', 1), ('E2', 1),
            ('E2', 1), ('E2', 1),
        ]
        self.music['boss'] = generate_chiptune_track(boss_melody, boss_bass, tempo=170, volume=0.22)
    
    def play_sound(self, sound_name):
        """Play a sound effect"""
        if self.sound_enabled and sound_name in self.sounds:
            self.sounds[sound_name].play()
    
    def play_music(self, music_name):
        """Play background music (loops)"""
        if not self.music_enabled:
            return
        
        if music_name == self.current_music:
            return
        
        # Stop current music
        pygame.mixer.stop()
        
        if music_name in self.music:
            self.current_music = music_name
            # Loop the music by playing it repeatedly
            self.music[music_name].play(loops=-1)
    
    def stop_music(self):
        """Stop all music"""
        pygame.mixer.stop()
        self.current_music = None
    
    def toggle_music(self):
        """Toggle music on/off"""
        self.music_enabled = not self.music_enabled
        if not self.music_enabled:
            self.stop_music()
        return self.music_enabled
    
    def toggle_sound(self):
        """Toggle sound effects on/off"""
        self.sound_enabled = not self.sound_enabled
        return self.sound_enabled


# Global sound manager instance
_sound_manager = None


def get_sound_manager():
    """Get the global sound manager"""
    global _sound_manager
    if _sound_manager is None:
        _sound_manager = SoundManager()
    return _sound_manager

```

```python
"""
Enemy classes for Chain
"""

import pygame
import math
import random
from settings import *
from sprites import create_slime_sprite, create_bat_sprite, create_knight_sprite, create_cannon_sprite


class Enemy(pygame.sprite.Sprite):
    """Base enemy class"""
    
    def __init__(self, x, y, enemy_type):
        super().__init__()
        self.enemy_type = enemy_type
        self.stats = ENEMY_TYPES[enemy_type]
        
        self.max_health = self.stats['health']
        self.health = self.max_health
        self.damage = self.stats['damage']
        self.speed = self.stats['speed']
        self.score = self.stats['score']
        
        self.frame = 0
        self.facing_right = True
        
        # AI state
        self.state = 'patrol'
        self.patrol_distance = 100
        self.start_x = x
        self.direction = 1
        
        # Physics
        self.velocity_x = 0
        self.velocity_y = 0
        
        # Combat
        self.hurt_timer = 0
        self.attack_cooldown = 0
        
        # Create initial sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
    
    def update_sprite(self):
        """Override in subclasses"""
        pass
    
    def update(self, player=None, tiles=None):
        """Update enemy state"""
        self.frame += 1
        
        if self.hurt_timer > 0:
            self.hurt_timer -= 1
        
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        self.ai_update(player)
        self.physics_update(tiles)
        self.update_sprite()
    
    def ai_update(self, player):
        """AI behavior - override in subclasses"""
        pass
    
    def physics_update(self, tiles):
        """Apply physics"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:
            self.velocity_y = 15
        
        # Move
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def take_damage(self, amount):
        """Take damage"""
        self.health -= amount
        self.hurt_timer = 10
        
        if self.health <= 0:
            self.kill()
            return True  # Enemy died
        return False
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw enemy"""
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.hurt_timer > 0 and self.frame % 4 < 2:
            return
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw health bar for tough enemies
        if self.max_health > 2:
            self.draw_health_bar(surface, camera_offset)
    
    def draw_health_bar(self, surface, camera_offset):
        """Draw health bar above enemy"""
        bar_width = 30
        bar_height = 4
        
        x = self.rect.centerx - camera_offset[0] - bar_width // 2
        y = self.rect.top - camera_offset[1] - 8
        
        # Background
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health
        health_width = int(bar_width * (self.health / self.max_health))
        pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))


class Slime(Enemy):
    """Slime enemy - easy, hops around"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'slime')
        self.hop_timer = 0
    
    def update_sprite(self):
        self.image = create_slime_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Hop periodically
        self.hop_timer += 1
        if self.hop_timer >= 60:
            self.hop_timer = 0
            self.velocity_y = -6
            
            # Move toward player if nearby, otherwise patrol
            if player and abs(player.rect.centerx - self.rect.centerx) < 200:
                if player.rect.centerx < self.rect.centerx:
                    self.velocity_x = -self.speed * 2
                else:
                    self.velocity_x = self.speed * 2
            else:
                # Patrol
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                self.velocity_x = self.speed * self.direction


class Bat(Enemy):
    """Bat enemy - flying, erratic movement"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'bat')
        self.start_y = y
        self.angle = 0
        self.swoop_target = None
    
    def update_sprite(self):
        self.image = create_bat_sprite(self.frame)
    
    def ai_update(self, player):
        # Erratic flying pattern
        self.angle += 0.05
        
        if player and abs(player.rect.centerx - self.rect.centerx) < 150:
            # Swoop toward player
            dx = player.rect.centerx - self.rect.centerx
            dy = player.rect.centery - self.rect.centery
            dist = math.sqrt(dx * dx + dy * dy)
            
            if dist > 0:
                self.velocity_x = (dx / dist) * self.speed * 1.5
                self.velocity_y = (dy / dist) * self.speed * 1.5
        else:
            # Patrol pattern
            self.velocity_x = math.sin(self.angle) * self.speed
            self.velocity_y = math.cos(self.angle * 2) * self.speed * 0.5
        
        self.facing_right = self.velocity_x > 0
    
    def physics_update(self, tiles):
        # Bats don't use gravity
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Keep within bounds
        if self.rect.y < self.start_y - 100:
            self.rect.y = self.start_y - 100
        if self.rect.y > self.start_y + 100:
            self.rect.y = self.start_y + 100


class Knight(Enemy):
    """Knight enemy - tough, shielded, aggressive"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'knight')
        self.shield_active = True
        self.charge_timer = 0
        self.charging = False
    
    def update_sprite(self):
        self.image = create_knight_sprite(self.facing_right, self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        if player:
            dx = player.rect.centerx - self.rect.centerx
            
            # Face player
            self.facing_right = dx > 0
            
            if abs(dx) < 250:
                # Aggressive pursuit
                self.charge_timer += 1
                
                if self.charge_timer >= 90:
                    # Charge attack
                    self.charging = True
                    self.charge_timer = 0
                
                if self.charging:
                    self.velocity_x = self.speed * 3 * (1 if self.facing_right else -1)
                    if abs(dx) < 30 or abs(dx) > 200:
                        self.charging = False
                else:
                    # Walk toward player
                    if abs(dx) > 40:
                        self.velocity_x = self.speed * (1 if dx > 0 else -1)
            else:
                # Patrol
                self.charge_timer = 0
                self.charging = False
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                    self.facing_right = False
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                    self.facing_right = True
                self.velocity_x = self.speed * self.direction
    
    def take_damage(self, amount):
        """Knights take reduced damage from front when shield is up"""
        if self.shield_active:
            # Shield blocks some damage
            amount = max(1, amount - 1)
        return super().take_damage(amount)


class Cannon(Enemy):
    """Boss enemy - the archenemy"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'cannon')
        self.phase = 1
        self.attack_pattern = 0
        self.pattern_timer = 0
        self.projectiles = pygame.sprite.Group()
        self.arena_bounds = (x - 200, x + 200)
        
        # Intro animation
        self.intro_active = True
        self.intro_timer = 0
        self.intro_duration = 180  # 3 seconds at 60fps
        self.intro_y_offset = -200  # Start above screen
        self.original_y = y
        
        # Phase transition
        self.phase_transition = False
        self.phase_transition_timer = 0
        self.last_phase = 1
    
    def update_sprite(self):
        # Flash during phase transition
        if self.phase_transition and self.frame % 4 < 2:
            self.image = pygame.Surface((48, 48), pygame.SRCALPHA)
            self.image.fill((*YELLOW[:3], 200))
        else:
            self.image = create_cannon_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Handle intro animation
        if self.intro_active:
            self.intro_timer += 1
            # Descend from above
            progress = min(1.0, self.intro_timer / (self.intro_duration * 0.6))
            # Ease out
            ease = 1 - (1 - progress) ** 3
            self.intro_y_offset = -200 * (1 - ease)
            self.rect.y = self.original_y + self.intro_y_offset
            
            if self.intro_timer >= self.intro_duration:
                self.intro_active = False
                self.intro_y_offset = 0
                self.rect.y = self.original_y
            return
        
        if not player:
            return
        
        # Handle phase transition animation
        if self.phase_transition:
            self.phase_transition_timer += 1
            if self.phase_transition_timer >= 60:
                self.phase_transition = False
                self.phase_transition_timer = 0
            return
        
        # Update phase based on health
        old_phase = self.phase
        if self.health <= self.max_health * 0.3:
            self.phase = 3
        elif self.health <= self.max_health * 0.5:
            self.phase = 2
        
        # Trigger phase transition animation
        if self.phase != old_phase:
            self.phase_transition = True
            self.phase_transition_timer = 0
            self.last_phase = self.phase
        
        dx = player.rect.centerx - self.rect.centerx
        self.facing_right = dx > 0
        
        self.pattern_timer += 1
        
        if self.phase == 1:
            self.phase1_ai(player)
        elif self.phase == 2:
            self.phase2_ai(player)
        else:
            self.phase3_ai(player)
    
    def phase1_ai(self, player):
        """Phase 1: Patrol and shoot"""
        # Move back and forth
        if self.rect.x > self.arena_bounds[1]:
            self.direction = -1
        elif self.rect.x < self.arena_bounds[0]:
            self.direction = 1
        
        self.velocity_x = self.speed * self.direction
        
        # Shoot periodically
        if self.pattern_timer >= 90:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase2_ai(self, player):
        """Phase 2: Chase and rapid fire"""
        dx = player.rect.centerx - self.rect.centerx
        
        if abs(dx) > 100:
            self.velocity_x = self.speed * 1.5 * (1 if dx > 0 else -1)
        
        # Rapid fire
        if self.pattern_timer >= 45:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase3_ai(self, player):
        """Phase 3: Enraged - fast and aggressive"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive pursuit
        self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Very rapid fire
        if self.pattern_timer >= 30:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def shoot_cannon_ball(self, player):
        """Fire a cannon ball at the player"""
        ball = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery
        )
        self.projectiles.add(ball)
    
    def update(self, player=None, tiles=None):
        super().update(player, tiles)
        self.projectiles.update()
    
    def draw(self, surface, camera_offset=(0, 0)):
        super().draw(surface, camera_offset)
        
        # Draw projectiles
        for ball in self.projectiles:
            ball.draw(surface, camera_offset)
        
        # Draw boss health bar at top of screen
        self.draw_boss_health_bar(surface)
    
    def draw_boss_health_bar(self, surface):
        """Draw large boss health bar at top"""
        bar_width = 400
        bar_height = 28
        x = SCREEN_WIDTH // 2 - bar_width // 2
        y = 50
        
        # Boss name label
        pygame.font.init()
        font = pygame.font.Font(None, 36)
        name_text = font.render("~ CANNON ~", True, YELLOW)
        name_rect = name_text.get_rect(center=(SCREEN_WIDTH // 2, 25))
        
        # Name background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), 
                        (name_rect.x - 15, name_rect.y - 5, name_rect.width + 30, name_rect.height + 10))
        pygame.draw.rect(surface, RED, 
                        (name_rect.x - 15, name_rect.y - 5, name_rect.width + 30, name_rect.height + 10), 2)
        surface.blit(name_text, name_rect)
        
        # Health bar background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 220), (x - 6, y - 6, bar_width + 12, bar_height + 12))
        pygame.draw.rect(surface, DARK_BROWN, (x - 2, y - 2, bar_width + 4, bar_height + 4))
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health (gradient effect)
        health_width = int(bar_width * (self.health / self.max_health))
        if health_width > 0:
            # Main health bar
            pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))
            # Highlight
            pygame.draw.rect(surface, ORANGE, (x, y, health_width, bar_height // 3))
        
        # Border
        pygame.draw.rect(surface, YELLOW, (x - 4, y - 4, bar_width + 8, bar_height + 8), 3)
        
        # Phase indicator
        if self.phase >= 2:
            phase_text = font.render(f"PHASE {self.phase}", True, MAGENTA if self.phase == 3 else ORANGE)
            phase_rect = phase_text.get_rect(center=(SCREEN_WIDTH // 2, y + bar_height + 20))
            surface.blit(phase_text, phase_rect)


class CannonBall(pygame.sprite.Sprite):
    """Projectile fired by Cannon boss"""
    
    def __init__(self, x, y, target_x, target_y):
        super().__init__()
        
        # Calculate direction
        dx = target_x - x
        dy = target_y - y
        dist = math.sqrt(dx * dx + dy * dy)
        
        self.speed = 5
        if dist > 0:
            self.velocity_x = (dx / dist) * self.speed
            self.velocity_y = (dy / dist) * self.speed
        else:
            self.velocity_x = self.speed
            self.velocity_y = 0
        
        self.damage = 2
        self.lifetime = 180
        
        # Create sprite
        self.image = pygame.Surface((16, 16), pygame.SRCALPHA)
        pygame.draw.circle(self.image, GRAY, (8, 8), 7)
        pygame.draw.circle(self.image, DARK_BROWN, (8, 8), 5)
        pygame.draw.circle(self.image, ORANGE, (6, 6), 2)
        
        self.rect = self.image.get_rect(center=(x, y))
    
    def update(self):
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


def create_enemy(enemy_type, x, y):
    """Factory function to create enemies"""
    if enemy_type == 'slime':
        return Slime(x, y)
    elif enemy_type == 'bat':
        return Bat(x, y)
    elif enemy_type == 'knight':
        return Knight(x, y)
    elif enemy_type == 'cannon':
        return Cannon(x, y)
    else:
        return Slime(x, y)  # Default

```

```python
"""
Enemy classes for Chain
"""

import pygame
import math
import random
from settings import *
from sprites import create_slime_sprite, create_bat_sprite, create_knight_sprite, create_cannon_sprite


class Enemy(pygame.sprite.Sprite):
    """Base enemy class"""
    
    def __init__(self, x, y, enemy_type):
        super().__init__()
        self.enemy_type = enemy_type
        self.stats = ENEMY_TYPES[enemy_type]
        
        self.max_health = self.stats['health']
        self.health = self.max_health
        self.damage = self.stats['damage']
        self.speed = self.stats['speed']
        self.score = self.stats['score']
        
        self.frame = 0
        self.facing_right = True
        
        # AI state
        self.state = 'patrol'
        self.patrol_distance = 100
        self.start_x = x
        self.direction = 1
        
        # Physics
        self.velocity_x = 0
        self.velocity_y = 0
        
        # Combat
        self.hurt_timer = 0
        self.attack_cooldown = 0
        
        # Create initial sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
    
    def update_sprite(self):
        """Override in subclasses"""
        pass
    
    def update(self, player=None, tiles=None):
        """Update enemy state"""
        self.frame += 1
        
        if self.hurt_timer > 0:
            self.hurt_timer -= 1
        
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        self.ai_update(player)
        self.physics_update(tiles)
        self.update_sprite()
    
    def ai_update(self, player):
        """AI behavior - override in subclasses"""
        pass
    
    def physics_update(self, tiles):
        """Apply physics"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:
            self.velocity_y = 15
        
        # Move
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def take_damage(self, amount):
        """Take damage"""
        self.health -= amount
        self.hurt_timer = 10
        
        if self.health <= 0:
            self.kill()
            return True  # Enemy died
        return False
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw enemy"""
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.hurt_timer > 0 and self.frame % 4 < 2:
            return
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw health bar for tough enemies
        if self.max_health > 2:
            self.draw_health_bar(surface, camera_offset)
    
    def draw_health_bar(self, surface, camera_offset):
        """Draw health bar above enemy"""
        bar_width = 30
        bar_height = 4
        
        x = self.rect.centerx - camera_offset[0] - bar_width // 2
        y = self.rect.top - camera_offset[1] - 8
        
        # Background
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health
        health_width = int(bar_width * (self.health / self.max_health))
        pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))


class Slime(Enemy):
    """Slime enemy - easy, hops around"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'slime')
        self.hop_timer = 0
    
    def update_sprite(self):
        self.image = create_slime_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Hop periodically
        self.hop_timer += 1
        if self.hop_timer >= 60:
            self.hop_timer = 0
            self.velocity_y = -6
            
            # Move toward player if nearby, otherwise patrol
            if player and abs(player.rect.centerx - self.rect.centerx) < 200:
                if player.rect.centerx < self.rect.centerx:
                    self.velocity_x = -self.speed * 2
                else:
                    self.velocity_x = self.speed * 2
            else:
                # Patrol
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                self.velocity_x = self.speed * self.direction


class Bat(Enemy):
    """Bat enemy - flying, erratic movement"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'bat')
        self.start_y = y
        self.angle = 0
        self.swoop_target = None
    
    def update_sprite(self):
        self.image = create_bat_sprite(self.frame)
    
    def ai_update(self, player):
        # Erratic flying pattern
        self.angle += 0.05
        
        if player and abs(player.rect.centerx - self.rect.centerx) < 150:
            # Swoop toward player
            dx = player.rect.centerx - self.rect.centerx
            dy = player.rect.centery - self.rect.centery
            dist = math.sqrt(dx * dx + dy * dy)
            
            if dist > 0:
                self.velocity_x = (dx / dist) * self.speed * 1.5
                self.velocity_y = (dy / dist) * self.speed * 1.5
        else:
            # Patrol pattern
            self.velocity_x = math.sin(self.angle) * self.speed
            self.velocity_y = math.cos(self.angle * 2) * self.speed * 0.5
        
        self.facing_right = self.velocity_x > 0
    
    def physics_update(self, tiles):
        # Bats don't use gravity
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Keep within bounds
        if self.rect.y < self.start_y - 100:
            self.rect.y = self.start_y - 100
        if self.rect.y > self.start_y + 100:
            self.rect.y = self.start_y + 100


class Knight(Enemy):
    """Knight enemy - tough, shielded, aggressive"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'knight')
        self.shield_active = True
        self.charge_timer = 0
        self.charging = False
    
    def update_sprite(self):
        self.image = create_knight_sprite(self.facing_right, self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        if player:
            dx = player.rect.centerx - self.rect.centerx
            
            # Face player
            self.facing_right = dx > 0
            
            if abs(dx) < 250:
                # Aggressive pursuit
                self.charge_timer += 1
                
                if self.charge_timer >= 90:
                    # Charge attack
                    self.charging = True
                    self.charge_timer = 0
                
                if self.charging:
                    self.velocity_x = self.speed * 3 * (1 if self.facing_right else -1)
                    if abs(dx) < 30 or abs(dx) > 200:
                        self.charging = False
                else:
                    # Walk toward player
                    if abs(dx) > 40:
                        self.velocity_x = self.speed * (1 if dx > 0 else -1)
            else:
                # Patrol
                self.charge_timer = 0
                self.charging = False
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                    self.facing_right = False
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                    self.facing_right = True
                self.velocity_x = self.speed * self.direction
    
    def take_damage(self, amount):
        """Knights take reduced damage from front when shield is up"""
        if self.shield_active:
            # Shield blocks some damage
            amount = max(1, amount - 1)
        return super().take_damage(amount)


class Cannon(Enemy):
    """Boss enemy - the archenemy"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'cannon')
        self.phase = 1
        self.attack_pattern = 0
        self.pattern_timer = 0
        self.projectiles = pygame.sprite.Group()
        self.arena_bounds = (x - 200, x + 200)
        
        # Intro animation
        self.intro_active = True
        self.intro_timer = 0
        self.intro_duration = 180  # 3 seconds at 60fps
        self.intro_y_offset = -200  # Start above screen
        self.original_y = y
        
        # Phase transition
        self.phase_transition = False
        self.phase_transition_timer = 0
        self.last_phase = 1
    
    def update_sprite(self):
        # Flash during phase transition
        if self.phase_transition and self.frame % 4 < 2:
            self.image = pygame.Surface((48, 48), pygame.SRCALPHA)
            self.image.fill((*YELLOW[:3], 200))
        else:
            self.image = create_cannon_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Handle intro animation
        if self.intro_active:
            self.intro_timer += 1
            # Descend from above
            progress = min(1.0, self.intro_timer / (self.intro_duration * 0.6))
            # Ease out
            ease = 1 - (1 - progress) ** 3
            self.intro_y_offset = -200 * (1 - ease)
            self.rect.y = self.original_y + self.intro_y_offset
            
            if self.intro_timer >= self.intro_duration:
                self.intro_active = False
                self.intro_y_offset = 0
                self.rect.y = self.original_y
            return
        
        if not player:
            return
        
        # Handle phase transition animation
        if self.phase_transition:
            self.phase_transition_timer += 1
            if self.phase_transition_timer >= 60:
                self.phase_transition = False
                self.phase_transition_timer = 0
            return
        
        # Update phase based on health
        old_phase = self.phase
        if self.health <= self.max_health * 0.3:
            self.phase = 3
        elif self.health <= self.max_health * 0.5:
            self.phase = 2
        
        # Trigger phase transition animation
        if self.phase != old_phase:
            self.phase_transition = True
            self.phase_transition_timer = 0
            self.last_phase = self.phase
        
        dx = player.rect.centerx - self.rect.centerx
        self.facing_right = dx > 0
        
        self.pattern_timer += 1
        
        if self.phase == 1:
            self.phase1_ai(player)
        elif self.phase == 2:
            self.phase2_ai(player)
        else:
            self.phase3_ai(player)
    
    def phase1_ai(self, player):
        """Phase 1: Patrol and shoot"""
        # Move back and forth
        if self.rect.x > self.arena_bounds[1]:
            self.direction = -1
        elif self.rect.x < self.arena_bounds[0]:
            self.direction = 1
        
        self.velocity_x = self.speed * self.direction
        
        # Shoot periodically
        if self.pattern_timer >= 90:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase2_ai(self, player):
        """Phase 2: Jump attacks and spread shot"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive chase
        if abs(dx) > 80:
            self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Jump attack periodically
        if self.pattern_timer % 120 == 0 and self.pattern_timer > 0:
            self.velocity_y = -10  # Jump!
        
        # Spread shot - fires 3 cannon balls
        if self.pattern_timer >= 60:
            self.shoot_cannon_ball(player)
            # Shoot additional balls at angles
            self.shoot_spread_shot(player)
            self.pattern_timer = 0
    
    def shoot_spread_shot(self, player):
        """Fire spread of cannon balls"""
        # Upper shot
        ball1 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery - 100
        )
        # Lower shot
        ball2 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery + 100
        )
        self.projectiles.add(ball1)
        self.projectiles.add(ball2)
    
    def phase3_ai(self, player):
        """Phase 3: Enraged - fast and aggressive"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive pursuit
        self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Very rapid fire
        if self.pattern_timer >= 30:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def shoot_cannon_ball(self, player):
        """Fire a cannon ball at the player"""
        ball = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery
        )
        self.projectiles.add(ball)
    
    def update(self, player=None, tiles=None):
        super().update(player, tiles)
        self.projectiles.update()
    
    def draw(self, surface, camera_offset=(0, 0)):
        super().draw(surface, camera_offset)
        
        # Draw projectiles
        for ball in self.projectiles:
            ball.draw(surface, camera_offset)
        
        # Draw boss health bar at top of screen
        self.draw_boss_health_bar(surface)
    
    def draw_boss_health_bar(self, surface):
        """Draw large boss health bar at top"""
        bar_width = 400
        bar_height = 28
        x = SCREEN_WIDTH // 2 - bar_width // 2
        y = 50
        
        # Boss name label
        pygame.font.init()
        font = pygame.font.Font(None, 36)
        name_text = font.render("~ CANNON ~", True, YELLOW)
        name_rect = name_text.get_rect(center=(SCREEN_WIDTH // 2, 25))
        
        # Name background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 200), 
                        (name_rect.x - 15, name_rect.y - 5, name_rect.width + 30, name_rect.height + 10))
        pygame.draw.rect(surface, RED, 
                        (name_rect.x - 15, name_rect.y - 5, name_rect.width + 30, name_rect.height + 10), 2)
        surface.blit(name_text, name_rect)
        
        # Health bar background
        pygame.draw.rect(surface, (*DARK_BLUE[:3], 220), (x - 6, y - 6, bar_width + 12, bar_height + 12))
        pygame.draw.rect(surface, DARK_BROWN, (x - 2, y - 2, bar_width + 4, bar_height + 4))
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health (gradient effect)
        health_width = int(bar_width * (self.health / self.max_health))
        if health_width > 0:
            # Main health bar
            pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))
            # Highlight
            pygame.draw.rect(surface, ORANGE, (x, y, health_width, bar_height // 3))
        
        # Border
        pygame.draw.rect(surface, YELLOW, (x - 4, y - 4, bar_width + 8, bar_height + 8), 3)
        
        # Phase indicator
        if self.phase >= 2:
            phase_text = font.render(f"PHASE {self.phase}", True, MAGENTA if self.phase == 3 else ORANGE)
            phase_rect = phase_text.get_rect(center=(SCREEN_WIDTH // 2, y + bar_height + 20))
            surface.blit(phase_text, phase_rect)


class CannonBall(pygame.sprite.Sprite):
    """Projectile fired by Cannon boss"""
    
    def __init__(self, x, y, target_x, target_y):
        super().__init__()
        
        # Calculate direction
        dx = target_x - x
        dy = target_y - y
        dist = math.sqrt(dx * dx + dy * dy)
        
        self.speed = 5
        if dist > 0:
            self.velocity_x = (dx / dist) * self.speed
            self.velocity_y = (dy / dist) * self.speed
        else:
            self.velocity_x = self.speed
            self.velocity_y = 0
        
        self.damage = 2
        self.lifetime = 180
        
        # Create sprite
        self.image = pygame.Surface((16, 16), pygame.SRCALPHA)
        pygame.draw.circle(self.image, GRAY, (8, 8), 7)
        pygame.draw.circle(self.image, DARK_BROWN, (8, 8), 5)
        pygame.draw.circle(self.image, ORANGE, (6, 6), 2)
        
        self.rect = self.image.get_rect(center=(x, y))
    
    def update(self):
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


def create_enemy(enemy_type, x, y):
    """Factory function to create enemies"""
    if enemy_type == 'slime':
        return Slime(x, y)
    elif enemy_type == 'bat':
        return Bat(x, y)
    elif enemy_type == 'knight':
        return Knight(x, y)
    elif enemy_type == 'cannon':
        return Cannon(x, y)
    else:
        return Slime(x, y)  # Default

```

```python
"""
Enemy classes for Chain
"""

import pygame
import math
import random
from settings import *
from sprites import create_slime_sprite, create_bat_sprite, create_knight_sprite, create_cannon_sprite


class Enemy(pygame.sprite.Sprite):
    """Base enemy class"""
    
    def __init__(self, x, y, enemy_type):
        super().__init__()
        self.enemy_type = enemy_type
        self.stats = ENEMY_TYPES[enemy_type]
        
        self.max_health = self.stats['health']
        self.health = self.max_health
        self.damage = self.stats['damage']
        self.speed = self.stats['speed']
        self.score = self.stats['score']
        
        self.frame = 0
        self.facing_right = True
        
        # AI state
        self.state = 'patrol'
        self.patrol_distance = 100
        self.start_x = x
        self.direction = 1
        
        # Physics
        self.velocity_x = 0
        self.velocity_y = 0
        
        # Combat
        self.hurt_timer = 0
        self.attack_cooldown = 0
        
        # Create initial sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
    
    def update_sprite(self):
        """Override in subclasses"""
        pass
    
    def update(self, player=None, tiles=None):
        """Update enemy state"""
        self.frame += 1
        
        if self.hurt_timer > 0:
            self.hurt_timer -= 1
        
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        self.ai_update(player)
        self.physics_update(tiles)
        self.update_sprite()
    
    def ai_update(self, player):
        """AI behavior - override in subclasses"""
        pass
    
    def physics_update(self, tiles):
        """Apply physics"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:
            self.velocity_y = 15
        
        # Move
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def take_damage(self, amount):
        """Take damage"""
        self.health -= amount
        self.hurt_timer = 10
        
        if self.health <= 0:
            self.kill()
            return True  # Enemy died
        return False
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw enemy"""
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.hurt_timer > 0 and self.frame % 4 < 2:
            return
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw health bar for tough enemies
        if self.max_health > 2:
            self.draw_health_bar(surface, camera_offset)
    
    def draw_health_bar(self, surface, camera_offset):
        """Draw health bar above enemy"""
        bar_width = 30
        bar_height = 4
        
        x = self.rect.centerx - camera_offset[0] - bar_width // 2
        y = self.rect.top - camera_offset[1] - 8
        
        # Background
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health
        health_width = int(bar_width * (self.health / self.max_health))
        pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))


class Slime(Enemy):
    """Slime enemy - easy, hops around"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'slime')
        self.hop_timer = 0
    
    def update_sprite(self):
        self.image = create_slime_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Hop periodically
        self.hop_timer += 1
        if self.hop_timer >= 60:
            self.hop_timer = 0
            self.velocity_y = -6
            
            # Move toward player if nearby, otherwise patrol
            if player and abs(player.rect.centerx - self.rect.centerx) < 200:
                if player.rect.centerx < self.rect.centerx:
                    self.velocity_x = -self.speed * 2
                else:
                    self.velocity_x = self.speed * 2
            else:
                # Patrol
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                self.velocity_x = self.speed * self.direction


class Bat(Enemy):
    """Bat enemy - flying, erratic movement"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'bat')
        self.start_y = y
        self.angle = 0
        self.swoop_target = None
    
    def update_sprite(self):
        self.image = create_bat_sprite(self.frame)
    
    def ai_update(self, player):
        # Erratic flying pattern
        self.angle += 0.05
        
        if player and abs(player.rect.centerx - self.rect.centerx) < 150:
            # Swoop toward player
            dx = player.rect.centerx - self.rect.centerx
            dy = player.rect.centery - self.rect.centery
            dist = math.sqrt(dx * dx + dy * dy)
            
            if dist > 0:
                self.velocity_x = (dx / dist) * self.speed * 1.5
                self.velocity_y = (dy / dist) * self.speed * 1.5
        else:
            # Patrol pattern
            self.velocity_x = math.sin(self.angle) * self.speed
            self.velocity_y = math.cos(self.angle * 2) * self.speed * 0.5
        
        self.facing_right = self.velocity_x > 0
    
    def physics_update(self, tiles):
        # Bats don't use gravity
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Keep within bounds
        if self.rect.y < self.start_y - 100:
            self.rect.y = self.start_y - 100
        if self.rect.y > self.start_y + 100:
            self.rect.y = self.start_y + 100


class Knight(Enemy):
    """Knight enemy - tough, shielded, aggressive"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'knight')
        self.shield_active = True
        self.charge_timer = 0
        self.charging = False
    
    def update_sprite(self):
        self.image = create_knight_sprite(self.facing_right, self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        if player:
            dx = player.rect.centerx - self.rect.centerx
            
            # Face player
            self.facing_right = dx > 0
            
            if abs(dx) < 250:
                # Aggressive pursuit
                self.charge_timer += 1
                
                if self.charge_timer >= 90:
                    # Charge attack
                    self.charging = True
                    self.charge_timer = 0
                
                if self.charging:
                    self.velocity_x = self.speed * 3 * (1 if self.facing_right else -1)
                    if abs(dx) < 30 or abs(dx) > 200:
                        self.charging = False
                else:
                    # Walk toward player
                    if abs(dx) > 40:
                        self.velocity_x = self.speed * (1 if dx > 0 else -1)
            else:
                # Patrol
                self.charge_timer = 0
                self.charging = False
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                    self.facing_right = False
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                    self.facing_right = True
                self.velocity_x = self.speed * self.direction
    
    def take_damage(self, amount):
        """Knights take reduced damage from front when shield is up"""
        if self.shield_active:
            # Shield blocks some damage
            amount = max(1, amount - 1)
        return super().take_damage(amount)


class Cannon(Enemy):
    """Boss enemy - the archenemy"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'cannon')
        self.phase = 1
        self.attack_pattern = 0
        self.pattern_timer = 0
        self.projectiles = pygame.sprite.Group()
        self.arena_bounds = (x - 200, x + 200)
        
        # Intro animation
        self.intro_active = True
        self.intro_timer = 0
        self.intro_duration = 180  # 3 seconds at 60fps
        self.intro_y_offset = -200  # Start above screen
        self.original_y = y
        
        # Phase transition
        self.phase_transition = False
        self.phase_transition_timer = 0
        self.last_phase = 1
    
    def update_sprite(self):
        # Flash during phase transition
        if self.phase_transition and self.frame % 4 < 2:
            self.image = pygame.Surface((48, 48), pygame.SRCALPHA)
            self.image.fill((*YELLOW[:3], 200))
        else:
            self.image = create_cannon_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Handle intro animation
        if self.intro_active:
            self.intro_timer += 1
            # Descend from above
            progress = min(1.0, self.intro_timer / (self.intro_duration * 0.6))
            # Ease out
            ease = 1 - (1 - progress) ** 3
            self.intro_y_offset = -200 * (1 - ease)
            self.rect.y = self.original_y + self.intro_y_offset
            
            if self.intro_timer >= self.intro_duration:
                self.intro_active = False
                self.intro_y_offset = 0
                self.rect.y = self.original_y
            return
        
        if not player:
            return
        
        # Handle phase transition animation
        if self.phase_transition:
            self.phase_transition_timer += 1
            if self.phase_transition_timer >= 60:
                self.phase_transition = False
                self.phase_transition_timer = 0
            return
        
        # Update phase based on health
        old_phase = self.phase
        if self.health <= self.max_health * 0.3:
            self.phase = 3
        elif self.health <= self.max_health * 0.5:
            self.phase = 2
        
        # Trigger phase transition animation
        if self.phase != old_phase:
            self.phase_transition = True
            self.phase_transition_timer = 0
            self.last_phase = self.phase
        
        dx = player.rect.centerx - self.rect.centerx
        self.facing_right = dx > 0
        
        self.pattern_timer += 1
        
        if self.phase == 1:
            self.phase1_ai(player)
        elif self.phase == 2:
            self.phase2_ai(player)
        else:
            self.phase3_ai(player)
    
    def phase1_ai(self, player):
        """Phase 1: Patrol and shoot"""
        # Move back and forth
        if self.rect.x > self.arena_bounds[1]:
            self.direction = -1
        elif self.rect.x < self.arena_bounds[0]:
            self.direction = 1
        
        self.velocity_x = self.speed * self.direction
        
        # Shoot periodically
        if self.pattern_timer >= 90:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase2_ai(self, player):
        """Phase 2: Jump attacks and spread shot"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive chase
        if abs(dx) > 80:
            self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Jump attack periodically
        if self.pattern_timer % 120 == 0 and self.pattern_timer > 0:
            self.velocity_y = -10  # Jump!
        
        # Spread shot - fires 3 cannon balls
        if self.pattern_timer >= 60:
            self.shoot_cannon_ball(player)
            # Shoot additional balls at angles
            self.shoot_spread_shot(player)
            self.pattern_timer = 0
    
    def shoot_spread_shot(self, player):
        """Fire spread of cannon balls"""
        # Upper shot
        ball1 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery - 100
        )
        # Lower shot
        ball2 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery + 100
        )
        self.projectiles.add(ball1)
        self.projectiles.add(ball2)
    
    def phase3_ai(self, player):
        """Phase 3: Enraged - fast and aggressive"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive pursuit
        self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Very rapid fire
        if self.pattern_timer >= 30:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def shoot_cannon_ball(self, player):
        """Fire a cannon ball at the player"""
        ball = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery
        )
        self.projectiles.add(ball)
    
    def update(self, player=None, tiles=None):
        super().update(player, tiles)
        self.projectiles.update()
    
    def draw(self, surface, camera_offset=(0, 0)):
        super().draw(surface, camera_offset)
        
        # Draw projectiles
        for ball in self.projectiles:
            ball.draw(surface, camera_offset)
        
        # Draw boss health bar at top of screen
        self.draw_boss_health_bar(surface)
    
    def draw_boss_health_bar(self, surface):
        """Draw large boss health bar at top"""
        bar_width = 500
        bar_height = 35
        x = SCREEN_WIDTH // 2 - bar_width // 2
        y = 55
        
        pygame.font.init()
        title_font = pygame.font.Font(None, 48)
        phase_font = pygame.font.Font(None, 32)
        
        # Draw intro text if in intro
        if self.intro_active:
            # Dramatic intro text
            if self.intro_timer > 30:
                intro_texts = ["THE ARCHENEMY", "CANNON", "APPEARS!"]
                text_idx = min(2, (self.intro_timer - 30) // 40)
                intro_text = title_font.render(intro_texts[text_idx], True, RED)
                intro_rect = intro_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
                
                # Flashing background
                if self.frame % 8 < 4:
                    pygame.draw.rect(surface, DARK_RED, 
                                   (intro_rect.x - 20, intro_rect.y - 10, 
                                    intro_rect.width + 40, intro_rect.height + 20))
                surface.blit(intro_text, intro_rect)
            return
        
        # Boss name header - large and prominent
        name_text = title_font.render("CANNON", True, YELLOW)
        name_rect = name_text.get_rect(center=(SCREEN_WIDTH // 2, 28))
        
        # Name background panel
        panel_rect = pygame.Rect(name_rect.x - 25, name_rect.y - 8, 
                                name_rect.width + 50, name_rect.height + 16)
        pygame.draw.rect(surface, DARK_BLUE, panel_rect)
        pygame.draw.rect(surface, DARK_RED, panel_rect, 3)
        pygame.draw.rect(surface, YELLOW, panel_rect.inflate(-6, -6), 2)
        surface.blit(name_text, name_rect)
        
        # Skull decorations on sides
        skull_left = title_font.render("☠", True, RED)
        skull_right = title_font.render("☠", True, RED)
        surface.blit(skull_left, (panel_rect.left - 30, name_rect.y - 2))
        surface.blit(skull_right, (panel_rect.right + 10, name_rect.y - 2))
        
        # Health bar outer frame
        frame_rect = pygame.Rect(x - 10, y - 10, bar_width + 20, bar_height + 20)
        pygame.draw.rect(surface, DARK_BLUE, frame_rect)
        pygame.draw.rect(surface, DARK_BROWN, frame_rect, 4)
        
        # Health bar inner background
        pygame.draw.rect(surface, BLACK, (x - 2, y - 2, bar_width + 4, bar_height + 4))
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health bar fill with gradient
        health_width = int(bar_width * (self.health / self.max_health))
        if health_width > 0:
            # Choose color based on phase
            if self.phase == 3:
                bar_color = MAGENTA
                highlight_color = PINK
            elif self.phase == 2:
                bar_color = ORANGE
                highlight_color = YELLOW
            else:
                bar_color = RED
                highlight_color = ORANGE
            
            # Main health bar
            pygame.draw.rect(surface, bar_color, (x, y, health_width, bar_height))
            # Top highlight
            pygame.draw.rect(surface, highlight_color, (x, y, health_width, bar_height // 4))
            # Bottom shadow
            pygame.draw.rect(surface, DARK_RED, (x, y + bar_height - 5, health_width, 5))
        
        # Golden border
        pygame.draw.rect(surface, YELLOW, (x - 4, y - 4, bar_width + 8, bar_height + 8), 3)
        
        # Phase indicator with dramatic styling
        if self.phase >= 2:
            phase_color = MAGENTA if self.phase == 3 else ORANGE
            phase_str = "⚡ PHASE 2 - ENRAGED ⚡" if self.phase == 2 else "💀 PHASE 3 - FINAL FORM 💀"
            phase_text = phase_font.render(phase_str, True, phase_color)
            phase_rect = phase_text.get_rect(center=(SCREEN_WIDTH // 2, y + bar_height + 18))
            
            # Flashing effect during transition
            if self.phase_transition and self.frame % 6 < 3:
                pygame.draw.rect(surface, phase_color, phase_rect.inflate(20, 10))
            surface.blit(phase_text, phase_rect)
        
        # Health percentage
        health_pct = int((self.health / self.max_health) * 100)
        pct_text = phase_font.render(f"{health_pct}%", True, WHITE)
        pct_rect = pct_text.get_rect(center=(x + bar_width // 2, y + bar_height // 2))
        surface.blit(pct_text, pct_rect)


class CannonBall(pygame.sprite.Sprite):
    """Projectile fired by Cannon boss"""
    
    def __init__(self, x, y, target_x, target_y):
        super().__init__()
        
        # Calculate direction
        dx = target_x - x
        dy = target_y - y
        dist = math.sqrt(dx * dx + dy * dy)
        
        self.speed = 5
        if dist > 0:
            self.velocity_x = (dx / dist) * self.speed
            self.velocity_y = (dy / dist) * self.speed
        else:
            self.velocity_x = self.speed
            self.velocity_y = 0
        
        self.damage = 2
        self.lifetime = 180
        
        # Create sprite
        self.image = pygame.Surface((16, 16), pygame.SRCALPHA)
        pygame.draw.circle(self.image, GRAY, (8, 8), 7)
        pygame.draw.circle(self.image, DARK_BROWN, (8, 8), 5)
        pygame.draw.circle(self.image, ORANGE, (6, 6), 2)
        
        self.rect = self.image.get_rect(center=(x, y))
    
    def update(self):
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


def create_enemy(enemy_type, x, y):
    """Factory function to create enemies"""
    if enemy_type == 'slime':
        return Slime(x, y)
    elif enemy_type == 'bat':
        return Bat(x, y)
    elif enemy_type == 'knight':
        return Knight(x, y)
    elif enemy_type == 'cannon':
        return Cannon(x, y)
    else:
        return Slime(x, y)  # Default

```

Done! Here's what I changed:

### Level Music
- Slowed down from 150 BPM to **115 BPM** - much more relaxed pace

### Boss Intro Animation
When you enter the boss arena:
1. **"THE ARCHENEMY"** appears on screen
2. **"CANNON"** flashes dramatically  
3. **"APPEARS!"** announces his arrival
4. Cannon **descends from above** with a smooth easing animation
5. Fight begins after the 3-second intro

### Enhanced Health Bar
- **Larger** (500px wide, 35px tall)
- **"CANNON"** title in big yellow letters at the top
- **Skull decorations** (☠) on each side of the name
- **Health percentage** displayed in the center of the bar
- **Color changes by phase**: Red → Orange → Magenta
- Golden border with shadow effects

### Phase 2 Overhaul
- **Jump attacks** - Cannon leaps into the air periodically
- **Spread shot** - Fires 3 cannon balls at once (high, center, low)
- **Faster movement** - More aggressive pursuit
- Triggers at **50% health** (was 60%)
- Shows **"⚡ PHASE 2 - ENRAGED ⚡"** below health bar

### Phase Transitions
- When entering a new phase, Cannon **flashes yellow** for 1 second
- Phase indicators flash dramatically during transition
- Phase 3 shows **"💀 PHASE 3 - FINAL FORM 💀"**

---

**User**

The game just crashed. Please look at the output in the terminal and fix it.

---

**Cursor**

I can see the error clearly in the terminal output:

```
AttributeError: 'Cannon' object has no attribute 'phase_transition'
```

The crash occurs at `enemies.py:293` in `update_sprite()` when trying to access `self.phase_transition`.

## Hypotheses

1. **H-A (Initialization Order)**: `super().__init__()` in `Cannon.__init__` calls `update_sprite()` before the `phase_transition` attribute is defined. The parent `Enemy.__init__` calls `self.update_sprite()` at line 44, but `phase_transition` isn't set until after the `super()` call.

2. **H-B (Missing Attribute)**: The `phase_transition` attribute was accidentally removed or never properly added during a code edit.

3. **H-C (Object State)**: There's a code path where a Cannon object is created but doesn't have all attributes initialized properly.

Let me add instrumentation to confirm which hypothesis is correct:

```plaintext
AttributeError: 'Cannon' object has no attribute 'phase_transition'
```

```python
"""
Enemy classes for Chain
"""

import pygame
import math
import random
from settings import *
from sprites import create_slime_sprite, create_bat_sprite, create_knight_sprite, create_cannon_sprite


class Enemy(pygame.sprite.Sprite):
    """Base enemy class"""
    
    def __init__(self, x, y, enemy_type):
        super().__init__()
        self.enemy_type = enemy_type
        self.stats = ENEMY_TYPES[enemy_type]
        
        self.max_health = self.stats['health']
        self.health = self.max_health
        self.damage = self.stats['damage']
        self.speed = self.stats['speed']
        self.score = self.stats['score']
        
        self.frame = 0
        self.facing_right = True
        
        # AI state
        self.state = 'patrol'
        self.patrol_distance = 100
        self.start_x = x
        self.direction = 1
        
        # Physics
        self.velocity_x = 0
        self.velocity_y = 0
        
        # Combat
        self.hurt_timer = 0
        self.attack_cooldown = 0
        
        # Create initial sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
    
    def update_sprite(self):
        """Override in subclasses"""
        pass
    
    def update(self, player=None, tiles=None):
        """Update enemy state"""
        self.frame += 1
        
        if self.hurt_timer > 0:
            self.hurt_timer -= 1
        
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        self.ai_update(player)
        self.physics_update(tiles)
        self.update_sprite()
    
    def ai_update(self, player):
        """AI behavior - override in subclasses"""
        pass
    
    def physics_update(self, tiles):
        """Apply physics"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:
            self.velocity_y = 15
        
        # Move
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def take_damage(self, amount):
        """Take damage"""
        self.health -= amount
        self.hurt_timer = 10
        
        if self.health <= 0:
            self.kill()
            return True  # Enemy died
        return False
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw enemy"""
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.hurt_timer > 0 and self.frame % 4 < 2:
            return
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw health bar for tough enemies
        if self.max_health > 2:
            self.draw_health_bar(surface, camera_offset)
    
    def draw_health_bar(self, surface, camera_offset):
        """Draw health bar above enemy"""
        bar_width = 30
        bar_height = 4
        
        x = self.rect.centerx - camera_offset[0] - bar_width // 2
        y = self.rect.top - camera_offset[1] - 8
        
        # Background
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health
        health_width = int(bar_width * (self.health / self.max_health))
        pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))


class Slime(Enemy):
    """Slime enemy - easy, hops around"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'slime')
        self.hop_timer = 0
    
    def update_sprite(self):
        self.image = create_slime_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Hop periodically
        self.hop_timer += 1
        if self.hop_timer >= 60:
            self.hop_timer = 0
            self.velocity_y = -6
            
            # Move toward player if nearby, otherwise patrol
            if player and abs(player.rect.centerx - self.rect.centerx) < 200:
                if player.rect.centerx < self.rect.centerx:
                    self.velocity_x = -self.speed * 2
                else:
                    self.velocity_x = self.speed * 2
            else:
                # Patrol
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                self.velocity_x = self.speed * self.direction


class Bat(Enemy):
    """Bat enemy - flying, erratic movement"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'bat')
        self.start_y = y
        self.angle = 0
        self.swoop_target = None
    
    def update_sprite(self):
        self.image = create_bat_sprite(self.frame)
    
    def ai_update(self, player):
        # Erratic flying pattern
        self.angle += 0.05
        
        if player and abs(player.rect.centerx - self.rect.centerx) < 150:
            # Swoop toward player
            dx = player.rect.centerx - self.rect.centerx
            dy = player.rect.centery - self.rect.centery
            dist = math.sqrt(dx * dx + dy * dy)
            
            if dist > 0:
                self.velocity_x = (dx / dist) * self.speed * 1.5
                self.velocity_y = (dy / dist) * self.speed * 1.5
        else:
            # Patrol pattern
            self.velocity_x = math.sin(self.angle) * self.speed
            self.velocity_y = math.cos(self.angle * 2) * self.speed * 0.5
        
        self.facing_right = self.velocity_x > 0
    
    def physics_update(self, tiles):
        # Bats don't use gravity
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Keep within bounds
        if self.rect.y < self.start_y - 100:
            self.rect.y = self.start_y - 100
        if self.rect.y > self.start_y + 100:
            self.rect.y = self.start_y + 100


class Knight(Enemy):
    """Knight enemy - tough, shielded, aggressive"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'knight')
        self.shield_active = True
        self.charge_timer = 0
        self.charging = False
    
    def update_sprite(self):
        self.image = create_knight_sprite(self.facing_right, self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        if player:
            dx = player.rect.centerx - self.rect.centerx
            
            # Face player
            self.facing_right = dx > 0
            
            if abs(dx) < 250:
                # Aggressive pursuit
                self.charge_timer += 1
                
                if self.charge_timer >= 90:
                    # Charge attack
                    self.charging = True
                    self.charge_timer = 0
                
                if self.charging:
                    self.velocity_x = self.speed * 3 * (1 if self.facing_right else -1)
                    if abs(dx) < 30 or abs(dx) > 200:
                        self.charging = False
                else:
                    # Walk toward player
                    if abs(dx) > 40:
                        self.velocity_x = self.speed * (1 if dx > 0 else -1)
            else:
                # Patrol
                self.charge_timer = 0
                self.charging = False
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                    self.facing_right = False
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                    self.facing_right = True
                self.velocity_x = self.speed * self.direction
    
    def take_damage(self, amount):
        """Knights take reduced damage from front when shield is up"""
        if self.shield_active:
            # Shield blocks some damage
            amount = max(1, amount - 1)
        return super().take_damage(amount)


class Cannon(Enemy):
    """Boss enemy - the archenemy"""
    
    def __init__(self, x, y):
        # #region agent log
        import json; open('./.cursor/debug.log','a').write(json.dumps({"hypothesisId":"H-A","location":"enemies.py:Cannon.__init__:before_super","message":"About to call super().__init__","data":{"x":x,"y":y},"timestamp":__import__('time').time()})+'\n')
        # #endregion
        super().__init__(x, y, 'cannon')
        self.phase = 1
        self.attack_pattern = 0
        self.pattern_timer = 0
        self.projectiles = pygame.sprite.Group()
        self.arena_bounds = (x - 200, x + 200)
        
        # Intro animation
        self.intro_active = True
        self.intro_timer = 0
        self.intro_duration = 180  # 3 seconds at 60fps
        self.intro_y_offset = -200  # Start above screen
        self.original_y = y
        
        # Phase transition
        self.phase_transition = False
        self.phase_transition_timer = 0
        self.last_phase = 1
    
    def update_sprite(self):
        # Flash during phase transition
        if self.phase_transition and self.frame % 4 < 2:
            self.image = pygame.Surface((48, 48), pygame.SRCALPHA)
            self.image.fill((*YELLOW[:3], 200))
        else:
            self.image = create_cannon_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Handle intro animation
        if self.intro_active:
            self.intro_timer += 1
            # Descend from above
            progress = min(1.0, self.intro_timer / (self.intro_duration * 0.6))
            # Ease out
            ease = 1 - (1 - progress) ** 3
            self.intro_y_offset = -200 * (1 - ease)
            self.rect.y = self.original_y + self.intro_y_offset
            
            if self.intro_timer >= self.intro_duration:
                self.intro_active = False
                self.intro_y_offset = 0
                self.rect.y = self.original_y
            return
        
        if not player:
            return
        
        # Handle phase transition animation
        if self.phase_transition:
            self.phase_transition_timer += 1
            if self.phase_transition_timer >= 60:
                self.phase_transition = False
                self.phase_transition_timer = 0
            return
        
        # Update phase based on health
        old_phase = self.phase
        if self.health <= self.max_health * 0.3:
            self.phase = 3
        elif self.health <= self.max_health * 0.5:
            self.phase = 2
        
        # Trigger phase transition animation
        if self.phase != old_phase:
            self.phase_transition = True
            self.phase_transition_timer = 0
            self.last_phase = self.phase
        
        dx = player.rect.centerx - self.rect.centerx
        self.facing_right = dx > 0
        
        self.pattern_timer += 1
        
        if self.phase == 1:
            self.phase1_ai(player)
        elif self.phase == 2:
            self.phase2_ai(player)
        else:
            self.phase3_ai(player)
    
    def phase1_ai(self, player):
        """Phase 1: Patrol and shoot"""
        # Move back and forth
        if self.rect.x > self.arena_bounds[1]:
            self.direction = -1
        elif self.rect.x < self.arena_bounds[0]:
            self.direction = 1
        
        self.velocity_x = self.speed * self.direction
        
        # Shoot periodically
        if self.pattern_timer >= 90:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase2_ai(self, player):
        """Phase 2: Jump attacks and spread shot"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive chase
        if abs(dx) > 80:
            self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Jump attack periodically
        if self.pattern_timer % 120 == 0 and self.pattern_timer > 0:
            self.velocity_y = -10  # Jump!
        
        # Spread shot - fires 3 cannon balls
        if self.pattern_timer >= 60:
            self.shoot_cannon_ball(player)
            # Shoot additional balls at angles
            self.shoot_spread_shot(player)
            self.pattern_timer = 0
    
    def shoot_spread_shot(self, player):
        """Fire spread of cannon balls"""
        # Upper shot
        ball1 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery - 100
        )
        # Lower shot
        ball2 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery + 100
        )
        self.projectiles.add(ball1)
        self.projectiles.add(ball2)
    
    def phase3_ai(self, player):
        """Phase 3: Enraged - fast and aggressive"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive pursuit
        self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Very rapid fire
        if self.pattern_timer >= 30:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def shoot_cannon_ball(self, player):
        """Fire a cannon ball at the player"""
        ball = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery
        )
        self.projectiles.add(ball)
    
    def update(self, player=None, tiles=None):
        super().update(player, tiles)
        self.projectiles.update()
    
    def draw(self, surface, camera_offset=(0, 0)):
        super().draw(surface, camera_offset)
        
        # Draw projectiles
        for ball in self.projectiles:
            ball.draw(surface, camera_offset)
        
        # Draw boss health bar at top of screen
        self.draw_boss_health_bar(surface)
    
    def draw_boss_health_bar(self, surface):
        """Draw large boss health bar at top"""
        bar_width = 500
        bar_height = 35
        x = SCREEN_WIDTH // 2 - bar_width // 2
        y = 55
        
        pygame.font.init()
        title_font = pygame.font.Font(None, 48)
        phase_font = pygame.font.Font(None, 32)
        
        # Draw intro text if in intro
        if self.intro_active:
            # Dramatic intro text
            if self.intro_timer > 30:
                intro_texts = ["THE ARCHENEMY", "CANNON", "APPEARS!"]
                text_idx = min(2, (self.intro_timer - 30) // 40)
                intro_text = title_font.render(intro_texts[text_idx], True, RED)
                intro_rect = intro_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
                
                # Flashing background
                if self.frame % 8 < 4:
                    pygame.draw.rect(surface, DARK_RED, 
                                   (intro_rect.x - 20, intro_rect.y - 10, 
                                    intro_rect.width + 40, intro_rect.height + 20))
                surface.blit(intro_text, intro_rect)
            return
        
        # Boss name header - large and prominent
        name_text = title_font.render("CANNON", True, YELLOW)
        name_rect = name_text.get_rect(center=(SCREEN_WIDTH // 2, 28))
        
        # Name background panel
        panel_rect = pygame.Rect(name_rect.x - 25, name_rect.y - 8, 
                                name_rect.width + 50, name_rect.height + 16)
        pygame.draw.rect(surface, DARK_BLUE, panel_rect)
        pygame.draw.rect(surface, DARK_RED, panel_rect, 3)
        pygame.draw.rect(surface, YELLOW, panel_rect.inflate(-6, -6), 2)
        surface.blit(name_text, name_rect)
        
        # Skull decorations on sides
        skull_left = title_font.render("☠", True, RED)
        skull_right = title_font.render("☠", True, RED)
        surface.blit(skull_left, (panel_rect.left - 30, name_rect.y - 2))
        surface.blit(skull_right, (panel_rect.right + 10, name_rect.y - 2))
        
        # Health bar outer frame
        frame_rect = pygame.Rect(x - 10, y - 10, bar_width + 20, bar_height + 20)
        pygame.draw.rect(surface, DARK_BLUE, frame_rect)
        pygame.draw.rect(surface, DARK_BROWN, frame_rect, 4)
        
        # Health bar inner background
        pygame.draw.rect(surface, BLACK, (x - 2, y - 2, bar_width + 4, bar_height + 4))
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health bar fill with gradient
        health_width = int(bar_width * (self.health / self.max_health))
        if health_width > 0:
            # Choose color based on phase
            if self.phase == 3:
                bar_color = MAGENTA
                highlight_color = PINK
            elif self.phase == 2:
                bar_color = ORANGE
                highlight_color = YELLOW
            else:
                bar_color = RED
                highlight_color = ORANGE
            
            # Main health bar
            pygame.draw.rect(surface, bar_color, (x, y, health_width, bar_height))
            # Top highlight
            pygame.draw.rect(surface, highlight_color, (x, y, health_width, bar_height // 4))
            # Bottom shadow
            pygame.draw.rect(surface, DARK_RED, (x, y + bar_height - 5, health_width, 5))
        
        # Golden border
        pygame.draw.rect(surface, YELLOW, (x - 4, y - 4, bar_width + 8, bar_height + 8), 3)
        
        # Phase indicator with dramatic styling
        if self.phase >= 2:
            phase_color = MAGENTA if self.phase == 3 else ORANGE
            phase_str = "⚡ PHASE 2 - ENRAGED ⚡" if self.phase == 2 else "💀 PHASE 3 - FINAL FORM 💀"
            phase_text = phase_font.render(phase_str, True, phase_color)
            phase_rect = phase_text.get_rect(center=(SCREEN_WIDTH // 2, y + bar_height + 18))
            
            # Flashing effect during transition
            if self.phase_transition and self.frame % 6 < 3:
                pygame.draw.rect(surface, phase_color, phase_rect.inflate(20, 10))
            surface.blit(phase_text, phase_rect)
        
        # Health percentage
        health_pct = int((self.health / self.max_health) * 100)
        pct_text = phase_font.render(f"{health_pct}%", True, WHITE)
        pct_rect = pct_text.get_rect(center=(x + bar_width // 2, y + bar_height // 2))
        surface.blit(pct_text, pct_rect)


class CannonBall(pygame.sprite.Sprite):
    """Projectile fired by Cannon boss"""
    
    def __init__(self, x, y, target_x, target_y):
        super().__init__()
        
        # Calculate direction
        dx = target_x - x
        dy = target_y - y
        dist = math.sqrt(dx * dx + dy * dy)
        
        self.speed = 5
        if dist > 0:
            self.velocity_x = (dx / dist) * self.speed
            self.velocity_y = (dy / dist) * self.speed
        else:
            self.velocity_x = self.speed
            self.velocity_y = 0
        
        self.damage = 2
        self.lifetime = 180
        
        # Create sprite
        self.image = pygame.Surface((16, 16), pygame.SRCALPHA)
        pygame.draw.circle(self.image, GRAY, (8, 8), 7)
        pygame.draw.circle(self.image, DARK_BROWN, (8, 8), 5)
        pygame.draw.circle(self.image, ORANGE, (6, 6), 2)
        
        self.rect = self.image.get_rect(center=(x, y))
    
    def update(self):
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


def create_enemy(enemy_type, x, y):
    """Factory function to create enemies"""
    if enemy_type == 'slime':
        return Slime(x, y)
    elif enemy_type == 'bat':
        return Bat(x, y)
    elif enemy_type == 'knight':
        return Knight(x, y)
    elif enemy_type == 'cannon':
        return Cannon(x, y)
    else:
        return Slime(x, y)  # Default

```

```python
"""
Enemy classes for Chain
"""

import pygame
import math
import random
from settings import *
from sprites import create_slime_sprite, create_bat_sprite, create_knight_sprite, create_cannon_sprite


class Enemy(pygame.sprite.Sprite):
    """Base enemy class"""
    
    def __init__(self, x, y, enemy_type):
        super().__init__()
        self.enemy_type = enemy_type
        self.stats = ENEMY_TYPES[enemy_type]
        
        self.max_health = self.stats['health']
        self.health = self.max_health
        self.damage = self.stats['damage']
        self.speed = self.stats['speed']
        self.score = self.stats['score']
        
        self.frame = 0
        self.facing_right = True
        
        # AI state
        self.state = 'patrol'
        self.patrol_distance = 100
        self.start_x = x
        self.direction = 1
        
        # Physics
        self.velocity_x = 0
        self.velocity_y = 0
        
        # Combat
        self.hurt_timer = 0
        self.attack_cooldown = 0
        
        # Create initial sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
    
    def update_sprite(self):
        """Override in subclasses"""
        pass
    
    def update(self, player=None, tiles=None):
        """Update enemy state"""
        self.frame += 1
        
        if self.hurt_timer > 0:
            self.hurt_timer -= 1
        
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        self.ai_update(player)
        self.physics_update(tiles)
        self.update_sprite()
    
    def ai_update(self, player):
        """AI behavior - override in subclasses"""
        pass
    
    def physics_update(self, tiles):
        """Apply physics"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:
            self.velocity_y = 15
        
        # Move
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def take_damage(self, amount):
        """Take damage"""
        self.health -= amount
        self.hurt_timer = 10
        
        if self.health <= 0:
            self.kill()
            return True  # Enemy died
        return False
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw enemy"""
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.hurt_timer > 0 and self.frame % 4 < 2:
            return
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw health bar for tough enemies
        if self.max_health > 2:
            self.draw_health_bar(surface, camera_offset)
    
    def draw_health_bar(self, surface, camera_offset):
        """Draw health bar above enemy"""
        bar_width = 30
        bar_height = 4
        
        x = self.rect.centerx - camera_offset[0] - bar_width // 2
        y = self.rect.top - camera_offset[1] - 8
        
        # Background
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health
        health_width = int(bar_width * (self.health / self.max_health))
        pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))


class Slime(Enemy):
    """Slime enemy - easy, hops around"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'slime')
        self.hop_timer = 0
    
    def update_sprite(self):
        self.image = create_slime_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Hop periodically
        self.hop_timer += 1
        if self.hop_timer >= 60:
            self.hop_timer = 0
            self.velocity_y = -6
            
            # Move toward player if nearby, otherwise patrol
            if player and abs(player.rect.centerx - self.rect.centerx) < 200:
                if player.rect.centerx < self.rect.centerx:
                    self.velocity_x = -self.speed * 2
                else:
                    self.velocity_x = self.speed * 2
            else:
                # Patrol
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                self.velocity_x = self.speed * self.direction


class Bat(Enemy):
    """Bat enemy - flying, erratic movement"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'bat')
        self.start_y = y
        self.angle = 0
        self.swoop_target = None
    
    def update_sprite(self):
        self.image = create_bat_sprite(self.frame)
    
    def ai_update(self, player):
        # Erratic flying pattern
        self.angle += 0.05
        
        if player and abs(player.rect.centerx - self.rect.centerx) < 150:
            # Swoop toward player
            dx = player.rect.centerx - self.rect.centerx
            dy = player.rect.centery - self.rect.centery
            dist = math.sqrt(dx * dx + dy * dy)
            
            if dist > 0:
                self.velocity_x = (dx / dist) * self.speed * 1.5
                self.velocity_y = (dy / dist) * self.speed * 1.5
        else:
            # Patrol pattern
            self.velocity_x = math.sin(self.angle) * self.speed
            self.velocity_y = math.cos(self.angle * 2) * self.speed * 0.5
        
        self.facing_right = self.velocity_x > 0
    
    def physics_update(self, tiles):
        # Bats don't use gravity
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Keep within bounds
        if self.rect.y < self.start_y - 100:
            self.rect.y = self.start_y - 100
        if self.rect.y > self.start_y + 100:
            self.rect.y = self.start_y + 100


class Knight(Enemy):
    """Knight enemy - tough, shielded, aggressive"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'knight')
        self.shield_active = True
        self.charge_timer = 0
        self.charging = False
    
    def update_sprite(self):
        self.image = create_knight_sprite(self.facing_right, self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        if player:
            dx = player.rect.centerx - self.rect.centerx
            
            # Face player
            self.facing_right = dx > 0
            
            if abs(dx) < 250:
                # Aggressive pursuit
                self.charge_timer += 1
                
                if self.charge_timer >= 90:
                    # Charge attack
                    self.charging = True
                    self.charge_timer = 0
                
                if self.charging:
                    self.velocity_x = self.speed * 3 * (1 if self.facing_right else -1)
                    if abs(dx) < 30 or abs(dx) > 200:
                        self.charging = False
                else:
                    # Walk toward player
                    if abs(dx) > 40:
                        self.velocity_x = self.speed * (1 if dx > 0 else -1)
            else:
                # Patrol
                self.charge_timer = 0
                self.charging = False
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                    self.facing_right = False
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                    self.facing_right = True
                self.velocity_x = self.speed * self.direction
    
    def take_damage(self, amount):
        """Knights take reduced damage from front when shield is up"""
        if self.shield_active:
            # Shield blocks some damage
            amount = max(1, amount - 1)
        return super().take_damage(amount)


class Cannon(Enemy):
    """Boss enemy - the archenemy"""
    
    def __init__(self, x, y):
        # #region agent log
        import json; open('./.cursor/debug.log','a').write(json.dumps({"hypothesisId":"H-A","location":"enemies.py:Cannon.__init__:before_super","message":"About to call super().__init__","data":{"x":x,"y":y},"timestamp":__import__('time').time()})+'\n')
        # #endregion
        super().__init__(x, y, 'cannon')
        self.phase = 1
        self.attack_pattern = 0
        self.pattern_timer = 0
        self.projectiles = pygame.sprite.Group()
        self.arena_bounds = (x - 200, x + 200)
        
        # #region agent log
        import json; open('./.cursor/debug.log','a').write(json.dumps({"hypothesisId":"H-A","location":"enemies.py:Cannon.__init__:after_super","message":"Returned from super().__init__, now setting Cannon attrs","timestamp":__import__('time').time()})+'\n')
        # #endregion
        # Intro animation
        self.intro_active = True
        self.intro_timer = 0
        self.intro_duration = 180  # 3 seconds at 60fps
        self.intro_y_offset = -200  # Start above screen
        self.original_y = y
        
        # Phase transition
        self.phase_transition = False
        self.phase_transition_timer = 0
        self.last_phase = 1
    
    def update_sprite(self):
        # Flash during phase transition
        if self.phase_transition and self.frame % 4 < 2:
            self.image = pygame.Surface((48, 48), pygame.SRCALPHA)
            self.image.fill((*YELLOW[:3], 200))
        else:
            self.image = create_cannon_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Handle intro animation
        if self.intro_active:
            self.intro_timer += 1
            # Descend from above
            progress = min(1.0, self.intro_timer / (self.intro_duration * 0.6))
            # Ease out
            ease = 1 - (1 - progress) ** 3
            self.intro_y_offset = -200 * (1 - ease)
            self.rect.y = self.original_y + self.intro_y_offset
            
            if self.intro_timer >= self.intro_duration:
                self.intro_active = False
                self.intro_y_offset = 0
                self.rect.y = self.original_y
            return
        
        if not player:
            return
        
        # Handle phase transition animation
        if self.phase_transition:
            self.phase_transition_timer += 1
            if self.phase_transition_timer >= 60:
                self.phase_transition = False
                self.phase_transition_timer = 0
            return
        
        # Update phase based on health
        old_phase = self.phase
        if self.health <= self.max_health * 0.3:
            self.phase = 3
        elif self.health <= self.max_health * 0.5:
            self.phase = 2
        
        # Trigger phase transition animation
        if self.phase != old_phase:
            self.phase_transition = True
            self.phase_transition_timer = 0
            self.last_phase = self.phase
        
        dx = player.rect.centerx - self.rect.centerx
        self.facing_right = dx > 0
        
        self.pattern_timer += 1
        
        if self.phase == 1:
            self.phase1_ai(player)
        elif self.phase == 2:
            self.phase2_ai(player)
        else:
            self.phase3_ai(player)
    
    def phase1_ai(self, player):
        """Phase 1: Patrol and shoot"""
        # Move back and forth
        if self.rect.x > self.arena_bounds[1]:
            self.direction = -1
        elif self.rect.x < self.arena_bounds[0]:
            self.direction = 1
        
        self.velocity_x = self.speed * self.direction
        
        # Shoot periodically
        if self.pattern_timer >= 90:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase2_ai(self, player):
        """Phase 2: Jump attacks and spread shot"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive chase
        if abs(dx) > 80:
            self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Jump attack periodically
        if self.pattern_timer % 120 == 0 and self.pattern_timer > 0:
            self.velocity_y = -10  # Jump!
        
        # Spread shot - fires 3 cannon balls
        if self.pattern_timer >= 60:
            self.shoot_cannon_ball(player)
            # Shoot additional balls at angles
            self.shoot_spread_shot(player)
            self.pattern_timer = 0
    
    def shoot_spread_shot(self, player):
        """Fire spread of cannon balls"""
        # Upper shot
        ball1 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery - 100
        )
        # Lower shot
        ball2 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery + 100
        )
        self.projectiles.add(ball1)
        self.projectiles.add(ball2)
    
    def phase3_ai(self, player):
        """Phase 3: Enraged - fast and aggressive"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive pursuit
        self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Very rapid fire
        if self.pattern_timer >= 30:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def shoot_cannon_ball(self, player):
        """Fire a cannon ball at the player"""
        ball = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery
        )
        self.projectiles.add(ball)
    
    def update(self, player=None, tiles=None):
        super().update(player, tiles)
        self.projectiles.update()
    
    def draw(self, surface, camera_offset=(0, 0)):
        super().draw(surface, camera_offset)
        
        # Draw projectiles
        for ball in self.projectiles:
            ball.draw(surface, camera_offset)
        
        # Draw boss health bar at top of screen
        self.draw_boss_health_bar(surface)
    
    def draw_boss_health_bar(self, surface):
        """Draw large boss health bar at top"""
        bar_width = 500
        bar_height = 35
        x = SCREEN_WIDTH // 2 - bar_width // 2
        y = 55
        
        pygame.font.init()
        title_font = pygame.font.Font(None, 48)
        phase_font = pygame.font.Font(None, 32)
        
        # Draw intro text if in intro
        if self.intro_active:
            # Dramatic intro text
            if self.intro_timer > 30:
                intro_texts = ["THE ARCHENEMY", "CANNON", "APPEARS!"]
                text_idx = min(2, (self.intro_timer - 30) // 40)
                intro_text = title_font.render(intro_texts[text_idx], True, RED)
                intro_rect = intro_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
                
                # Flashing background
                if self.frame % 8 < 4:
                    pygame.draw.rect(surface, DARK_RED, 
                                   (intro_rect.x - 20, intro_rect.y - 10, 
                                    intro_rect.width + 40, intro_rect.height + 20))
                surface.blit(intro_text, intro_rect)
            return
        
        # Boss name header - large and prominent
        name_text = title_font.render("CANNON", True, YELLOW)
        name_rect = name_text.get_rect(center=(SCREEN_WIDTH // 2, 28))
        
        # Name background panel
        panel_rect = pygame.Rect(name_rect.x - 25, name_rect.y - 8, 
                                name_rect.width + 50, name_rect.height + 16)
        pygame.draw.rect(surface, DARK_BLUE, panel_rect)
        pygame.draw.rect(surface, DARK_RED, panel_rect, 3)
        pygame.draw.rect(surface, YELLOW, panel_rect.inflate(-6, -6), 2)
        surface.blit(name_text, name_rect)
        
        # Skull decorations on sides
        skull_left = title_font.render("☠", True, RED)
        skull_right = title_font.render("☠", True, RED)
        surface.blit(skull_left, (panel_rect.left - 30, name_rect.y - 2))
        surface.blit(skull_right, (panel_rect.right + 10, name_rect.y - 2))
        
        # Health bar outer frame
        frame_rect = pygame.Rect(x - 10, y - 10, bar_width + 20, bar_height + 20)
        pygame.draw.rect(surface, DARK_BLUE, frame_rect)
        pygame.draw.rect(surface, DARK_BROWN, frame_rect, 4)
        
        # Health bar inner background
        pygame.draw.rect(surface, BLACK, (x - 2, y - 2, bar_width + 4, bar_height + 4))
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health bar fill with gradient
        health_width = int(bar_width * (self.health / self.max_health))
        if health_width > 0:
            # Choose color based on phase
            if self.phase == 3:
                bar_color = MAGENTA
                highlight_color = PINK
            elif self.phase == 2:
                bar_color = ORANGE
                highlight_color = YELLOW
            else:
                bar_color = RED
                highlight_color = ORANGE
            
            # Main health bar
            pygame.draw.rect(surface, bar_color, (x, y, health_width, bar_height))
            # Top highlight
            pygame.draw.rect(surface, highlight_color, (x, y, health_width, bar_height // 4))
            # Bottom shadow
            pygame.draw.rect(surface, DARK_RED, (x, y + bar_height - 5, health_width, 5))
        
        # Golden border
        pygame.draw.rect(surface, YELLOW, (x - 4, y - 4, bar_width + 8, bar_height + 8), 3)
        
        # Phase indicator with dramatic styling
        if self.phase >= 2:
            phase_color = MAGENTA if self.phase == 3 else ORANGE
            phase_str = "⚡ PHASE 2 - ENRAGED ⚡" if self.phase == 2 else "💀 PHASE 3 - FINAL FORM 💀"
            phase_text = phase_font.render(phase_str, True, phase_color)
            phase_rect = phase_text.get_rect(center=(SCREEN_WIDTH // 2, y + bar_height + 18))
            
            # Flashing effect during transition
            if self.phase_transition and self.frame % 6 < 3:
                pygame.draw.rect(surface, phase_color, phase_rect.inflate(20, 10))
            surface.blit(phase_text, phase_rect)
        
        # Health percentage
        health_pct = int((self.health / self.max_health) * 100)
        pct_text = phase_font.render(f"{health_pct}%", True, WHITE)
        pct_rect = pct_text.get_rect(center=(x + bar_width // 2, y + bar_height // 2))
        surface.blit(pct_text, pct_rect)


class CannonBall(pygame.sprite.Sprite):
    """Projectile fired by Cannon boss"""
    
    def __init__(self, x, y, target_x, target_y):
        super().__init__()
        
        # Calculate direction
        dx = target_x - x
        dy = target_y - y
        dist = math.sqrt(dx * dx + dy * dy)
        
        self.speed = 5
        if dist > 0:
            self.velocity_x = (dx / dist) * self.speed
            self.velocity_y = (dy / dist) * self.speed
        else:
            self.velocity_x = self.speed
            self.velocity_y = 0
        
        self.damage = 2
        self.lifetime = 180
        
        # Create sprite
        self.image = pygame.Surface((16, 16), pygame.SRCALPHA)
        pygame.draw.circle(self.image, GRAY, (8, 8), 7)
        pygame.draw.circle(self.image, DARK_BROWN, (8, 8), 5)
        pygame.draw.circle(self.image, ORANGE, (6, 6), 2)
        
        self.rect = self.image.get_rect(center=(x, y))
    
    def update(self):
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


def create_enemy(enemy_type, x, y):
    """Factory function to create enemies"""
    if enemy_type == 'slime':
        return Slime(x, y)
    elif enemy_type == 'bat':
        return Bat(x, y)
    elif enemy_type == 'knight':
        return Knight(x, y)
    elif enemy_type == 'cannon':
        return Cannon(x, y)
    else:
        return Slime(x, y)  # Default

```

```python
"""
Enemy classes for Chain
"""

import pygame
import math
import random
from settings import *
from sprites import create_slime_sprite, create_bat_sprite, create_knight_sprite, create_cannon_sprite


class Enemy(pygame.sprite.Sprite):
    """Base enemy class"""
    
    def __init__(self, x, y, enemy_type):
        super().__init__()
        self.enemy_type = enemy_type
        self.stats = ENEMY_TYPES[enemy_type]
        
        self.max_health = self.stats['health']
        self.health = self.max_health
        self.damage = self.stats['damage']
        self.speed = self.stats['speed']
        self.score = self.stats['score']
        
        self.frame = 0
        self.facing_right = True
        
        # AI state
        self.state = 'patrol'
        self.patrol_distance = 100
        self.start_x = x
        self.direction = 1
        
        # Physics
        self.velocity_x = 0
        self.velocity_y = 0
        
        # Combat
        self.hurt_timer = 0
        self.attack_cooldown = 0
        
        # Create initial sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
    
    def update_sprite(self):
        """Override in subclasses"""
        pass
    
    def update(self, player=None, tiles=None):
        """Update enemy state"""
        self.frame += 1
        
        if self.hurt_timer > 0:
            self.hurt_timer -= 1
        
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        self.ai_update(player)
        self.physics_update(tiles)
        self.update_sprite()
    
    def ai_update(self, player):
        """AI behavior - override in subclasses"""
        pass
    
    def physics_update(self, tiles):
        """Apply physics"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:
            self.velocity_y = 15
        
        # Move
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def take_damage(self, amount):
        """Take damage"""
        self.health -= amount
        self.hurt_timer = 10
        
        if self.health <= 0:
            self.kill()
            return True  # Enemy died
        return False
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw enemy"""
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.hurt_timer > 0 and self.frame % 4 < 2:
            return
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw health bar for tough enemies
        if self.max_health > 2:
            self.draw_health_bar(surface, camera_offset)
    
    def draw_health_bar(self, surface, camera_offset):
        """Draw health bar above enemy"""
        bar_width = 30
        bar_height = 4
        
        x = self.rect.centerx - camera_offset[0] - bar_width // 2
        y = self.rect.top - camera_offset[1] - 8
        
        # Background
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health
        health_width = int(bar_width * (self.health / self.max_health))
        pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))


class Slime(Enemy):
    """Slime enemy - easy, hops around"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'slime')
        self.hop_timer = 0
    
    def update_sprite(self):
        self.image = create_slime_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Hop periodically
        self.hop_timer += 1
        if self.hop_timer >= 60:
            self.hop_timer = 0
            self.velocity_y = -6
            
            # Move toward player if nearby, otherwise patrol
            if player and abs(player.rect.centerx - self.rect.centerx) < 200:
                if player.rect.centerx < self.rect.centerx:
                    self.velocity_x = -self.speed * 2
                else:
                    self.velocity_x = self.speed * 2
            else:
                # Patrol
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                self.velocity_x = self.speed * self.direction


class Bat(Enemy):
    """Bat enemy - flying, erratic movement"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'bat')
        self.start_y = y
        self.angle = 0
        self.swoop_target = None
    
    def update_sprite(self):
        self.image = create_bat_sprite(self.frame)
    
    def ai_update(self, player):
        # Erratic flying pattern
        self.angle += 0.05
        
        if player and abs(player.rect.centerx - self.rect.centerx) < 150:
            # Swoop toward player
            dx = player.rect.centerx - self.rect.centerx
            dy = player.rect.centery - self.rect.centery
            dist = math.sqrt(dx * dx + dy * dy)
            
            if dist > 0:
                self.velocity_x = (dx / dist) * self.speed * 1.5
                self.velocity_y = (dy / dist) * self.speed * 1.5
        else:
            # Patrol pattern
            self.velocity_x = math.sin(self.angle) * self.speed
            self.velocity_y = math.cos(self.angle * 2) * self.speed * 0.5
        
        self.facing_right = self.velocity_x > 0
    
    def physics_update(self, tiles):
        # Bats don't use gravity
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Keep within bounds
        if self.rect.y < self.start_y - 100:
            self.rect.y = self.start_y - 100
        if self.rect.y > self.start_y + 100:
            self.rect.y = self.start_y + 100


class Knight(Enemy):
    """Knight enemy - tough, shielded, aggressive"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'knight')
        self.shield_active = True
        self.charge_timer = 0
        self.charging = False
    
    def update_sprite(self):
        self.image = create_knight_sprite(self.facing_right, self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        if player:
            dx = player.rect.centerx - self.rect.centerx
            
            # Face player
            self.facing_right = dx > 0
            
            if abs(dx) < 250:
                # Aggressive pursuit
                self.charge_timer += 1
                
                if self.charge_timer >= 90:
                    # Charge attack
                    self.charging = True
                    self.charge_timer = 0
                
                if self.charging:
                    self.velocity_x = self.speed * 3 * (1 if self.facing_right else -1)
                    if abs(dx) < 30 or abs(dx) > 200:
                        self.charging = False
                else:
                    # Walk toward player
                    if abs(dx) > 40:
                        self.velocity_x = self.speed * (1 if dx > 0 else -1)
            else:
                # Patrol
                self.charge_timer = 0
                self.charging = False
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                    self.facing_right = False
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                    self.facing_right = True
                self.velocity_x = self.speed * self.direction
    
    def take_damage(self, amount):
        """Knights take reduced damage from front when shield is up"""
        if self.shield_active:
            # Shield blocks some damage
            amount = max(1, amount - 1)
        return super().take_damage(amount)


class Cannon(Enemy):
    """Boss enemy - the archenemy"""
    
    def __init__(self, x, y):
        # #region agent log
        import json; open('./.cursor/debug.log','a').write(json.dumps({"hypothesisId":"H-A","location":"enemies.py:Cannon.__init__:before_super","message":"About to call super().__init__","data":{"x":x,"y":y},"timestamp":__import__('time').time()})+'\n')
        # #endregion
        super().__init__(x, y, 'cannon')
        self.phase = 1
        self.attack_pattern = 0
        self.pattern_timer = 0
        self.projectiles = pygame.sprite.Group()
        self.arena_bounds = (x - 200, x + 200)
        
        # #region agent log
        import json; open('./.cursor/debug.log','a').write(json.dumps({"hypothesisId":"H-A","location":"enemies.py:Cannon.__init__:after_super","message":"Returned from super().__init__, now setting Cannon attrs","timestamp":__import__('time').time()})+'\n')
        # #endregion
        # Intro animation
        self.intro_active = True
        self.intro_timer = 0
        self.intro_duration = 180  # 3 seconds at 60fps
        self.intro_y_offset = -200  # Start above screen
        self.original_y = y
        
        # Phase transition
        self.phase_transition = False
        self.phase_transition_timer = 0
        self.last_phase = 1
    
    def update_sprite(self):
        # #region agent log
        import json; open('./.cursor/debug.log','a').write(json.dumps({"hypothesisId":"H-A","location":"enemies.py:Cannon.update_sprite:entry","message":"update_sprite called","data":{"has_phase_transition":hasattr(self,'phase_transition')},"timestamp":__import__('time').time()})+'\n')
        # #endregion
        # Flash during phase transition
        if self.phase_transition and self.frame % 4 < 2:
            self.image = pygame.Surface((48, 48), pygame.SRCALPHA)
            self.image.fill((*YELLOW[:3], 200))
        else:
            self.image = create_cannon_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Handle intro animation
        if self.intro_active:
            self.intro_timer += 1
            # Descend from above
            progress = min(1.0, self.intro_timer / (self.intro_duration * 0.6))
            # Ease out
            ease = 1 - (1 - progress) ** 3
            self.intro_y_offset = -200 * (1 - ease)
            self.rect.y = self.original_y + self.intro_y_offset
            
            if self.intro_timer >= self.intro_duration:
                self.intro_active = False
                self.intro_y_offset = 0
                self.rect.y = self.original_y
            return
        
        if not player:
            return
        
        # Handle phase transition animation
        if self.phase_transition:
            self.phase_transition_timer += 1
            if self.phase_transition_timer >= 60:
                self.phase_transition = False
                self.phase_transition_timer = 0
            return
        
        # Update phase based on health
        old_phase = self.phase
        if self.health <= self.max_health * 0.3:
            self.phase = 3
        elif self.health <= self.max_health * 0.5:
            self.phase = 2
        
        # Trigger phase transition animation
        if self.phase != old_phase:
            self.phase_transition = True
            self.phase_transition_timer = 0
            self.last_phase = self.phase
        
        dx = player.rect.centerx - self.rect.centerx
        self.facing_right = dx > 0
        
        self.pattern_timer += 1
        
        if self.phase == 1:
            self.phase1_ai(player)
        elif self.phase == 2:
            self.phase2_ai(player)
        else:
            self.phase3_ai(player)
    
    def phase1_ai(self, player):
        """Phase 1: Patrol and shoot"""
        # Move back and forth
        if self.rect.x > self.arena_bounds[1]:
            self.direction = -1
        elif self.rect.x < self.arena_bounds[0]:
            self.direction = 1
        
        self.velocity_x = self.speed * self.direction
        
        # Shoot periodically
        if self.pattern_timer >= 90:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase2_ai(self, player):
        """Phase 2: Jump attacks and spread shot"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive chase
        if abs(dx) > 80:
            self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Jump attack periodically
        if self.pattern_timer % 120 == 0 and self.pattern_timer > 0:
            self.velocity_y = -10  # Jump!
        
        # Spread shot - fires 3 cannon balls
        if self.pattern_timer >= 60:
            self.shoot_cannon_ball(player)
            # Shoot additional balls at angles
            self.shoot_spread_shot(player)
            self.pattern_timer = 0
    
    def shoot_spread_shot(self, player):
        """Fire spread of cannon balls"""
        # Upper shot
        ball1 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery - 100
        )
        # Lower shot
        ball2 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery + 100
        )
        self.projectiles.add(ball1)
        self.projectiles.add(ball2)
    
    def phase3_ai(self, player):
        """Phase 3: Enraged - fast and aggressive"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive pursuit
        self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Very rapid fire
        if self.pattern_timer >= 30:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def shoot_cannon_ball(self, player):
        """Fire a cannon ball at the player"""
        ball = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery
        )
        self.projectiles.add(ball)
    
    def update(self, player=None, tiles=None):
        super().update(player, tiles)
        self.projectiles.update()
    
    def draw(self, surface, camera_offset=(0, 0)):
        super().draw(surface, camera_offset)
        
        # Draw projectiles
        for ball in self.projectiles:
            ball.draw(surface, camera_offset)
        
        # Draw boss health bar at top of screen
        self.draw_boss_health_bar(surface)
    
    def draw_boss_health_bar(self, surface):
        """Draw large boss health bar at top"""
        bar_width = 500
        bar_height = 35
        x = SCREEN_WIDTH // 2 - bar_width // 2
        y = 55
        
        pygame.font.init()
        title_font = pygame.font.Font(None, 48)
        phase_font = pygame.font.Font(None, 32)
        
        # Draw intro text if in intro
        if self.intro_active:
            # Dramatic intro text
            if self.intro_timer > 30:
                intro_texts = ["THE ARCHENEMY", "CANNON", "APPEARS!"]
                text_idx = min(2, (self.intro_timer - 30) // 40)
                intro_text = title_font.render(intro_texts[text_idx], True, RED)
                intro_rect = intro_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
                
                # Flashing background
                if self.frame % 8 < 4:
                    pygame.draw.rect(surface, DARK_RED, 
                                   (intro_rect.x - 20, intro_rect.y - 10, 
                                    intro_rect.width + 40, intro_rect.height + 20))
                surface.blit(intro_text, intro_rect)
            return
        
        # Boss name header - large and prominent
        name_text = title_font.render("CANNON", True, YELLOW)
        name_rect = name_text.get_rect(center=(SCREEN_WIDTH // 2, 28))
        
        # Name background panel
        panel_rect = pygame.Rect(name_rect.x - 25, name_rect.y - 8, 
                                name_rect.width + 50, name_rect.height + 16)
        pygame.draw.rect(surface, DARK_BLUE, panel_rect)
        pygame.draw.rect(surface, DARK_RED, panel_rect, 3)
        pygame.draw.rect(surface, YELLOW, panel_rect.inflate(-6, -6), 2)
        surface.blit(name_text, name_rect)
        
        # Skull decorations on sides
        skull_left = title_font.render("☠", True, RED)
        skull_right = title_font.render("☠", True, RED)
        surface.blit(skull_left, (panel_rect.left - 30, name_rect.y - 2))
        surface.blit(skull_right, (panel_rect.right + 10, name_rect.y - 2))
        
        # Health bar outer frame
        frame_rect = pygame.Rect(x - 10, y - 10, bar_width + 20, bar_height + 20)
        pygame.draw.rect(surface, DARK_BLUE, frame_rect)
        pygame.draw.rect(surface, DARK_BROWN, frame_rect, 4)
        
        # Health bar inner background
        pygame.draw.rect(surface, BLACK, (x - 2, y - 2, bar_width + 4, bar_height + 4))
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health bar fill with gradient
        health_width = int(bar_width * (self.health / self.max_health))
        if health_width > 0:
            # Choose color based on phase
            if self.phase == 3:
                bar_color = MAGENTA
                highlight_color = PINK
            elif self.phase == 2:
                bar_color = ORANGE
                highlight_color = YELLOW
            else:
                bar_color = RED
                highlight_color = ORANGE
            
            # Main health bar
            pygame.draw.rect(surface, bar_color, (x, y, health_width, bar_height))
            # Top highlight
            pygame.draw.rect(surface, highlight_color, (x, y, health_width, bar_height // 4))
            # Bottom shadow
            pygame.draw.rect(surface, DARK_RED, (x, y + bar_height - 5, health_width, 5))
        
        # Golden border
        pygame.draw.rect(surface, YELLOW, (x - 4, y - 4, bar_width + 8, bar_height + 8), 3)
        
        # Phase indicator with dramatic styling
        if self.phase >= 2:
            phase_color = MAGENTA if self.phase == 3 else ORANGE
            phase_str = "⚡ PHASE 2 - ENRAGED ⚡" if self.phase == 2 else "💀 PHASE 3 - FINAL FORM 💀"
            phase_text = phase_font.render(phase_str, True, phase_color)
            phase_rect = phase_text.get_rect(center=(SCREEN_WIDTH // 2, y + bar_height + 18))
            
            # Flashing effect during transition
            if self.phase_transition and self.frame % 6 < 3:
                pygame.draw.rect(surface, phase_color, phase_rect.inflate(20, 10))
            surface.blit(phase_text, phase_rect)
        
        # Health percentage
        health_pct = int((self.health / self.max_health) * 100)
        pct_text = phase_font.render(f"{health_pct}%", True, WHITE)
        pct_rect = pct_text.get_rect(center=(x + bar_width // 2, y + bar_height // 2))
        surface.blit(pct_text, pct_rect)


class CannonBall(pygame.sprite.Sprite):
    """Projectile fired by Cannon boss"""
    
    def __init__(self, x, y, target_x, target_y):
        super().__init__()
        
        # Calculate direction
        dx = target_x - x
        dy = target_y - y
        dist = math.sqrt(dx * dx + dy * dy)
        
        self.speed = 5
        if dist > 0:
            self.velocity_x = (dx / dist) * self.speed
            self.velocity_y = (dy / dist) * self.speed
        else:
            self.velocity_x = self.speed
            self.velocity_y = 0
        
        self.damage = 2
        self.lifetime = 180
        
        # Create sprite
        self.image = pygame.Surface((16, 16), pygame.SRCALPHA)
        pygame.draw.circle(self.image, GRAY, (8, 8), 7)
        pygame.draw.circle(self.image, DARK_BROWN, (8, 8), 5)
        pygame.draw.circle(self.image, ORANGE, (6, 6), 2)
        
        self.rect = self.image.get_rect(center=(x, y))
    
    def update(self):
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


def create_enemy(enemy_type, x, y):
    """Factory function to create enemies"""
    if enemy_type == 'slime':
        return Slime(x, y)
    elif enemy_type == 'bat':
        return Bat(x, y)
    elif enemy_type == 'knight':
        return Knight(x, y)
    elif enemy_type == 'cannon':
        return Cannon(x, y)
    else:
        return Slime(x, y)  # Default

```

Good, the log file will be created fresh. Now please reproduce the crash.

<reproduction_steps>
1. Run `python main.py` in the terminal
2. Start a new game
3. Navigate to a boss level (or whichever level triggers the crash)
4. The crash should occur - note any error messages
</reproduction_steps>

---

**User**

Issue reproduced, please proceed.

---

**Cursor**

The terminal still shows the same crash from before. Let me check if there's a newer run, but more importantly, the traceback clearly confirms **Hypothesis H-A**:

## Analysis (from traceback evidence)

**H-A: CONFIRMED** - The traceback shows:
- Line 272: `super().__init__(x, y, 'cannon')` is called
- Line 44 (in Enemy.__init__): `self.update_sprite()` is called  
- Line 293 (in Cannon.update_sprite): Tries to access `self.phase_transition` → **CRASH**

The `phase_transition` attribute is defined AFTER the `super().__init__()` call returns, but `update_sprite()` is called DURING `super().__init__()`, before `phase_transition` exists.

## Fix

I'll add a guard in `update_sprite()` to check if the attribute exists before accessing it:

```python
"""
Enemy classes for Chain
"""

import pygame
import math
import random
from settings import *
from sprites import create_slime_sprite, create_bat_sprite, create_knight_sprite, create_cannon_sprite


class Enemy(pygame.sprite.Sprite):
    """Base enemy class"""
    
    def __init__(self, x, y, enemy_type):
        super().__init__()
        self.enemy_type = enemy_type
        self.stats = ENEMY_TYPES[enemy_type]
        
        self.max_health = self.stats['health']
        self.health = self.max_health
        self.damage = self.stats['damage']
        self.speed = self.stats['speed']
        self.score = self.stats['score']
        
        self.frame = 0
        self.facing_right = True
        
        # AI state
        self.state = 'patrol'
        self.patrol_distance = 100
        self.start_x = x
        self.direction = 1
        
        # Physics
        self.velocity_x = 0
        self.velocity_y = 0
        
        # Combat
        self.hurt_timer = 0
        self.attack_cooldown = 0
        
        # Create initial sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
    
    def update_sprite(self):
        """Override in subclasses"""
        pass
    
    def update(self, player=None, tiles=None):
        """Update enemy state"""
        self.frame += 1
        
        if self.hurt_timer > 0:
            self.hurt_timer -= 1
        
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        self.ai_update(player)
        self.physics_update(tiles)
        self.update_sprite()
    
    def ai_update(self, player):
        """AI behavior - override in subclasses"""
        pass
    
    def physics_update(self, tiles):
        """Apply physics"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:
            self.velocity_y = 15
        
        # Move
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def take_damage(self, amount):
        """Take damage"""
        self.health -= amount
        self.hurt_timer = 10
        
        if self.health <= 0:
            self.kill()
            return True  # Enemy died
        return False
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw enemy"""
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.hurt_timer > 0 and self.frame % 4 < 2:
            return
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw health bar for tough enemies
        if self.max_health > 2:
            self.draw_health_bar(surface, camera_offset)
    
    def draw_health_bar(self, surface, camera_offset):
        """Draw health bar above enemy"""
        bar_width = 30
        bar_height = 4
        
        x = self.rect.centerx - camera_offset[0] - bar_width // 2
        y = self.rect.top - camera_offset[1] - 8
        
        # Background
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health
        health_width = int(bar_width * (self.health / self.max_health))
        pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))


class Slime(Enemy):
    """Slime enemy - easy, hops around"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'slime')
        self.hop_timer = 0
    
    def update_sprite(self):
        self.image = create_slime_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Hop periodically
        self.hop_timer += 1
        if self.hop_timer >= 60:
            self.hop_timer = 0
            self.velocity_y = -6
            
            # Move toward player if nearby, otherwise patrol
            if player and abs(player.rect.centerx - self.rect.centerx) < 200:
                if player.rect.centerx < self.rect.centerx:
                    self.velocity_x = -self.speed * 2
                else:
                    self.velocity_x = self.speed * 2
            else:
                # Patrol
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                self.velocity_x = self.speed * self.direction


class Bat(Enemy):
    """Bat enemy - flying, erratic movement"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'bat')
        self.start_y = y
        self.angle = 0
        self.swoop_target = None
    
    def update_sprite(self):
        self.image = create_bat_sprite(self.frame)
    
    def ai_update(self, player):
        # Erratic flying pattern
        self.angle += 0.05
        
        if player and abs(player.rect.centerx - self.rect.centerx) < 150:
            # Swoop toward player
            dx = player.rect.centerx - self.rect.centerx
            dy = player.rect.centery - self.rect.centery
            dist = math.sqrt(dx * dx + dy * dy)
            
            if dist > 0:
                self.velocity_x = (dx / dist) * self.speed * 1.5
                self.velocity_y = (dy / dist) * self.speed * 1.5
        else:
            # Patrol pattern
            self.velocity_x = math.sin(self.angle) * self.speed
            self.velocity_y = math.cos(self.angle * 2) * self.speed * 0.5
        
        self.facing_right = self.velocity_x > 0
    
    def physics_update(self, tiles):
        # Bats don't use gravity
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Keep within bounds
        if self.rect.y < self.start_y - 100:
            self.rect.y = self.start_y - 100
        if self.rect.y > self.start_y + 100:
            self.rect.y = self.start_y + 100


class Knight(Enemy):
    """Knight enemy - tough, shielded, aggressive"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'knight')
        self.shield_active = True
        self.charge_timer = 0
        self.charging = False
    
    def update_sprite(self):
        self.image = create_knight_sprite(self.facing_right, self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        if player:
            dx = player.rect.centerx - self.rect.centerx
            
            # Face player
            self.facing_right = dx > 0
            
            if abs(dx) < 250:
                # Aggressive pursuit
                self.charge_timer += 1
                
                if self.charge_timer >= 90:
                    # Charge attack
                    self.charging = True
                    self.charge_timer = 0
                
                if self.charging:
                    self.velocity_x = self.speed * 3 * (1 if self.facing_right else -1)
                    if abs(dx) < 30 or abs(dx) > 200:
                        self.charging = False
                else:
                    # Walk toward player
                    if abs(dx) > 40:
                        self.velocity_x = self.speed * (1 if dx > 0 else -1)
            else:
                # Patrol
                self.charge_timer = 0
                self.charging = False
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                    self.facing_right = False
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                    self.facing_right = True
                self.velocity_x = self.speed * self.direction
    
    def take_damage(self, amount):
        """Knights take reduced damage from front when shield is up"""
        if self.shield_active:
            # Shield blocks some damage
            amount = max(1, amount - 1)
        return super().take_damage(amount)


class Cannon(Enemy):
    """Boss enemy - the archenemy"""
    
    def __init__(self, x, y):
        # #region agent log
        import json; open('./.cursor/debug.log','a').write(json.dumps({"hypothesisId":"H-A","location":"enemies.py:Cannon.__init__:before_super","message":"About to call super().__init__","data":{"x":x,"y":y},"timestamp":__import__('time').time()})+'\n')
        # #endregion
        super().__init__(x, y, 'cannon')
        self.phase = 1
        self.attack_pattern = 0
        self.pattern_timer = 0
        self.projectiles = pygame.sprite.Group()
        self.arena_bounds = (x - 200, x + 200)
        
        # #region agent log
        import json; open('./.cursor/debug.log','a').write(json.dumps({"hypothesisId":"H-A","location":"enemies.py:Cannon.__init__:after_super","message":"Returned from super().__init__, now setting Cannon attrs","timestamp":__import__('time').time()})+'\n')
        # #endregion
        # Intro animation
        self.intro_active = True
        self.intro_timer = 0
        self.intro_duration = 180  # 3 seconds at 60fps
        self.intro_y_offset = -200  # Start above screen
        self.original_y = y
        
        # Phase transition
        self.phase_transition = False
        self.phase_transition_timer = 0
        self.last_phase = 1
    
    def update_sprite(self):
        # #region agent log
        import json; open('./.cursor/debug.log','a').write(json.dumps({"hypothesisId":"H-A","location":"enemies.py:Cannon.update_sprite:entry","message":"update_sprite called","data":{"has_phase_transition":hasattr(self,'phase_transition')},"timestamp":__import__('time').time()})+'\n')
        # #endregion
        # Flash during phase transition (guard against early call during __init__)
        if getattr(self, 'phase_transition', False) and self.frame % 4 < 2:
            self.image = pygame.Surface((48, 48), pygame.SRCALPHA)
            self.image.fill((*YELLOW[:3], 200))
        else:
            self.image = create_cannon_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Handle intro animation
        if self.intro_active:
            self.intro_timer += 1
            # Descend from above
            progress = min(1.0, self.intro_timer / (self.intro_duration * 0.6))
            # Ease out
            ease = 1 - (1 - progress) ** 3
            self.intro_y_offset = -200 * (1 - ease)
            self.rect.y = self.original_y + self.intro_y_offset
            
            if self.intro_timer >= self.intro_duration:
                self.intro_active = False
                self.intro_y_offset = 0
                self.rect.y = self.original_y
            return
        
        if not player:
            return
        
        # Handle phase transition animation
        if self.phase_transition:
            self.phase_transition_timer += 1
            if self.phase_transition_timer >= 60:
                self.phase_transition = False
                self.phase_transition_timer = 0
            return
        
        # Update phase based on health
        old_phase = self.phase
        if self.health <= self.max_health * 0.3:
            self.phase = 3
        elif self.health <= self.max_health * 0.5:
            self.phase = 2
        
        # Trigger phase transition animation
        if self.phase != old_phase:
            self.phase_transition = True
            self.phase_transition_timer = 0
            self.last_phase = self.phase
        
        dx = player.rect.centerx - self.rect.centerx
        self.facing_right = dx > 0
        
        self.pattern_timer += 1
        
        if self.phase == 1:
            self.phase1_ai(player)
        elif self.phase == 2:
            self.phase2_ai(player)
        else:
            self.phase3_ai(player)
    
    def phase1_ai(self, player):
        """Phase 1: Patrol and shoot"""
        # Move back and forth
        if self.rect.x > self.arena_bounds[1]:
            self.direction = -1
        elif self.rect.x < self.arena_bounds[0]:
            self.direction = 1
        
        self.velocity_x = self.speed * self.direction
        
        # Shoot periodically
        if self.pattern_timer >= 90:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase2_ai(self, player):
        """Phase 2: Jump attacks and spread shot"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive chase
        if abs(dx) > 80:
            self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Jump attack periodically
        if self.pattern_timer % 120 == 0 and self.pattern_timer > 0:
            self.velocity_y = -10  # Jump!
        
        # Spread shot - fires 3 cannon balls
        if self.pattern_timer >= 60:
            self.shoot_cannon_ball(player)
            # Shoot additional balls at angles
            self.shoot_spread_shot(player)
            self.pattern_timer = 0
    
    def shoot_spread_shot(self, player):
        """Fire spread of cannon balls"""
        # Upper shot
        ball1 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery - 100
        )
        # Lower shot
        ball2 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery + 100
        )
        self.projectiles.add(ball1)
        self.projectiles.add(ball2)
    
    def phase3_ai(self, player):
        """Phase 3: Enraged - fast and aggressive"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive pursuit
        self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Very rapid fire
        if self.pattern_timer >= 30:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def shoot_cannon_ball(self, player):
        """Fire a cannon ball at the player"""
        ball = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery
        )
        self.projectiles.add(ball)
    
    def update(self, player=None, tiles=None):
        super().update(player, tiles)
        self.projectiles.update()
    
    def draw(self, surface, camera_offset=(0, 0)):
        super().draw(surface, camera_offset)
        
        # Draw projectiles
        for ball in self.projectiles:
            ball.draw(surface, camera_offset)
        
        # Draw boss health bar at top of screen
        self.draw_boss_health_bar(surface)
    
    def draw_boss_health_bar(self, surface):
        """Draw large boss health bar at top"""
        bar_width = 500
        bar_height = 35
        x = SCREEN_WIDTH // 2 - bar_width // 2
        y = 55
        
        pygame.font.init()
        title_font = pygame.font.Font(None, 48)
        phase_font = pygame.font.Font(None, 32)
        
        # Draw intro text if in intro
        if self.intro_active:
            # Dramatic intro text
            if self.intro_timer > 30:
                intro_texts = ["THE ARCHENEMY", "CANNON", "APPEARS!"]
                text_idx = min(2, (self.intro_timer - 30) // 40)
                intro_text = title_font.render(intro_texts[text_idx], True, RED)
                intro_rect = intro_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
                
                # Flashing background
                if self.frame % 8 < 4:
                    pygame.draw.rect(surface, DARK_RED, 
                                   (intro_rect.x - 20, intro_rect.y - 10, 
                                    intro_rect.width + 40, intro_rect.height + 20))
                surface.blit(intro_text, intro_rect)
            return
        
        # Boss name header - large and prominent
        name_text = title_font.render("CANNON", True, YELLOW)
        name_rect = name_text.get_rect(center=(SCREEN_WIDTH // 2, 28))
        
        # Name background panel
        panel_rect = pygame.Rect(name_rect.x - 25, name_rect.y - 8, 
                                name_rect.width + 50, name_rect.height + 16)
        pygame.draw.rect(surface, DARK_BLUE, panel_rect)
        pygame.draw.rect(surface, DARK_RED, panel_rect, 3)
        pygame.draw.rect(surface, YELLOW, panel_rect.inflate(-6, -6), 2)
        surface.blit(name_text, name_rect)
        
        # Skull decorations on sides
        skull_left = title_font.render("☠", True, RED)
        skull_right = title_font.render("☠", True, RED)
        surface.blit(skull_left, (panel_rect.left - 30, name_rect.y - 2))
        surface.blit(skull_right, (panel_rect.right + 10, name_rect.y - 2))
        
        # Health bar outer frame
        frame_rect = pygame.Rect(x - 10, y - 10, bar_width + 20, bar_height + 20)
        pygame.draw.rect(surface, DARK_BLUE, frame_rect)
        pygame.draw.rect(surface, DARK_BROWN, frame_rect, 4)
        
        # Health bar inner background
        pygame.draw.rect(surface, BLACK, (x - 2, y - 2, bar_width + 4, bar_height + 4))
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health bar fill with gradient
        health_width = int(bar_width * (self.health / self.max_health))
        if health_width > 0:
            # Choose color based on phase
            if self.phase == 3:
                bar_color = MAGENTA
                highlight_color = PINK
            elif self.phase == 2:
                bar_color = ORANGE
                highlight_color = YELLOW
            else:
                bar_color = RED
                highlight_color = ORANGE
            
            # Main health bar
            pygame.draw.rect(surface, bar_color, (x, y, health_width, bar_height))
            # Top highlight
            pygame.draw.rect(surface, highlight_color, (x, y, health_width, bar_height // 4))
            # Bottom shadow
            pygame.draw.rect(surface, DARK_RED, (x, y + bar_height - 5, health_width, 5))
        
        # Golden border
        pygame.draw.rect(surface, YELLOW, (x - 4, y - 4, bar_width + 8, bar_height + 8), 3)
        
        # Phase indicator with dramatic styling
        if self.phase >= 2:
            phase_color = MAGENTA if self.phase == 3 else ORANGE
            phase_str = "⚡ PHASE 2 - ENRAGED ⚡" if self.phase == 2 else "💀 PHASE 3 - FINAL FORM 💀"
            phase_text = phase_font.render(phase_str, True, phase_color)
            phase_rect = phase_text.get_rect(center=(SCREEN_WIDTH // 2, y + bar_height + 18))
            
            # Flashing effect during transition
            if self.phase_transition and self.frame % 6 < 3:
                pygame.draw.rect(surface, phase_color, phase_rect.inflate(20, 10))
            surface.blit(phase_text, phase_rect)
        
        # Health percentage
        health_pct = int((self.health / self.max_health) * 100)
        pct_text = phase_font.render(f"{health_pct}%", True, WHITE)
        pct_rect = pct_text.get_rect(center=(x + bar_width // 2, y + bar_height // 2))
        surface.blit(pct_text, pct_rect)


class CannonBall(pygame.sprite.Sprite):
    """Projectile fired by Cannon boss"""
    
    def __init__(self, x, y, target_x, target_y):
        super().__init__()
        
        # Calculate direction
        dx = target_x - x
        dy = target_y - y
        dist = math.sqrt(dx * dx + dy * dy)
        
        self.speed = 5
        if dist > 0:
            self.velocity_x = (dx / dist) * self.speed
            self.velocity_y = (dy / dist) * self.speed
        else:
            self.velocity_x = self.speed
            self.velocity_y = 0
        
        self.damage = 2
        self.lifetime = 180
        
        # Create sprite
        self.image = pygame.Surface((16, 16), pygame.SRCALPHA)
        pygame.draw.circle(self.image, GRAY, (8, 8), 7)
        pygame.draw.circle(self.image, DARK_BROWN, (8, 8), 5)
        pygame.draw.circle(self.image, ORANGE, (6, 6), 2)
        
        self.rect = self.image.get_rect(center=(x, y))
    
    def update(self):
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


def create_enemy(enemy_type, x, y):
    """Factory function to create enemies"""
    if enemy_type == 'slime':
        return Slime(x, y)
    elif enemy_type == 'bat':
        return Bat(x, y)
    elif enemy_type == 'knight':
        return Knight(x, y)
    elif enemy_type == 'cannon':
        return Cannon(x, y)
    else:
        return Slime(x, y)  # Default

```

I've applied the fix by using `getattr(self, 'phase_transition', False)` instead of directly accessing `self.phase_transition`. This safely returns `False` if the attribute doesn't exist yet during early initialization.

Please verify the fix works:

<reproduction_steps>
1. Run `python main.py` in the terminal
2. Start a new game
3. Navigate to the boss level (Cannon's Throne)
4. The game should now load without crashing
5. Confirm Cannon appears with his intro animation
</reproduction_steps>

---

**User**

Issue reproduced, please proceed.

---

**Cursor**

The terminal file may not have updated. Let me verify my fix is actually in the file:

Good - I can see my fix is in the code at line 302. The terminal output shows the old crash from before my fix. Let me also verify the `.cursor` directory exists so logs can be written:

The `.cursor` directory exists. The fix is in place - I changed line 302 from:
```python
if self.phase_transition and self.frame % 4 < 2:
```
to:
```python
if getattr(self, 'phase_transition', False) and self.frame % 4 < 2:
```

Please run the game again to verify the fix works:

<reproduction_steps>
1. Run `python main.py` in the terminal (make sure the game window from any previous run is closed first)
2. Start a new game by selecting "New Game"
3. Navigate to the boss level marker (Cannon's Throne) on the world map
4. Press Enter to enter the level
5. Confirm whether the game crashes or Cannon appears successfully with his intro animation
</reproduction_steps>

```python
if self.phase_transition and self.frame % 4 < 2:
```

```python
if getattr(self, 'phase_transition', False) and self.frame % 4 < 2:
```

---

**User**

Let's make it so that each subsequent sidescroll adventure can be skipped in terms of completion by typing c

---

**Cursor**

The user moving on to a new feature request suggests the crash fix worked. Let me remove the debug instrumentation and implement the level skip feature.

```python
    def __init__(self, x, y):
        super().__init__(x, y, 'cannon')
```

```python
"""
Enemy classes for Chain
"""

import pygame
import math
import random
from settings import *
from sprites import create_slime_sprite, create_bat_sprite, create_knight_sprite, create_cannon_sprite


class Enemy(pygame.sprite.Sprite):
    """Base enemy class"""
    
    def __init__(self, x, y, enemy_type):
        super().__init__()
        self.enemy_type = enemy_type
        self.stats = ENEMY_TYPES[enemy_type]
        
        self.max_health = self.stats['health']
        self.health = self.max_health
        self.damage = self.stats['damage']
        self.speed = self.stats['speed']
        self.score = self.stats['score']
        
        self.frame = 0
        self.facing_right = True
        
        # AI state
        self.state = 'patrol'
        self.patrol_distance = 100
        self.start_x = x
        self.direction = 1
        
        # Physics
        self.velocity_x = 0
        self.velocity_y = 0
        
        # Combat
        self.hurt_timer = 0
        self.attack_cooldown = 0
        
        # Create initial sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
    
    def update_sprite(self):
        """Override in subclasses"""
        pass
    
    def update(self, player=None, tiles=None):
        """Update enemy state"""
        self.frame += 1
        
        if self.hurt_timer > 0:
            self.hurt_timer -= 1
        
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        self.ai_update(player)
        self.physics_update(tiles)
        self.update_sprite()
    
    def ai_update(self, player):
        """AI behavior - override in subclasses"""
        pass
    
    def physics_update(self, tiles):
        """Apply physics"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:
            self.velocity_y = 15
        
        # Move
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def take_damage(self, amount):
        """Take damage"""
        self.health -= amount
        self.hurt_timer = 10
        
        if self.health <= 0:
            self.kill()
            return True  # Enemy died
        return False
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw enemy"""
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.hurt_timer > 0 and self.frame % 4 < 2:
            return
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw health bar for tough enemies
        if self.max_health > 2:
            self.draw_health_bar(surface, camera_offset)
    
    def draw_health_bar(self, surface, camera_offset):
        """Draw health bar above enemy"""
        bar_width = 30
        bar_height = 4
        
        x = self.rect.centerx - camera_offset[0] - bar_width // 2
        y = self.rect.top - camera_offset[1] - 8
        
        # Background
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health
        health_width = int(bar_width * (self.health / self.max_health))
        pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))


class Slime(Enemy):
    """Slime enemy - easy, hops around"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'slime')
        self.hop_timer = 0
    
    def update_sprite(self):
        self.image = create_slime_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Hop periodically
        self.hop_timer += 1
        if self.hop_timer >= 60:
            self.hop_timer = 0
            self.velocity_y = -6
            
            # Move toward player if nearby, otherwise patrol
            if player and abs(player.rect.centerx - self.rect.centerx) < 200:
                if player.rect.centerx < self.rect.centerx:
                    self.velocity_x = -self.speed * 2
                else:
                    self.velocity_x = self.speed * 2
            else:
                # Patrol
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                self.velocity_x = self.speed * self.direction


class Bat(Enemy):
    """Bat enemy - flying, erratic movement"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'bat')
        self.start_y = y
        self.angle = 0
        self.swoop_target = None
    
    def update_sprite(self):
        self.image = create_bat_sprite(self.frame)
    
    def ai_update(self, player):
        # Erratic flying pattern
        self.angle += 0.05
        
        if player and abs(player.rect.centerx - self.rect.centerx) < 150:
            # Swoop toward player
            dx = player.rect.centerx - self.rect.centerx
            dy = player.rect.centery - self.rect.centery
            dist = math.sqrt(dx * dx + dy * dy)
            
            if dist > 0:
                self.velocity_x = (dx / dist) * self.speed * 1.5
                self.velocity_y = (dy / dist) * self.speed * 1.5
        else:
            # Patrol pattern
            self.velocity_x = math.sin(self.angle) * self.speed
            self.velocity_y = math.cos(self.angle * 2) * self.speed * 0.5
        
        self.facing_right = self.velocity_x > 0
    
    def physics_update(self, tiles):
        # Bats don't use gravity
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Keep within bounds
        if self.rect.y < self.start_y - 100:
            self.rect.y = self.start_y - 100
        if self.rect.y > self.start_y + 100:
            self.rect.y = self.start_y + 100


class Knight(Enemy):
    """Knight enemy - tough, shielded, aggressive"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'knight')
        self.shield_active = True
        self.charge_timer = 0
        self.charging = False
    
    def update_sprite(self):
        self.image = create_knight_sprite(self.facing_right, self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        if player:
            dx = player.rect.centerx - self.rect.centerx
            
            # Face player
            self.facing_right = dx > 0
            
            if abs(dx) < 250:
                # Aggressive pursuit
                self.charge_timer += 1
                
                if self.charge_timer >= 90:
                    # Charge attack
                    self.charging = True
                    self.charge_timer = 0
                
                if self.charging:
                    self.velocity_x = self.speed * 3 * (1 if self.facing_right else -1)
                    if abs(dx) < 30 or abs(dx) > 200:
                        self.charging = False
                else:
                    # Walk toward player
                    if abs(dx) > 40:
                        self.velocity_x = self.speed * (1 if dx > 0 else -1)
            else:
                # Patrol
                self.charge_timer = 0
                self.charging = False
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                    self.facing_right = False
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                    self.facing_right = True
                self.velocity_x = self.speed * self.direction
    
    def take_damage(self, amount):
        """Knights take reduced damage from front when shield is up"""
        if self.shield_active:
            # Shield blocks some damage
            amount = max(1, amount - 1)
        return super().take_damage(amount)


class Cannon(Enemy):
    """Boss enemy - the archenemy"""
    
    def __init__(self, x, y):
        # #region agent log
        import json; open('./.cursor/debug.log','a').write(json.dumps({"hypothesisId":"H-A","location":"enemies.py:Cannon.__init__:before_super","message":"About to call super().__init__","data":{"x":x,"y":y},"timestamp":__import__('time').time()})+'\n')
        # #endregion
        super().__init__(x, y, 'cannon')
        self.phase = 1
        self.attack_pattern = 0
        self.pattern_timer = 0
        self.projectiles = pygame.sprite.Group()
        self.arena_bounds = (x - 200, x + 200)
        
        # #region agent log
        import json; open('./.cursor/debug.log','a').write(json.dumps({"hypothesisId":"H-A","location":"enemies.py:Cannon.__init__:after_super","message":"Returned from super().__init__, now setting Cannon attrs","timestamp":__import__('time').time()})+'\n')
        # #endregion
        # Intro animation
        self.intro_active = True
        self.intro_timer = 0
        self.intro_duration = 180  # 3 seconds at 60fps
        self.intro_y_offset = -200  # Start above screen
        self.original_y = y
        
        # Phase transition
        self.phase_transition = False
        self.phase_transition_timer = 0
        self.last_phase = 1
    
    def update_sprite(self):
        # Flash during phase transition (guard against early call during __init__)
        if getattr(self, 'phase_transition', False) and self.frame % 4 < 2:
            self.image = pygame.Surface((48, 48), pygame.SRCALPHA)
            self.image.fill((*YELLOW[:3], 200))
        else:
            self.image = create_cannon_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Handle intro animation
        if self.intro_active:
            self.intro_timer += 1
            # Descend from above
            progress = min(1.0, self.intro_timer / (self.intro_duration * 0.6))
            # Ease out
            ease = 1 - (1 - progress) ** 3
            self.intro_y_offset = -200 * (1 - ease)
            self.rect.y = self.original_y + self.intro_y_offset
            
            if self.intro_timer >= self.intro_duration:
                self.intro_active = False
                self.intro_y_offset = 0
                self.rect.y = self.original_y
            return
        
        if not player:
            return
        
        # Handle phase transition animation
        if self.phase_transition:
            self.phase_transition_timer += 1
            if self.phase_transition_timer >= 60:
                self.phase_transition = False
                self.phase_transition_timer = 0
            return
        
        # Update phase based on health
        old_phase = self.phase
        if self.health <= self.max_health * 0.3:
            self.phase = 3
        elif self.health <= self.max_health * 0.5:
            self.phase = 2
        
        # Trigger phase transition animation
        if self.phase != old_phase:
            self.phase_transition = True
            self.phase_transition_timer = 0
            self.last_phase = self.phase
        
        dx = player.rect.centerx - self.rect.centerx
        self.facing_right = dx > 0
        
        self.pattern_timer += 1
        
        if self.phase == 1:
            self.phase1_ai(player)
        elif self.phase == 2:
            self.phase2_ai(player)
        else:
            self.phase3_ai(player)
    
    def phase1_ai(self, player):
        """Phase 1: Patrol and shoot"""
        # Move back and forth
        if self.rect.x > self.arena_bounds[1]:
            self.direction = -1
        elif self.rect.x < self.arena_bounds[0]:
            self.direction = 1
        
        self.velocity_x = self.speed * self.direction
        
        # Shoot periodically
        if self.pattern_timer >= 90:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase2_ai(self, player):
        """Phase 2: Jump attacks and spread shot"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive chase
        if abs(dx) > 80:
            self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Jump attack periodically
        if self.pattern_timer % 120 == 0 and self.pattern_timer > 0:
            self.velocity_y = -10  # Jump!
        
        # Spread shot - fires 3 cannon balls
        if self.pattern_timer >= 60:
            self.shoot_cannon_ball(player)
            # Shoot additional balls at angles
            self.shoot_spread_shot(player)
            self.pattern_timer = 0
    
    def shoot_spread_shot(self, player):
        """Fire spread of cannon balls"""
        # Upper shot
        ball1 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery - 100
        )
        # Lower shot
        ball2 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery + 100
        )
        self.projectiles.add(ball1)
        self.projectiles.add(ball2)
    
    def phase3_ai(self, player):
        """Phase 3: Enraged - fast and aggressive"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive pursuit
        self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Very rapid fire
        if self.pattern_timer >= 30:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def shoot_cannon_ball(self, player):
        """Fire a cannon ball at the player"""
        ball = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery
        )
        self.projectiles.add(ball)
    
    def update(self, player=None, tiles=None):
        super().update(player, tiles)
        self.projectiles.update()
    
    def draw(self, surface, camera_offset=(0, 0)):
        super().draw(surface, camera_offset)
        
        # Draw projectiles
        for ball in self.projectiles:
            ball.draw(surface, camera_offset)
        
        # Draw boss health bar at top of screen
        self.draw_boss_health_bar(surface)
    
    def draw_boss_health_bar(self, surface):
        """Draw large boss health bar at top"""
        bar_width = 500
        bar_height = 35
        x = SCREEN_WIDTH // 2 - bar_width // 2
        y = 55
        
        pygame.font.init()
        title_font = pygame.font.Font(None, 48)
        phase_font = pygame.font.Font(None, 32)
        
        # Draw intro text if in intro
        if self.intro_active:
            # Dramatic intro text
            if self.intro_timer > 30:
                intro_texts = ["THE ARCHENEMY", "CANNON", "APPEARS!"]
                text_idx = min(2, (self.intro_timer - 30) // 40)
                intro_text = title_font.render(intro_texts[text_idx], True, RED)
                intro_rect = intro_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
                
                # Flashing background
                if self.frame % 8 < 4:
                    pygame.draw.rect(surface, DARK_RED, 
                                   (intro_rect.x - 20, intro_rect.y - 10, 
                                    intro_rect.width + 40, intro_rect.height + 20))
                surface.blit(intro_text, intro_rect)
            return
        
        # Boss name header - large and prominent
        name_text = title_font.render("CANNON", True, YELLOW)
        name_rect = name_text.get_rect(center=(SCREEN_WIDTH // 2, 28))
        
        # Name background panel
        panel_rect = pygame.Rect(name_rect.x - 25, name_rect.y - 8, 
                                name_rect.width + 50, name_rect.height + 16)
        pygame.draw.rect(surface, DARK_BLUE, panel_rect)
        pygame.draw.rect(surface, DARK_RED, panel_rect, 3)
        pygame.draw.rect(surface, YELLOW, panel_rect.inflate(-6, -6), 2)
        surface.blit(name_text, name_rect)
        
        # Skull decorations on sides
        skull_left = title_font.render("☠", True, RED)
        skull_right = title_font.render("☠", True, RED)
        surface.blit(skull_left, (panel_rect.left - 30, name_rect.y - 2))
        surface.blit(skull_right, (panel_rect.right + 10, name_rect.y - 2))
        
        # Health bar outer frame
        frame_rect = pygame.Rect(x - 10, y - 10, bar_width + 20, bar_height + 20)
        pygame.draw.rect(surface, DARK_BLUE, frame_rect)
        pygame.draw.rect(surface, DARK_BROWN, frame_rect, 4)
        
        # Health bar inner background
        pygame.draw.rect(surface, BLACK, (x - 2, y - 2, bar_width + 4, bar_height + 4))
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health bar fill with gradient
        health_width = int(bar_width * (self.health / self.max_health))
        if health_width > 0:
            # Choose color based on phase
            if self.phase == 3:
                bar_color = MAGENTA
                highlight_color = PINK
            elif self.phase == 2:
                bar_color = ORANGE
                highlight_color = YELLOW
            else:
                bar_color = RED
                highlight_color = ORANGE
            
            # Main health bar
            pygame.draw.rect(surface, bar_color, (x, y, health_width, bar_height))
            # Top highlight
            pygame.draw.rect(surface, highlight_color, (x, y, health_width, bar_height // 4))
            # Bottom shadow
            pygame.draw.rect(surface, DARK_RED, (x, y + bar_height - 5, health_width, 5))
        
        # Golden border
        pygame.draw.rect(surface, YELLOW, (x - 4, y - 4, bar_width + 8, bar_height + 8), 3)
        
        # Phase indicator with dramatic styling
        if self.phase >= 2:
            phase_color = MAGENTA if self.phase == 3 else ORANGE
            phase_str = "⚡ PHASE 2 - ENRAGED ⚡" if self.phase == 2 else "💀 PHASE 3 - FINAL FORM 💀"
            phase_text = phase_font.render(phase_str, True, phase_color)
            phase_rect = phase_text.get_rect(center=(SCREEN_WIDTH // 2, y + bar_height + 18))
            
            # Flashing effect during transition
            if self.phase_transition and self.frame % 6 < 3:
                pygame.draw.rect(surface, phase_color, phase_rect.inflate(20, 10))
            surface.blit(phase_text, phase_rect)
        
        # Health percentage
        health_pct = int((self.health / self.max_health) * 100)
        pct_text = phase_font.render(f"{health_pct}%", True, WHITE)
        pct_rect = pct_text.get_rect(center=(x + bar_width // 2, y + bar_height // 2))
        surface.blit(pct_text, pct_rect)


class CannonBall(pygame.sprite.Sprite):
    """Projectile fired by Cannon boss"""
    
    def __init__(self, x, y, target_x, target_y):
        super().__init__()
        
        # Calculate direction
        dx = target_x - x
        dy = target_y - y
        dist = math.sqrt(dx * dx + dy * dy)
        
        self.speed = 5
        if dist > 0:
            self.velocity_x = (dx / dist) * self.speed
            self.velocity_y = (dy / dist) * self.speed
        else:
            self.velocity_x = self.speed
            self.velocity_y = 0
        
        self.damage = 2
        self.lifetime = 180
        
        # Create sprite
        self.image = pygame.Surface((16, 16), pygame.SRCALPHA)
        pygame.draw.circle(self.image, GRAY, (8, 8), 7)
        pygame.draw.circle(self.image, DARK_BROWN, (8, 8), 5)
        pygame.draw.circle(self.image, ORANGE, (6, 6), 2)
        
        self.rect = self.image.get_rect(center=(x, y))
    
    def update(self):
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


def create_enemy(enemy_type, x, y):
    """Factory function to create enemies"""
    if enemy_type == 'slime':
        return Slime(x, y)
    elif enemy_type == 'bat':
        return Bat(x, y)
    elif enemy_type == 'knight':
        return Knight(x, y)
    elif enemy_type == 'cannon':
        return Cannon(x, y)
    else:
        return Slime(x, y)  # Default

```

```python
"""
Enemy classes for Chain
"""

import pygame
import math
import random
from settings import *
from sprites import create_slime_sprite, create_bat_sprite, create_knight_sprite, create_cannon_sprite


class Enemy(pygame.sprite.Sprite):
    """Base enemy class"""
    
    def __init__(self, x, y, enemy_type):
        super().__init__()
        self.enemy_type = enemy_type
        self.stats = ENEMY_TYPES[enemy_type]
        
        self.max_health = self.stats['health']
        self.health = self.max_health
        self.damage = self.stats['damage']
        self.speed = self.stats['speed']
        self.score = self.stats['score']
        
        self.frame = 0
        self.facing_right = True
        
        # AI state
        self.state = 'patrol'
        self.patrol_distance = 100
        self.start_x = x
        self.direction = 1
        
        # Physics
        self.velocity_x = 0
        self.velocity_y = 0
        
        # Combat
        self.hurt_timer = 0
        self.attack_cooldown = 0
        
        # Create initial sprite
        self.update_sprite()
        self.rect = self.image.get_rect(topleft=(x, y))
    
    def update_sprite(self):
        """Override in subclasses"""
        pass
    
    def update(self, player=None, tiles=None):
        """Update enemy state"""
        self.frame += 1
        
        if self.hurt_timer > 0:
            self.hurt_timer -= 1
        
        if self.attack_cooldown > 0:
            self.attack_cooldown -= 1
        
        self.ai_update(player)
        self.physics_update(tiles)
        self.update_sprite()
    
    def ai_update(self, player):
        """AI behavior - override in subclasses"""
        pass
    
    def physics_update(self, tiles):
        """Apply physics"""
        # Apply gravity
        self.velocity_y += PLAYER_GRAVITY
        if self.velocity_y > 15:
            self.velocity_y = 15
        
        # Move
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Check tile collisions
        if tiles:
            for tile in tiles:
                if self.rect.colliderect(tile.rect):
                    if self.velocity_y > 0:
                        self.rect.bottom = tile.rect.top
                        self.velocity_y = 0
                    elif self.velocity_y < 0:
                        self.rect.top = tile.rect.bottom
                        self.velocity_y = 0
    
    def take_damage(self, amount):
        """Take damage"""
        self.health -= amount
        self.hurt_timer = 10
        
        if self.health <= 0:
            self.kill()
            return True  # Enemy died
        return False
    
    def draw(self, surface, camera_offset=(0, 0)):
        """Draw enemy"""
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        
        # Flash when hurt
        if self.hurt_timer > 0 and self.frame % 4 < 2:
            return
        
        surface.blit(self.image, (draw_x, draw_y))
        
        # Draw health bar for tough enemies
        if self.max_health > 2:
            self.draw_health_bar(surface, camera_offset)
    
    def draw_health_bar(self, surface, camera_offset):
        """Draw health bar above enemy"""
        bar_width = 30
        bar_height = 4
        
        x = self.rect.centerx - camera_offset[0] - bar_width // 2
        y = self.rect.top - camera_offset[1] - 8
        
        # Background
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health
        health_width = int(bar_width * (self.health / self.max_health))
        pygame.draw.rect(surface, RED, (x, y, health_width, bar_height))


class Slime(Enemy):
    """Slime enemy - easy, hops around"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'slime')
        self.hop_timer = 0
    
    def update_sprite(self):
        self.image = create_slime_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Hop periodically
        self.hop_timer += 1
        if self.hop_timer >= 60:
            self.hop_timer = 0
            self.velocity_y = -6
            
            # Move toward player if nearby, otherwise patrol
            if player and abs(player.rect.centerx - self.rect.centerx) < 200:
                if player.rect.centerx < self.rect.centerx:
                    self.velocity_x = -self.speed * 2
                else:
                    self.velocity_x = self.speed * 2
            else:
                # Patrol
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                self.velocity_x = self.speed * self.direction


class Bat(Enemy):
    """Bat enemy - flying, erratic movement"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'bat')
        self.start_y = y
        self.angle = 0
        self.swoop_target = None
    
    def update_sprite(self):
        self.image = create_bat_sprite(self.frame)
    
    def ai_update(self, player):
        # Erratic flying pattern
        self.angle += 0.05
        
        if player and abs(player.rect.centerx - self.rect.centerx) < 150:
            # Swoop toward player
            dx = player.rect.centerx - self.rect.centerx
            dy = player.rect.centery - self.rect.centery
            dist = math.sqrt(dx * dx + dy * dy)
            
            if dist > 0:
                self.velocity_x = (dx / dist) * self.speed * 1.5
                self.velocity_y = (dy / dist) * self.speed * 1.5
        else:
            # Patrol pattern
            self.velocity_x = math.sin(self.angle) * self.speed
            self.velocity_y = math.cos(self.angle * 2) * self.speed * 0.5
        
        self.facing_right = self.velocity_x > 0
    
    def physics_update(self, tiles):
        # Bats don't use gravity
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        
        # Keep within bounds
        if self.rect.y < self.start_y - 100:
            self.rect.y = self.start_y - 100
        if self.rect.y > self.start_y + 100:
            self.rect.y = self.start_y + 100


class Knight(Enemy):
    """Knight enemy - tough, shielded, aggressive"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'knight')
        self.shield_active = True
        self.charge_timer = 0
        self.charging = False
    
    def update_sprite(self):
        self.image = create_knight_sprite(self.facing_right, self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        if player:
            dx = player.rect.centerx - self.rect.centerx
            
            # Face player
            self.facing_right = dx > 0
            
            if abs(dx) < 250:
                # Aggressive pursuit
                self.charge_timer += 1
                
                if self.charge_timer >= 90:
                    # Charge attack
                    self.charging = True
                    self.charge_timer = 0
                
                if self.charging:
                    self.velocity_x = self.speed * 3 * (1 if self.facing_right else -1)
                    if abs(dx) < 30 or abs(dx) > 200:
                        self.charging = False
                else:
                    # Walk toward player
                    if abs(dx) > 40:
                        self.velocity_x = self.speed * (1 if dx > 0 else -1)
            else:
                # Patrol
                self.charge_timer = 0
                self.charging = False
                if self.rect.x > self.start_x + self.patrol_distance:
                    self.direction = -1
                    self.facing_right = False
                elif self.rect.x < self.start_x - self.patrol_distance:
                    self.direction = 1
                    self.facing_right = True
                self.velocity_x = self.speed * self.direction
    
    def take_damage(self, amount):
        """Knights take reduced damage from front when shield is up"""
        if self.shield_active:
            # Shield blocks some damage
            amount = max(1, amount - 1)
        return super().take_damage(amount)


class Cannon(Enemy):
    """Boss enemy - the archenemy"""
    
    def __init__(self, x, y):
        super().__init__(x, y, 'cannon')
        self.phase = 1
        self.attack_pattern = 0
        self.pattern_timer = 0
        self.projectiles = pygame.sprite.Group()
        self.arena_bounds = (x - 200, x + 200)
        
        # Intro animation
        self.intro_active = True
        self.intro_timer = 0
        self.intro_duration = 180  # 3 seconds at 60fps
        self.intro_y_offset = -200  # Start above screen
        self.original_y = y
        
        # Phase transition
        self.phase_transition = False
        self.phase_transition_timer = 0
        self.last_phase = 1
    
    def update_sprite(self):
        # Flash during phase transition (guard against early call during __init__)
        if getattr(self, 'phase_transition', False) and self.frame % 4 < 2:
            self.image = pygame.Surface((48, 48), pygame.SRCALPHA)
            self.image.fill((*YELLOW[:3], 200))
        else:
            self.image = create_cannon_sprite(self.frame)
    
    def ai_update(self, player):
        self.velocity_x = 0
        
        # Handle intro animation
        if self.intro_active:
            self.intro_timer += 1
            # Descend from above
            progress = min(1.0, self.intro_timer / (self.intro_duration * 0.6))
            # Ease out
            ease = 1 - (1 - progress) ** 3
            self.intro_y_offset = -200 * (1 - ease)
            self.rect.y = self.original_y + self.intro_y_offset
            
            if self.intro_timer >= self.intro_duration:
                self.intro_active = False
                self.intro_y_offset = 0
                self.rect.y = self.original_y
            return
        
        if not player:
            return
        
        # Handle phase transition animation
        if self.phase_transition:
            self.phase_transition_timer += 1
            if self.phase_transition_timer >= 60:
                self.phase_transition = False
                self.phase_transition_timer = 0
            return
        
        # Update phase based on health
        old_phase = self.phase
        if self.health <= self.max_health * 0.3:
            self.phase = 3
        elif self.health <= self.max_health * 0.5:
            self.phase = 2
        
        # Trigger phase transition animation
        if self.phase != old_phase:
            self.phase_transition = True
            self.phase_transition_timer = 0
            self.last_phase = self.phase
        
        dx = player.rect.centerx - self.rect.centerx
        self.facing_right = dx > 0
        
        self.pattern_timer += 1
        
        if self.phase == 1:
            self.phase1_ai(player)
        elif self.phase == 2:
            self.phase2_ai(player)
        else:
            self.phase3_ai(player)
    
    def phase1_ai(self, player):
        """Phase 1: Patrol and shoot"""
        # Move back and forth
        if self.rect.x > self.arena_bounds[1]:
            self.direction = -1
        elif self.rect.x < self.arena_bounds[0]:
            self.direction = 1
        
        self.velocity_x = self.speed * self.direction
        
        # Shoot periodically
        if self.pattern_timer >= 90:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def phase2_ai(self, player):
        """Phase 2: Jump attacks and spread shot"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive chase
        if abs(dx) > 80:
            self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Jump attack periodically
        if self.pattern_timer % 120 == 0 and self.pattern_timer > 0:
            self.velocity_y = -10  # Jump!
        
        # Spread shot - fires 3 cannon balls
        if self.pattern_timer >= 60:
            self.shoot_cannon_ball(player)
            # Shoot additional balls at angles
            self.shoot_spread_shot(player)
            self.pattern_timer = 0
    
    def shoot_spread_shot(self, player):
        """Fire spread of cannon balls"""
        # Upper shot
        ball1 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery - 100
        )
        # Lower shot
        ball2 = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery + 100
        )
        self.projectiles.add(ball1)
        self.projectiles.add(ball2)
    
    def phase3_ai(self, player):
        """Phase 3: Enraged - fast and aggressive"""
        dx = player.rect.centerx - self.rect.centerx
        
        # Aggressive pursuit
        self.velocity_x = self.speed * 2 * (1 if dx > 0 else -1)
        
        # Very rapid fire
        if self.pattern_timer >= 30:
            self.shoot_cannon_ball(player)
            self.pattern_timer = 0
    
    def shoot_cannon_ball(self, player):
        """Fire a cannon ball at the player"""
        ball = CannonBall(
            self.rect.centerx,
            self.rect.centery,
            player.rect.centerx,
            player.rect.centery
        )
        self.projectiles.add(ball)
    
    def update(self, player=None, tiles=None):
        super().update(player, tiles)
        self.projectiles.update()
    
    def draw(self, surface, camera_offset=(0, 0)):
        super().draw(surface, camera_offset)
        
        # Draw projectiles
        for ball in self.projectiles:
            ball.draw(surface, camera_offset)
        
        # Draw boss health bar at top of screen
        self.draw_boss_health_bar(surface)
    
    def draw_boss_health_bar(self, surface):
        """Draw large boss health bar at top"""
        bar_width = 500
        bar_height = 35
        x = SCREEN_WIDTH // 2 - bar_width // 2
        y = 55
        
        pygame.font.init()
        title_font = pygame.font.Font(None, 48)
        phase_font = pygame.font.Font(None, 32)
        
        # Draw intro text if in intro
        if self.intro_active:
            # Dramatic intro text
            if self.intro_timer > 30:
                intro_texts = ["THE ARCHENEMY", "CANNON", "APPEARS!"]
                text_idx = min(2, (self.intro_timer - 30) // 40)
                intro_text = title_font.render(intro_texts[text_idx], True, RED)
                intro_rect = intro_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 50))
                
                # Flashing background
                if self.frame % 8 < 4:
                    pygame.draw.rect(surface, DARK_RED, 
                                   (intro_rect.x - 20, intro_rect.y - 10, 
                                    intro_rect.width + 40, intro_rect.height + 20))
                surface.blit(intro_text, intro_rect)
            return
        
        # Boss name header - large and prominent
        name_text = title_font.render("CANNON", True, YELLOW)
        name_rect = name_text.get_rect(center=(SCREEN_WIDTH // 2, 28))
        
        # Name background panel
        panel_rect = pygame.Rect(name_rect.x - 25, name_rect.y - 8, 
                                name_rect.width + 50, name_rect.height + 16)
        pygame.draw.rect(surface, DARK_BLUE, panel_rect)
        pygame.draw.rect(surface, DARK_RED, panel_rect, 3)
        pygame.draw.rect(surface, YELLOW, panel_rect.inflate(-6, -6), 2)
        surface.blit(name_text, name_rect)
        
        # Skull decorations on sides
        skull_left = title_font.render("☠", True, RED)
        skull_right = title_font.render("☠", True, RED)
        surface.blit(skull_left, (panel_rect.left - 30, name_rect.y - 2))
        surface.blit(skull_right, (panel_rect.right + 10, name_rect.y - 2))
        
        # Health bar outer frame
        frame_rect = pygame.Rect(x - 10, y - 10, bar_width + 20, bar_height + 20)
        pygame.draw.rect(surface, DARK_BLUE, frame_rect)
        pygame.draw.rect(surface, DARK_BROWN, frame_rect, 4)
        
        # Health bar inner background
        pygame.draw.rect(surface, BLACK, (x - 2, y - 2, bar_width + 4, bar_height + 4))
        pygame.draw.rect(surface, DARK_RED, (x, y, bar_width, bar_height))
        
        # Health bar fill with gradient
        health_width = int(bar_width * (self.health / self.max_health))
        if health_width > 0:
            # Choose color based on phase
            if self.phase == 3:
                bar_color = MAGENTA
                highlight_color = PINK
            elif self.phase == 2:
                bar_color = ORANGE
                highlight_color = YELLOW
            else:
                bar_color = RED
                highlight_color = ORANGE
            
            # Main health bar
            pygame.draw.rect(surface, bar_color, (x, y, health_width, bar_height))
            # Top highlight
            pygame.draw.rect(surface, highlight_color, (x, y, health_width, bar_height // 4))
            # Bottom shadow
            pygame.draw.rect(surface, DARK_RED, (x, y + bar_height - 5, health_width, 5))
        
        # Golden border
        pygame.draw.rect(surface, YELLOW, (x - 4, y - 4, bar_width + 8, bar_height + 8), 3)
        
        # Phase indicator with dramatic styling
        if self.phase >= 2:
            phase_color = MAGENTA if self.phase == 3 else ORANGE
            phase_str = "⚡ PHASE 2 - ENRAGED ⚡" if self.phase == 2 else "💀 PHASE 3 - FINAL FORM 💀"
            phase_text = phase_font.render(phase_str, True, phase_color)
            phase_rect = phase_text.get_rect(center=(SCREEN_WIDTH // 2, y + bar_height + 18))
            
            # Flashing effect during transition
            if self.phase_transition and self.frame % 6 < 3:
                pygame.draw.rect(surface, phase_color, phase_rect.inflate(20, 10))
            surface.blit(phase_text, phase_rect)
        
        # Health percentage
        health_pct = int((self.health / self.max_health) * 100)
        pct_text = phase_font.render(f"{health_pct}%", True, WHITE)
        pct_rect = pct_text.get_rect(center=(x + bar_width // 2, y + bar_height // 2))
        surface.blit(pct_text, pct_rect)


class CannonBall(pygame.sprite.Sprite):
    """Projectile fired by Cannon boss"""
    
    def __init__(self, x, y, target_x, target_y):
        super().__init__()
        
        # Calculate direction
        dx = target_x - x
        dy = target_y - y
        dist = math.sqrt(dx * dx + dy * dy)
        
        self.speed = 5
        if dist > 0:
            self.velocity_x = (dx / dist) * self.speed
            self.velocity_y = (dy / dist) * self.speed
        else:
            self.velocity_x = self.speed
            self.velocity_y = 0
        
        self.damage = 2
        self.lifetime = 180
        
        # Create sprite
        self.image = pygame.Surface((16, 16), pygame.SRCALPHA)
        pygame.draw.circle(self.image, GRAY, (8, 8), 7)
        pygame.draw.circle(self.image, DARK_BROWN, (8, 8), 5)
        pygame.draw.circle(self.image, ORANGE, (6, 6), 2)
        
        self.rect = self.image.get_rect(center=(x, y))
    
    def update(self):
        self.rect.x += self.velocity_x
        self.rect.y += self.velocity_y
        self.lifetime -= 1
        
        if self.lifetime <= 0:
            self.kill()
    
    def draw(self, surface, camera_offset=(0, 0)):
        draw_x = self.rect.x - camera_offset[0]
        draw_y = self.rect.y - camera_offset[1]
        surface.blit(self.image, (draw_x, draw_y))


def create_enemy(enemy_type, x, y):
    """Factory function to create enemies"""
    if enemy_type == 'slime':
        return Slime(x, y)
    elif enemy_type == 'bat':
        return Bat(x, y)
    elif enemy_type == 'knight':
        return Knight(x, y)
    elif enemy_type == 'cannon':
        return Cannon(x, y)
    else:
        return Slime(x, y)  # Default

```

Now let me add the level skip feature by pressing 'c':

```python
"""
Main game class for Chain
"""

import pygame
from settings import *
from player import Player
from world_map import WorldMap
from level import Level
from ui import UI
from sounds import get_sound_manager


class Game:
    """Main game class that handles all game logic"""
    
    def __init__(self):
        pygame.init()
        pygame.display.set_caption(TITLE)
        
        self.screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        self.clock = pygame.time.Clock()
        self.running = True
        
        # Game state
        self.state = STATE_MENU
        self.paused = False
        
        # Menu
        self.menu_options = ['New Game', 'Controls', 'Quit']
        self.menu_selection = 0
        self.showing_controls = False
        
        # Game objects
        self.player = None
        self.world_map = None
        self.current_level = None
        
        # UI
        self.ui = UI()
        
        # Sound
        self.sound = get_sound_manager()
        
        # Events from last frame
        self.events = []
    
    def new_game(self):
        """Start a new game"""
        self.world_map = WorldMap()
        start_pos = self.world_map.get_start_position()
        
        self.player = Player(start_pos[0], start_pos[1], mode='world')
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def enter_level(self, level_marker):
        """Enter a side-scrolling level"""
        self.current_level = Level(level_marker.level_id, level_marker.level_type)
        self.player.set_mode('level')
        self.player.reset_position(self.current_level.start_x, self.current_level.start_y)
        self.state = STATE_LEVEL
        
        # Play appropriate music
        if level_marker.level_id == 'boss':
            self.sound.play_music('boss')
        else:
            self.sound.play_music('level')
    
    def exit_level(self, completed=False):
        """Exit current level and return to world map"""
        if completed and self.current_level:
            self.world_map.complete_level(self.current_level.level_id)
            
            # Check for victory (boss defeated)
            if self.current_level.level_id == 'boss':
                self.state = STATE_VICTORY
                return
        
        # Return to world map
        start_pos = self.world_map.get_start_position()
        self.player.set_mode('world')
        self.player.reset_position(start_pos[0], start_pos[1])
        self.current_level = None
        self.state = STATE_WORLD_MAP
        self.sound.play_music('world')
    
    def handle_events(self):
        """Handle pygame events"""
        self.events = []
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.running = False
            
            self.events.append(event)
            
            if event.type == pygame.KEYDOWN:
                if self.state == STATE_MENU:
                    self.handle_menu_input(event)
                elif self.state == STATE_PAUSE:
                    self.handle_pause_input(event)
                elif self.state == STATE_GAME_OVER:
                    self.handle_game_over_input(event)
                elif self.state == STATE_VICTORY:
                    self.handle_victory_input(event)
                elif event.key == pygame.K_ESCAPE:
                    if self.state == STATE_LEVEL:
                        self.state = STATE_PAUSE
                    elif self.state == STATE_WORLD_MAP:
                        self.state = STATE_MENU
    
    def handle_menu_input(self, event):
        """Handle menu navigation"""
        if self.showing_controls:
            if event.key in [pygame.K_RETURN, pygame.K_ESCAPE]:
                self.showing_controls = False
                self.sound.play_sound('menu')
            return
        
        if event.key == pygame.K_UP:
            self.menu_selection = (self.menu_selection - 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_DOWN:
            self.menu_selection = (self.menu_selection + 1) % len(self.menu_options)
            self.sound.play_sound('menu')
        elif event.key == pygame.K_RETURN:
            self.sound.play_sound('menu')
            if self.menu_options[self.menu_selection] == 'New Game':
                self.new_game()
            elif self.menu_options[self.menu_selection] == 'Controls':
                self.showing_controls = True
            elif self.menu_options[self.menu_selection] == 'Quit':
                self.running = False
    
    def handle_pause_input(self, event):
        """Handle pause menu"""
        if event.key == pygame.K_ESCAPE:
            self.state = STATE_LEVEL
        elif event.key == pygame.K_q:
            self.exit_level(completed=False)
    
    def handle_game_over_input(self, event):
        """Handle game over screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def handle_victory_input(self, event):
        """Handle victory screen"""
        if event.key == pygame.K_RETURN:
            self.state = STATE_MENU
            self.sound.play_music('menu')
    
    def update(self):
        """Update game state"""
        if self.state == STATE_WORLD_MAP:
            self.update_world_map()
        elif self.state == STATE_LEVEL:
            self.update_level()
    
    def update_world_map(self):
        """Update world map state"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get walkable tiles
        walkable_tiles = self.world_map.get_walkable_tiles()
        self.player.update(walkable_tiles)
        
        # Update world map
        self.world_map.update(self.player)
        
        # Check for level entry
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_RETURN:
                marker = self.world_map.get_current_level_marker(self.player.rect)
                if marker and not marker.completed:
                    self.enter_level(marker)
    
    def update_level(self):
        """Update side-scrolling level"""
        keys = pygame.key.get_pressed()
        self.player.handle_input(keys, self.events)
        
        # Get tiles for collision
        tiles = self.current_level.get_tiles()
        self.player.update(tiles)
        
        # Update level
        self.current_level.update(self.player)
        
        # Check item collection
        items_before = len(self.current_level.item_manager.items)
        self.current_level.item_manager.check_collection(self.player)
        if len(self.current_level.item_manager.items) < items_before:
            self.sound.play_sound('pickup')
        
        # Check enemy collisions
        self.check_combat()
        
        # Check if player fell in a pit
        if self.player.fell_in_pit(self.current_level.height):
            # Lose 1 health and respawn at last safe position
            self.player.health -= 1
            self.sound.play_sound('hit')
            if self.player.health <= 0:
                self.state = STATE_GAME_OVER
            else:
                self.player.respawn_at_safe_position()
                self.player.invincibility = PLAYER_INVINCIBILITY_FRAMES
        
        # Check player death
        if self.player.health <= 0:
            self.state = STATE_GAME_OVER
        
        # Check for level skip cheat (press C to complete level)
        for event in self.events:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_c:
                self.current_level.completed = True
        
        # Check level completion
        if self.current_level.completed:
            self.exit_level(completed=True)
    
    def check_combat(self):
        """Handle combat between player and enemies"""
        camera_offset = self.current_level.get_camera_offset()
        
        # Player attack
        attack_rect = self.player.get_attack_rect()
        if attack_rect:
            for enemy in self.current_level.enemies:
                if attack_rect.colliderect(enemy.rect):
                    if enemy.take_damage(1):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    else:
                        self.sound.play_sound('hit')
        
        # Spell projectiles
        projectiles = self.player.spell_manager.get_projectiles()
        for projectile in projectiles:
            for enemy in self.current_level.enemies:
                if projectile.rect.colliderect(enemy.rect):
                    if enemy.take_damage(projectile.damage):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
                    projectile.kill()
                    break
        
        # Thunder effects
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            for enemy in self.current_level.enemies:
                if effect.can_hit(enemy):
                    if enemy.take_damage(effect.damage):
                        self.player.add_score(enemy.score)
                        self.sound.play_sound('enemy_death')
        
        # Enemy contact damage (or instant kill if invincible)
        for enemy in list(self.current_level.enemies):
            if self.player.rect.colliderect(enemy.rect):
                if self.player.invincible_mode:
                    # Invincible mode instantly eliminates enemies!
                    self.player.add_score(enemy.score)
                    enemy.kill()
                    self.sound.play_sound('enemy_death')
                else:
                    if self.player.take_damage(enemy.damage):
                        pass  # Player died
                    else:
                        self.sound.play_sound('hit')
            
            # Check boss projectiles
            if hasattr(enemy, 'projectiles'):
                for proj in list(enemy.projectiles):
                    if self.player.rect.colliderect(proj.rect):
                        if self.player.invincible_mode:
                            proj.kill()  # Destroy projectile
                        else:
                            self.player.take_damage(proj.damage)
                            proj.kill()
    
    def draw(self):
        """Draw the current game state"""
        self.screen.fill(DARK_BLUE)
        
        if self.state == STATE_MENU:
            self.draw_menu()
        elif self.state == STATE_WORLD_MAP:
            self.draw_world_map()
        elif self.state == STATE_LEVEL:
            self.draw_level()
        elif self.state == STATE_PAUSE:
            self.draw_level()  # Draw level in background
            self.ui.draw_pause(self.screen)
        elif self.state == STATE_GAME_OVER:
            if self.current_level:
                self.draw_level()
            self.ui.draw_game_over(self.screen, self.player.score if self.player else 0)
        elif self.state == STATE_VICTORY:
            self.ui.draw_victory(self.screen, self.player.score if self.player else 0)
        
        pygame.display.flip()
    
    def draw_menu(self):
        """Draw main menu"""
        # Start menu music if not playing
        if self.sound.current_music != 'menu':
            self.sound.play_music('menu')
        
        # Draw title
        title_font = pygame.font.Font(None, 72)
        title_text = title_font.render("CHAIN", True, YELLOW)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH // 2, 120))
        self.screen.blit(title_text, title_rect)
        
        # Subtitle
        subtitle_font = pygame.font.Font(None, 32)
        subtitle = subtitle_font.render("Quest for the Lost Princess", True, CYAN)
        subtitle_rect = subtitle.get_rect(center=(SCREEN_WIDTH // 2, 170))
        self.screen.blit(subtitle, subtitle_rect)
        
        if self.showing_controls:
            self.draw_controls_screen()
        else:
            # Draw menu options
            self.ui.draw_menu(self.screen, "", self.menu_options, self.menu_selection)
        
        # Draw decorative chain character
        from sprites import create_chain_sprite
        chain_sprite = create_chain_sprite(True, pygame.time.get_ticks() // 100)
        # Scale up for menu
        big_chain = pygame.transform.scale(chain_sprite, 
                                          (chain_sprite.get_width() * 2, 
                                           chain_sprite.get_height() * 2))
        self.screen.blit(big_chain, (100, SCREEN_HEIGHT - 200))
    
    def draw_controls_screen(self):
        """Draw controls help screen"""
        controls = [
            ("Movement", "Arrow Keys / WASD"),
            ("Jump", "Space"),
            ("Attack", "Z"),
            ("Cast Spell", "X"),
            ("Select Spell", "1, 2, 3, 4"),
            ("Interact", "Enter"),
            ("Pause", "ESC"),
        ]
        
        y = 220
        for action, key in controls:
            action_text = self.ui.font_medium.render(action + ":", True, YELLOW)
            key_text = self.ui.font_medium.render(key, True, WHITE)
            self.screen.blit(action_text, (200, y))
            self.screen.blit(key_text, (400, y))
            y += 40
        
        back_text = self.ui.font_small.render("Press ENTER or ESC to go back", True, LIGHT_GRAY)
        back_rect = back_text.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
        self.screen.blit(back_text, back_rect)
    
    def draw_world_map(self):
        """Draw world map view"""
        self.world_map.draw(self.screen)
        
        # Draw player
        camera_offset = self.world_map.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw HUD
        location = self.world_map.get_location_name(self.player.rect)
        self.ui.draw_world_map_hud(self.screen, self.player, location)
    
    def draw_level(self):
        """Draw side-scrolling level"""
        self.current_level.draw(self.screen)
        
        # Draw player
        camera_offset = self.current_level.get_camera_offset()
        self.player.draw(self.screen, camera_offset)
        
        # Draw spell effects (projectiles, etc.)
        projectiles = self.player.spell_manager.get_projectiles()
        for proj in projectiles:
            draw_x = proj.rect.x - camera_offset[0]
            draw_y = proj.rect.y - camera_offset[1]
            self.screen.blit(proj.image, (draw_x, draw_y))
        
        effects = self.player.spell_manager.get_effects()
        for effect in effects:
            draw_x = effect.rect.x - camera_offset[0]
            draw_y = effect.rect.y - camera_offset[1]
            self.screen.blit(effect.image, (draw_x, draw_y))
        
        # Draw HUD
        self.ui.draw_hud(self.screen, self.player)
        self.ui.draw_level_name(self.screen, self.current_level.name)
    
    def run(self):
        """Main game loop"""
        while self.running:
            self.handle_events()
            self.update()
            self.draw()
            self.clock.tick(FPS)
        
        pygame.quit()

```

Done! Now you can press **'C'** during any side-scrolling level to instantly complete it and return to the world map. This works for all levels including the boss fight.

**Summary of changes:**
1. **Fixed the Cannon crash** - Used `getattr()` to safely check for `phase_transition` attribute during early initialization
2. **Added level skip cheat** - Press 'C' to instantly complete any level

